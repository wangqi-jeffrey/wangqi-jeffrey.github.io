<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux/Linux学习网站</title>
      <link href="/2021/11/26/Linux/Linux%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/"/>
      <url>/2021/11/26/Linux/Linux%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p><strong>社区网站</strong></p><ul><li><a href="https://linux.cn/" target="_blank" rel="noopener">Linux中国</a> - 各种资讯、文章、技术</li><li><a href="https://www.shiyanlou.com/" target="_blank" rel="noopener">实验楼</a> - 免费提供了Linux在线环境，不用在自己机子上装系统也可以学习Linux，超方便实用。</li><li><a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的linux私房菜</a> - 非常适合Linux入门初学者看的教程。</li><li><a href="http://www.linuxidc.com/" target="_blank" rel="noopener">Linux公社</a> - Linux相关的新闻、教程、主题、壁纸都有。</li><li><a href="http://www.linuxde.net/" target="_blank" rel="noopener">Linux Today</a> - Linux新闻资讯发布，Linux职业技术学习！。</li><li>Linux搜索引擎：<a href="https://wangchujiang.com/linux-command/" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/</a></li></ul><p><strong>知识相关</strong></p><ul><li><a href="http://www.jianshu.com/p/59f759207862" target="_blank" rel="noopener">Linux思维导图整理</a></li><li><a href="http://www.jianshu.com/p/fe2a790b41eb" target="_blank" rel="noopener">Linux初学者进阶学习资源整理</a></li><li><a href="https://www.shiyanlou.com/courses/1" target="_blank" rel="noopener">Linux 基础入门（新版）</a></li><li><a href="http://www.jianshu.com/p/c5ae8f061cfe" target="_blank" rel="noopener">【译】Linux概念架构的理解</a> <a href="http://oss.org.cn/ossdocs/linux/kernel/a1/index.html" target="_blank" rel="noopener">En</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="noopener">Linux 守护进程的启动方法</a></li><li><a href="https://www.shiyanlou.com/questions/2992" target="_blank" rel="noopener">Linux编程之内存映射</a></li><li><a href="https://blog.huachao.me/2016/1/Linux知识点小结/" target="_blank" rel="noopener">Linux知识点小结</a></li><li><a href="https://linux.cn/article-6971-1.html" target="_blank" rel="noopener">10大白帽黑客专用的 Linux 操作系统</a></li></ul><p><strong>软件工具</strong></p><ul><li><p><a href="https://www.gitbook.com/book/alim0x/awesome-linux-software-zh_cn/details" target="_blank" rel="noopener">超赞的Linux软件</a> Github仓库<a href="https://github.com/alim0x/Awesome-Linux-Software-zh_CN" target="_blank" rel="noopener">Zh</a> <a href="https://github.com/VoLuong/Awesome-Linux-Software" target="_blank" rel="noopener">En</a></p></li><li><p><a href="http://os.51cto.com/art/201607/513796.htm" target="_blank" rel="noopener">程序员喜欢的9款最佳的Linux文件比较工具</a></p></li><li><p><a href="http://www.codeceo.com/article/5-linux-productivity-tools.html" target="_blank" rel="noopener">提高 Linux 开发效率的 5 个工具</a></p></li><li><p><a href="http://os.51cto.com/art/201603/508027.htm" target="_blank" rel="noopener">你要了解的11款面向Linux系统的一流备份实用工具</a></p></li><li><p><a href="http://www.simlinux.com/archives/264.html" target="_blank" rel="noopener">16个很有用的在线工具</a></p></li><li><p>Adobe软件的最佳替代品 <a href="https://linux.cn/article-8928-1.html" target="_blank" rel="noopener">原文在这里</a></p></li><li><ul><li><a href="https://wiki.gnome.org/Apps/Evince" target="_blank" rel="noopener">Evince (Adobe Acrobat Reader)</a> 一个“支持多种文档格式的文档查看器”，可以查看PDF，还支持各种漫画书格式</li><li><a href="https://pixlr.com/" target="_blank" rel="noopener">Pixlr (Adobe Photoshop)</a> 一个强大的图像编辑工具</li><li><a href="https://inkscape.org/zh/" target="_blank" rel="noopener">Inkscape (Adobe Illustrator)</a> 一个专业的矢量图形编辑器</li><li><a href="https://pinegrow.com/" target="_blank" rel="noopener">Pinegrow Web Editor (Adobe Dreamweaver)</a> 一个可视化编辑制作 HTML 网站</li><li><a href="https://www.scribus.net/" target="_blank" rel="noopener">Scribus (Adobe InDesign)</a> 一个开源电子杂志制作软件</li><li><a href="https://webflow.com/" target="_blank" rel="noopener">Webflow (Adobe Muse)</a> 一款可以帮助用户不用编码就可以快速创建网站的谷歌浏览器插件。</li><li><a href="http://www.maefloresta.com/portal/" target="_blank" rel="noopener">Tupi (Adobe Animate)</a> 一款可以创建HTML5动画的工具。</li><li><a href="https://www.blackmagicdesign.com/" target="_blank" rel="noopener">Black Magic Fusion (Adobe After Effects)</a> 一款先进的合成软件，广泛应用于视觉特效、广电影视设计以及3D动画设计等领域。</li></ul></li></ul><p><strong>中国开源镜像站点</strong></p><ul><li><p>阿里云开源镜像站：<a href="http://mirrors.aliyun.com/" target="_blank" rel="noopener">http://mirrors.aliyun.com/</a></p></li><li><p>网易开源镜像站：<a href="http://mirrors.163.com/" target="_blank" rel="noopener">http://mirrors.163.com/</a></p></li><li><p>搜狐开源镜像站：<a href="http://mirrors.sohu.com/" target="_blank" rel="noopener">http://mirrors.sohu.com/</a></p></li><li><p>北京交通大学：<a href="http://mirror.bjtu.edu.cn/" target="_blank" rel="noopener">http://mirror.bjtu.edu.cn/</a> &lt;教育网荐&gt;</p></li><li><p>兰州大学：<a href="http://mirror.lzu.edu.cn/" target="_blank" rel="noopener">http://mirror.lzu.edu.cn/</a> &lt;西北高校FTP搜索引擎&gt;</p></li><li><p>厦门大学：<a href="http://mirrors.xmu.edu.cn/" target="_blank" rel="noopener">http://mirrors.xmu.edu.cn/</a></p></li><li><p>上海交通大学：<a href="http://ftp.sjtu.edu.cn/" target="_blank" rel="noopener">http://ftp.sjtu.edu.cn/</a></p></li><li><p>清华大学：<a href="http://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/</a></p></li><li><ul><li><a href="http://mirrors6.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors6.tuna.tsinghua.edu.cn/</a></li><li><a href="http://mirrors4.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">http://mirrors4.tuna.tsinghua.edu.cn/</a></li></ul></li><li><p>中国科学技术大学：<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></p></li><li><ul><li><a href="http://ipv4.ustc.edu.cn/" target="_blank" rel="noopener">http://ipv4.ustc.edu.cn/</a> &lt;教育网、电信&gt;</li><li><a href="http://ipv6.ustc.edu.cn/" target="_blank" rel="noopener">http://ipv6.ustc.edu.cn/</a> </li></ul></li><li><p>东北大学：<a href="http://mirror.neu.edu.cn/" target="_blank" rel="noopener">http://mirror.neu.edu.cn/</a></p></li><li><p>浙江大学：<a href="http://mirrors.zju.edu.cn/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/</a></p></li><li><p>东软信息学院：<a href="http://mirrors.neusoft.edu.cn/" target="_blank" rel="noopener">http://mirrors.neusoft.edu.cn/</a></p></li></ul><p><strong>游戏玩家发行版</strong></p><p><em>面向游戏玩家的八款最佳 Linux 发行版，本文由开源中国整理，</em><a href="https://my.oschina.net/editorial-story/blog/888795" target="_blank" rel="noopener"><em>原文在这里</em></a>。</p><ul><li><a href="http://store.steampowered.com/livingroom/SteamOS/" target="_blank" rel="noopener">SteamOS</a> <a href="http://store.steampowered.com/steamos/buildyourown" target="_blank" rel="noopener">官方文档</a> <a href="http://repo.steampowered.com/download/" target="_blank" rel="noopener">镜像下载</a></li><li><a href="https://ualinux.com/en/ubuntu-gamepack" target="_blank" rel="noopener">Ubuntu GamePack</a> <a href="https://ualinux.com/en/ubuntu-gamepack" target="_blank" rel="noopener">下载地址</a></li><li><a href="https://www.oschina.net/p/fedora_linux" target="_blank" rel="noopener">Fedora – Games Spin</a> <a href="https://labs.fedoraproject.org/en/games/" target="_blank" rel="noopener">下载地址</a></li><li><a href="https://www.oschina.net/p/sparkylinux" target="_blank" rel="noopener">SparkyLinux – GameOver Edition</a> <a href="https://sparkylinux.org/download/#special" target="_blank" rel="noopener">下载地址</a></li><li><a href="http://www.lakka.tv/" target="_blank" rel="noopener">Lakka</a> <a href="http://www.lakka.tv/disclaimer/" target="_blank" rel="noopener">下载地址</a></li><li><a href="http://gamedrift.org/" target="_blank" rel="noopener">Game Drift Linux</a> <a href="http://gamedrift.org/Download.html" target="_blank" rel="noopener">下载地址</a></li><li><a href="https://solus-project.com/" target="_blank" rel="noopener">Solus</a> <a href="https://solus-project.com/download/" target="_blank" rel="noopener">下载地址</a></li><li><a href="https://sourceforge.net/projects/mgame/" target="_blank" rel="noopener">Manjaro Gaming Edition (mGAMe)</a> [下载地址](</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Guide</title>
      <link href="/2021/11/13/Hexo-Guide/"/>
      <url>/2021/11/13/Hexo-Guide/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="More-Links"><a href="#More-Links" class="headerlink" title="More Links"></a>More Links</h3><p><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">Hexo搭建教程</a> </p><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">更多主题</a></p><p><a href="https://hexo.io/plugins/" target="_blank" rel="noopener">更多插件</a></p><p><a href="https://github.com/monniya/hexo-theme-new-vno" target="_blank" rel="noopener">hexo-new-vno主题</a></p><p><a href="https://huangweicai.github.io/" target="_blank" rel="noopener">Demo3</a></p><p><a href="https://www.yanbinghu.com" target="_blank" rel="noopener">Demo4</a></p><p><a href="http://darryrzhong.xyz/" target="_blank" rel="noopener">Demo5</a></p><p><a href="https://www.yangguo.info/2014/05/19/Kryo2.22翻译/" target="_blank" rel="noopener">Demo6</a></p><p><a href="https://www.yangguo.info/" target="_blank" rel="noopener">Demo7</a></p><p><a href="https://suyin-blog.club/categories/" target="_blank" rel="noopener">Demo8-Hexo使用</a></p><p><a href="https://www.gagahappy.com/" target="_blank" rel="noopener">Demo9</a></p><p><a href="https://eyhn.in/about/" target="_blank" rel="noopener">Demo10</a></p><p><a href="http://51world.win/" target="_blank" rel="noopener">Demo11</a></p><p><a href="http://whx4j8.github.io/" target="_blank" rel="noopener">Demo12</a></p><p><a href="https://www.strongerhuang.com/" target="_blank" rel="noopener">Demo13</a></p><p><a href="https://www.lushaojun.com/links" target="_blank" rel="noopener">Demo14</a></p><p><a href="https://ahh666.com/categories/" target="_blank" rel="noopener">Demo15</a></p><p><a href="https://yuchen-lea.github.io/2016-01-18-hexo-dir-struct/" target="_blank" rel="noopener">Demo16</a></p><p><a href="https://icodebook.com/posts/kafka-navigator" target="_blank" rel="noopener">Demo17</a></p><p>干掉这里的bug：<a href="https://www.wangtianyi.top/" target="_blank" rel="noopener">https://www.wangtianyi.top/</a></p><p><a href="http://guoyanjun.top" target="_blank" rel="noopener">http://guoyanjun.top</a></p><p><a href="http://www.xiangzhihong.com/" target="_blank" rel="noopener">http://www.xiangzhihong.com/</a></p><p><a href="http://tombraiderjf.com/" target="_blank" rel="noopener">http://tombraiderjf.com/</a></p><p><a href="https://lemonx.cn/" target="_blank" rel="noopener">https://lemonx.cn/</a></p><p><a href="https://liushiqi.xyz/zawen/1.html" target="_blank" rel="noopener">https://liushiqi.xyz/zawen/1.html</a></p><p><a href="https://www.cnblogs.com/hujunzheng/p/10887937.html#autoid-5-0-0" target="_blank" rel="noopener">https://www.cnblogs.com/hujunzheng/p/10887937.html#autoid-5-0-0</a></p><p><a href="https://morning-pro.github.io/categories/Redis/" target="_blank" rel="noopener">https://morning-pro.github.io/categories/Redis/</a></p><p><a href="https://crossoverjie.top/" target="_blank" rel="noopener">https://crossoverjie.top/</a></p><p><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo中文网</a></p><p><a href="https://www.javazhiyin.com/" target="_blank" rel="noopener">Java知音</a></p><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT主题设置</a></p><p><a href="https://fontawesome.com/" target="_blank" rel="noopener">图标库</a></p><p><a href="https://www.javazhiyin.com/" target="_blank" rel="noopener">友情链接-Java知音</a></p><p><a href="http://wangwenming.github.io/" target="_blank" rel="noopener">桉树</a></p><p><a href="https://ikaros-521.github.io/" target="_blank" rel="noopener">https://ikaros-521.github.io/</a></p><p><a href="https://kalasearch.cn/" target="_blank" rel="noopener">卡拉搜索</a></p><h2 id="Getting-Help"><a href="#Getting-Help" class="headerlink" title="Getting Help"></a>Getting Help</h2><h3 id="本地启动测试："><a href="#本地启动测试：" class="headerlink" title="本地启动测试："></a>本地启动测试：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line"></span><br><span class="line">## 缩写</span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><h3 id="Hexo-使用经验"><a href="#Hexo-使用经验" class="headerlink" title="Hexo 使用经验"></a>Hexo 使用经验</h3><ul><li>插入本地图片：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![Image zoo](Git实战分享/image2019-1-25_20_50_37.png)</span><br><span class="line">在当前文件下新建与文件名相同目录存放图片</span><br><span class="line">注意：文件名不能存在空格，否则不生效</span><br></pre></td></tr></table></figure><ul><li>锚点目录生成不规则-临时解决方案：使用h4标题，参考文章：Git 实战分享</li><li>锚点目录生成不规则-终极解决方案：<a href="https://www.jianshu.com/p/588ab3d22eb8（后续优化）" target="_blank" rel="noopener">https://www.jianshu.com/p/588ab3d22eb8（后续优化）</a></li><li>换机方法：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">将本级整个目录拷贝到另一台机器wangqi-jeffrey.github.io</span><br><span class="line">执行命令：npm install hexo-cli -g</span><br><span class="line">然后进到wangqi-jeffrey.github.io执行npm install</span><br><span class="line">hexo s 测试</span><br><span class="line">github认证失败后选择令牌方式登录</span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">'git'</span></span><br><span class="line">  repo: git@github.com:wangqi-jeffrey/wangqi-jeffrey.github.io.git</span><br></pre></td></tr></table></figure><h3 id="未解决问题"><a href="#未解决问题" class="headerlink" title="未解决问题"></a>未解决问题</h3><ul><li><p>多台Mac同步后，博客更新日期不一致问题</p></li><li><p>图片不展示问题-临时解决方案：单台机器发布</p></li><li><p>图片不展示问题-终极解决方案：</p><p><a href="https://github.com/xcodebuild/hexo-asset-image/issues/47" target="_blank" rel="noopener">https://github.com/xcodebuild/hexo-asset-image/issues/47</a></p><p>/Users/jeffrey/wangqi-jeffrey.github.io/node_modules/hexo-asset-image</p></li></ul><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>node版本：v12.19.0；高版本会报错</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Troubleshooting/项目上线常见问题汇总及处理方案</title>
      <link href="/2021/11/11/Troubleshooting/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/"/>
      <url>/2021/11/11/Troubleshooting/%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="编者按"><a href="#编者按" class="headerlink" title="编者按"></a>编者按</h2><p>本文受启发于支付团队一次项目上线中遇到的问题，特结合自身经验，对一些常见问题做统一整理，给出一些解决方案，以供参考。</p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="1-需求改动点多，涉及较多项目，构建及发布耗时太长"><a href="#1-需求改动点多，涉及较多项目，构建及发布耗时太长" class="headerlink" title="1. 需求改动点多，涉及较多项目，构建及发布耗时太长"></a>1. 需求改动点多，涉及较多项目，构建及发布耗时太长</h3><p>解决方案：</p><ul><li>改动的模块越多，带来的不确定性就越大，需要考虑是否可以分拆需求，每次只做少量更新。<br>拆分的维度：1.功能上，2.前后端。</li><li>思考业务模块划分的合理性，如果可以，从功能的角度对模块的划分做一些优化，从公用及特性化的角度划分，做好各个模块之间的接口设计。</li></ul><h3 id="2-产品上线环节验收周期长，产品经理投入度不够"><a href="#2-产品上线环节验收周期长，产品经理投入度不够" class="headerlink" title="2. 产品上线环节验收周期长，产品经理投入度不够"></a>2. 产品上线环节验收周期长，产品经理投入度不够</h3><p>解决方案：</p><ul><li>提前确定好上线时间，尽量与产品提前沟通，尽可能协调大家的时间集中火力，速战速决。</li></ul><h3 id="3-上线后发现功能与产品预期不一致"><a href="#3-上线后发现功能与产品预期不一致" class="headerlink" title="3. 上线后发现功能与产品预期不一致"></a>3. 上线后发现功能与产品预期不一致</h3><p>解决方案：</p><ul><li>需求经评审后，不应该再做变动，如有变动需要通过变更流程（可以按较轻的流程处理），变动应第一时间知会开发人员，开发人员评估后，应给出反馈，如对项目计划有影响，应提前告知</li><li>产品经理需要在上线前做功能性验收，尤其是有需求变动的项目。</li><li>正式发布前的上线审批环节，应加入”产品经理确认-功能已实现”的环节。显式的流程有助于提醒产品经理，在开发完成或者测试完成后做功能验收，而不至于在上线后才发现，打乱上线节奏。</li></ul><h3 id="4-上线后发现某些功能验证困难或者无法验证"><a href="#4-上线后发现某些功能验证困难或者无法验证" class="headerlink" title="4. 上线后发现某些功能验证困难或者无法验证"></a>4. 上线后发现某些功能验证困难或者无法验证</h3><p>解决方案：</p><ul><li>设计或者开发阶段应考虑的功能的可测试性，从技术角度做一些工作，比如可以增加一些特殊的配置，减少这种问题的影响</li><li>如确实无法避免，应该提前考虑，提前告知，让大家有所准备。</li><li>考虑将验证环节遗留到可以验证的时候再进行</li></ul><h3 id="5-上线过程遇到预期外的环境问题（服务器、网络等等）"><a href="#5-上线过程遇到预期外的环境问题（服务器、网络等等）" class="headerlink" title="5. 上线过程遇到预期外的环境问题（服务器、网络等等）"></a>5. 上线过程遇到预期外的环境问题（服务器、网络等等）</h3><p>解决方案：</p><ul><li>此问题可能无法100%避免，因此建议提前将发布时间、发布方案告知运维人员，尽可能在运维人员知晓并能配合的时间发布，避免出现有问题时找不到人处理的情况，而延误上线计划。</li></ul><h3 id="6-上线过程中发现依赖的内部或者外部资源并未准备好"><a href="#6-上线过程中发现依赖的内部或者外部资源并未准备好" class="headerlink" title="6. 上线过程中发现依赖的内部或者外部资源并未准备好"></a>6. 上线过程中发现依赖的内部或者外部资源并未准备好</h3><p>依赖资源包括但不限于：数据库库表结构、数据库权限、网络策略、IP白名单授权、依赖的内外部服务等<br>解决方案：</p><ul><li>上线前增加梳理依赖资源的环节，将可以在上线前准备好的依赖资源申请或者准备好，并做好验证。（多数依赖项可以独立与上线过程提前准备）</li><li>提前知会依赖的内外部资源的相关干系人，以便出现问题时能及时联系</li><li>对于依赖的外部资源更要协调好可以支持的时间。</li></ul><h3 id="7-上线验证环节发现了功能性Bug"><a href="#7-上线验证环节发现了功能性Bug" class="headerlink" title="7. 上线验证环节发现了功能性Bug"></a>7. 上线验证环节发现了功能性Bug</h3><p>解决方案：</p><ul><li>及时上报已发现的问题，对问题的严重性及影响做评估，并及时报告</li><li>对问题的严重性及影响做好评估，采取下一步措施：1.发布中止，回退，2. 继续发布，已经发现的问题在后续版本修复，3. 发布暂停，立即修复问题，完成后继续发布。对于需要立即修复的问题，一定不要操之过急，避免在修复问题的同时引入新的问题。</li></ul><h3 id="8-项目上线后，一些依赖该项目的产品或者服务发现异常情况"><a href="#8-项目上线后，一些依赖该项目的产品或者服务发现异常情况" class="headerlink" title="8. 项目上线后，一些依赖该项目的产品或者服务发现异常情况"></a>8. 项目上线后，一些依赖该项目的产品或者服务发现异常情况</h3><p>此情况可能发生在一些对公共模块的修改中。<br>解决方案：</p><ul><li>首先在项目开始阶段，应该正确评估此类模块修改的影响，对于已有的接口尽量采用兼容性的修改，对于无法兼容的情况，应该及时告知调用方做必要的修改。</li><li>问题出现后，及时上报，遇到不能快速修复问题，应及时回退已更新的模块，避免造成更大的影响。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上便是结合历史项目的经验，对一些常见问题整理，并给出的考虑解决方案，希望对后续项目上线有所参考。总体上讲，应该坚持：早准备、早评估，早发现，早解决。对于可能出现的问题应该有所预见，这样才能临危不乱，游刃有余。</p><p>欢迎评论、补充、讨论。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>管理/【有效沟通】跨部门沟通的10个原则</title>
      <link href="/2021/11/11/%E7%AE%A1%E7%90%86/%E3%80%90%E6%9C%89%E6%95%88%E6%B2%9F%E9%80%9A%E3%80%91%E8%B7%A8%E9%83%A8%E9%97%A8%E6%B2%9F%E9%80%9A%E7%9A%8410%E4%B8%AA%E5%8E%9F%E5%88%99/"/>
      <url>/2021/11/11/%E7%AE%A1%E7%90%86/%E3%80%90%E6%9C%89%E6%95%88%E6%B2%9F%E9%80%9A%E3%80%91%E8%B7%A8%E9%83%A8%E9%97%A8%E6%B2%9F%E9%80%9A%E7%9A%8410%E4%B8%AA%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p><strong>跨部门沟通不良，可能会让他好不容易建立起来的自信瞬间摧毁。</strong></p><p>你认为十万火急的事，到了其它部门主管口中，竟然成了“芝麻绿豆大的事”；原本应该合作解决的问题，到了跨部门会议上，又沦为“各弹各的调”，找不到共识。</p><p>到底，在不同部门各有不同立场与利益的情况下，怎样才能把话说清楚，把成果做出来？很多人抱怨为什么跨部门沟通这么难？其实，只要掌握几个典型基本原则，进行无障碍的跨部门沟通，并非难事。</p><p><strong>原则1：沟通前先做好准备</strong></p><p>在你跟同事讨论事情之前，先把一些基本问题想清楚，不要毫无准备就去，否则很可能得不到你想要的东西。下面的几个问题应该事先想清楚：</p><ol><li>你希望对方帮你做什么事？</li><li>你认为他会要求你做什么？</li><li>如果对方不同意你提出来的做法，有没有其它选择方案？</li><li>如果双方没共识，你会有什么后果？对方又会有什么后果？</li></ol><p><strong>原则2：了解其它部门的语言</strong></p><p>跨部门沟通不良，很多时候都是“语言不通”所引起。举例来说，营销部人员平常讲的是“相同语言”，他们非常清楚自己部门的规则、目标与期望。同样地，财务、生产、人资等部门，也有自己的语言与观点。因此，想要沟通顺畅，前提就是“听懂对方的语言”。原则2的一个重要方法是换位思考，试着站在对方的立场思考：</p><ol><li>这么做，对业务部的业绩有帮助吗？</li><li>如果我是他，会接受这种做法吗？</li><li>这个方法真的有用吗？</li></ol><p>跨部门的换位思考法能将误解或沟通频率不搭的机率降到最低。此外，频繁的互动有助于建立彼此的熟识度，让你更容易设身处地想问题。因此，时不时的跟其它部门的同事吃吃饭、聊聊天，有好无坏。</p><p><strong>原则3：开诚布公是最好的对策</strong></p><p>你面对的是必须长期共事的同事，因此，凡事以诚实为上策，最忌欺骗、隐瞒事实，破坏信任关系。部门间一旦缺乏信任感，会加重彼此的防御心，沟通时就会有所保留，甚至隐藏一些重要信息。相反的，互信会让双方在沟通时打开心防，他们会明白说出自己的需求与考虑，并且提高合作意愿，共同解决问题。诚信沟通有四个要素：</p><ol><li>错的不要解释；</li><li>务必不要争执</li><li>不打断对方说话；</li><li>微笑再微笑；</li></ol><p>频繁的互动有助于建立彼此的熟识度，让你更容易设身处地想问题。因此，时不时的跟其它部门的同事吃吃饭、聊聊天，有好无坏。</p><p><strong>原则4：不要害怕冲突</strong></p><p>在跨部门会议上，每个主管为了维护自己部门的利益，难免会出现一些摩擦。有些主管，尤其是新手主管，为了怕把气氛弄僵，往往会变得沉默寡言，以维持表面的和谐。艾林哈特在《有效沟通》一书中点出，“如果管理团队在议题的讨论上都没有冲突，决策质量就会低落。”艾林哈特提醒，千万别把“没有冲突”跟“意见一致”混为一谈。</p><p>有时候，太过和谐反而凸显不了你对议题的重视，而且问题也不会获得真正的解决。因此，艾林哈特建议经理人，态度要柔软，但立场要坚定，“别太快或太轻易就顺从认命。”记住，你是部门主管，虽然你要和其它部门保持良好关系，但是，捍卫部门及部属的权益，更是你责无旁贷的使命。</p><p><strong>原则5：呈现事实，专注中心议题</strong></p><p>让沟通聚焦的最好方式，就是呈现具体事实，引导人们迅速将注意力放在中心议题上，减少不当的臆测。</p><p>美国达顿商学院企管教授布尔乔亚三世在《哈佛商业评论》中为文指出，事实（例如目前销量、市占率、研发经费、竞争对手的行为等）可以将沟通过程中“人”的因素降到最低。在缺乏事实的情况下，个人动机可能会遭到猜疑，但“事实就是事实”，它不是出自人的幻想或自私的欲望，因此，提出事实“可以创造一种强调议题，而非人身攻击的氛围。”布尔乔亚三世说。</p><p><strong>原则6：多提选项，保持弹性</strong></p><p>当你进行跨部门协商时，不要执着在单一做法上，而是开发多元选项，例如一次提出3～5个方案，让其它经理人有更大的选择空间。</p><p>专家分析，多元选项能让选择不再“非黑即白”，经理人有较大的弹性调整自己的支持度，也可以轻易变换立场，不觉得有失颜面，因此能够降低沟通时的人际冲突。</p><p><strong>原则7：创造共同目标一起合作</strong></p><p>无可讳言，各部门间一定同时存在合作与竞争关系。部门间若想进行建设性的沟通，一定要强调彼此的合作关系，竞争意味愈淡愈好。合作的关键在于拥有共同目标。</p><p>因此，尽量去创造一个横跨各部门的共同目标，然后一起努力，就算有争执也没关系。因为，就如苹果计算机创办人贾伯斯所言：“如果每个人都要去旧金山，那么，花许多时间争执走哪条路并不是问题。但如果有人要去旧金山，有人要去圣地亚哥，这样的争执就很浪费时间了。在跨部门沟通中，达成一致的目标需要弄清楚四个问题：</p><ol><li>双方的共同目标是什么？</li><li>有什么阻碍双方合作？</li><li>创造共同目标的资源是什么？</li><li>合作的价值是什么？</li></ol><p><strong>原则8：尊重沟通对象的权力</strong></p><p>每个经理人都是各自管辖范围内最有权力的决策者，而他们也期待别人尊重他的这种权力。因此，当你在进行横向沟通时，一定要挑对对象。</p><p>举例来说，你们最新的网络营销计划下周就要上路了，但是信息部门的网站建置还未完成。这时，不要心急地马上跑去找负责的工程师，你应该去找他的主管，进行协调，找出解决之道。</p><p>总之，跨部门沟通时一定要注意彼此位阶的对等关系，以免造成不必要的误会。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Troubleshooting/开发常见问题以及解决方案</title>
      <link href="/2021/11/04/Troubleshooting/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2021/11/04/Troubleshooting/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><strong>注意：</strong>如果是gradle项目，先删除build文件夹再试</p><p><strong>1.项目启动总是启动 The following profiles are active: test</strong></p><p>解决：先使用bootRun运行，删除module重新导入到项目</p><p><strong>2.gradle打jar包总是打不进最新代码问题</strong></p><p>解决：</p><p><strong>3.错误: 找不到或无法加载主类 com.huifenqi.usercomm.Application</strong></p><p>解决：删除build文件夹、build-&gt;clean、删除gradle文件夹、删除out文件夹、检查代码是否构建成功</p><p><img src="/2021/11/04/Troubleshooting/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20210612173252201.png" alt="image-20210612173252201"></p><p><strong>4.mac idea偶尔找不到依赖，全部代码报错问题：</strong></p><p>解决方案：打开gradle面板，点击刷新重新导入包就可以，或者执行gradle clean</p><p><img src="/2021/11/04/Troubleshooting/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20210612173317202.png" alt="image-20210612173317202"></p><p><strong>5.idea编辑器突然不能输入：</strong></p><p>本质上是键盘失灵，更新idea？点击Application下拉框:果然有效，或者点击顶部菜单试试、或者狂点编辑区</p><p>解决方案：用鼠标拖动以下里面的字符试试</p><p><strong>6.idea专治各种不服，删除build\gradle和idea.imi 使用bootRun build-&gt;clean等</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English</title>
      <link href="/2021/11/04/English/"/>
      <url>/2021/11/04/English/</url>
      
        <content type="html"><![CDATA[<p>Microservices    微服务<br>Distributed Systems    分布式系统<br>Patterns    模式<br>Observe    观察<br>Logic         逻辑<br>circuit        电路<br>breaker      断路器<br>discovery   发现<br>obtained     获得<br>archives     档案，归档<br>cycle          周期，循环<br>upgrade     升级<br>summary    概要、摘要<br>purchase    采购、购买<br>interview     面试<br>enhance     加强<br>location      [ ləu’keiʃən]  位置(文件在电脑中的位置)<br>encoding    [in’kəudiŋ]  编码<br>Folder        [‘fəʊldə] 文件夹<br>cost estimator 成本估算器<br>standard    标准版<br>enterprise  企业版<br>tiers            层级<br>usage         用法<br>invoices      发票<br>specify        指定<br>tutorial         教程，说明<br>troubleshooting  故障排除<br>Launcher    发射器<br>Placeholder 占位符<br>Tracing 追踪<br>Metrics 指标<br>in depth 深入<br>Concepts 概念</p><p>透视图  perspective figure<br>内容助理（自动代码提示）：设置快捷键 General–&gt;keys–&gt;content assist<br>内省—-&gt;IntroSpector<br>Properties            [ ‘prɔpətis]  属性,性能<br>View                  [ vju: ]  视图,  视线,看<br>Show view             显示视图<br>Refresh               [ri’freʃ] 更新,刷新<br>Edit                  [‘edit]  编辑<br>Project               [prədʒekt]  项目,工程,计划<br>Preference            [‘prefə rəns]  个人喜好/在汉化版中是”属性”<br>rename                [,ri:’neim]  改名,重新命名 (F2 快捷键)<br>template              [‘templit]  模板<br>console               [kən’səul]  控制台<br>font                  [fɔnt] 字体<br>syntax                [‘sintæks]  语法<br>bracket               [‘brækit]   括号<br>keyword                           [‘ki:wə:d]  关键字<br>excluding                         [ik’sklu:diŋ]  将…排除在外</p><p>1–Java中的23种设计模式<br>1.Factory（工厂模式）<br>2.Builder（建造模式）<br>3.Factory Method（工厂方法模式）<br>4.Prototype（原始模型模式）<br>5.Singleton（单例模式）<br>6.Facade（门面模式）<br>7.Adapter（适配器模式）<br>8.Bridge（桥梁模式）<br>9.Composite（合成模式）<br>10.Decorator（装饰模式）<br>11.Flyweight（享元模式）<br>12.Proxy（代理模式）<br>13.Command（命令模式）<br>14.Interpreter（解释器模式）<br>15.Visitor（访问者模式）<br>16.Iterator（迭代子模式）<br>17.Mediator（调停者模式）<br>18.Memento（备忘录模式）<br>19.Observer（观察者模式）<br>20.State（状态模式）<br>21.Strategy（策略模式）<br>22.Template Method（模板方法模式）<br>23.Chain Of Responsibleity（责任链模式）</p><p>4–J2EE的核心技术</p><p>JDBC(Java Database Connectivity)<br>JNDI(Java Name and Directory Interface)<br>EJB(Enterprise JavaBean)<br>RMI(Remote Method Invoke)<br>Java IDL/CORBA<br>JSP(Java Server Pages)<br>Java Servlet<br>XML(Extensible Markup Language)<br>JMS(Java Message Service)<br>JTA(Java Transaction Architecture)<br>JTS(Java Transaction Service):<br>JavaMail<br>JAF(JavaBeans Activation Framework)</p><p>OSS<br>     Object Storage Service静态存储</p><p>ECS<br>      云服务器(Elastic Compute Service)</p><p>SLB<br>     服务器负载均衡（Server Load Balancing）</p><p>RDS<br>     关系型数据库服务（Relational Database Service）<br>AWT<br>抽象窗口工具集(Abstract Window Toolkit)<br>IFC<br>（Internet Foundation Classes）<br>GUI<br>Graphical User Interface(图形用户接口)（图形用户界面）<br>CLI<br>    Command line User Interface (命令行用户接口<br>JFC<br>Swing。AWT、Swing、辅助功能API、2DAPI以及拖放API共同组成JFC（Java Foundation Classes）<br>JAVA EE<br> 全称 java platform enterprise edition java企业级平台 适用于创建服务器应用程序和服务的Java 2平台企业版（Java2 Platform Enterprise Edition，Java EE）</p><p>JAVA SE<br>适用于桌面系统的Java 2平台标准版（Java2 Platform Standard Edition，Java SE）</p><p>JAVA ME<br>适用于小型设备和智能卡的Java2平台Micro版（Java2 Platform Micro Edition，J avaME）</p><p>IT<br>information technology</p><p>IDE<br>itegrity development environment</p><p>API<br>（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。<br>JMS<br>JMX<br>JNDI<br>AOP<br>Aspect oriented program ,简称AOP 面向切面<br>http:hypertext transfer protocol</p><p>SQL<br>（Structured Query Language）结构化查询语言是IBM公司San Jose实验室为System R而设计的查询语言，后被国际标准化组织（ISO）批准作为关系数据库语言的国际标准。</p><p>SUN<br>(Stanford University Network，斯坦福大学网络公司)<br>JVM<br>Java Virtual Machine</p><p>GC<br>垃圾回收机制（Garbage Collection，也被称为GC）<br>DAO<br>data  access  object 数据访问</p><p>CRUD<br>  create read update delete增删改查<br>MVC<br>Struts<br>ORM<br>Hibernate<br>IOC<br>Spring(Inversion of Control)<br>DML<br>数据操纵语言(Data Manipulation Language DML)语句<br>  用于修改表的内容<br>  INSERT 添加行<br>  UPDATE 修改行内容<br>  DELETE 删除行<br>DDL<br>数据定义语言(Data Definition Language,DDL)语句<br>  用于定义构成数据库的数据结构<br>  CREATE 创建数据库结构<br>  ALTER  修改数据库结构<br>  DROP   删除数据库结构<br>  RENAME 更改表名<br>  TRUNCATE 删除表的全部内容<br>TCL<br>事务控制(Transaction Control TC)语句<br>  用于将对行做的修改永久性存储到表中<br>  COMMIT 永久性的保存对行做的修改<br>  ROLLBACK 取消对行做的修改<br>  SAVEPOINT 设置保存点<br>DCL<br>数据控制语言(Data Control Language DCL)语句<br>  GRANT 授予其他用户对数据库访问权限<br>  REVOKE 防止其他用户访问数据结构<br>JDBC<br>全称Java Database Connectivity 即java数据库连接<br>ODBC<br>全称 Open Database Connectivity 开放数据库连接<br>POJOs<br>Plan Old Java Objects，普通的Java对象</p><p>POJO(plain old java object)：普通的java对象，有别于特殊的java对象(含继承约束等)和EJB。POJO一般只有一系列的属性和相应的get、set方法。<br>PO(persistant object):持久化对象，有别于POJO,必须对应数据库中的实体。一个PO对应数据库的一条记录。持久化对象的生命周期与数据库密切相关，只能存在于connection之中，连接关闭后，PO就消失了。 PO相对于POJO有诸多不同，比如PO中会有保存数据库entity状态的属性和方法。但是ORM(object-relation mapping)追求的目标是PO和POJO的一致，所以在程序员的日常开发中，都是将POJO作为PO使用，而将POJO转化为PO的功能交给hibernate等框架来实现。</p><p>DTO(data transfer object):数据传输对象，以前被称为值对象(VO,value object)，作用仅在于在应用程序的各个子系统间传输数据，在表现层展示。与POJO对应一个数据库实体不同，DTO并不对应一个实体，可能仅存储实体的部分属性或加入符合传输需求的其他的属性。<br>DAO(data access object):数据访问对象。提供访问数据库的抽象接口，或者持久化机制，而不暴露数据库的内部详细信息。DAO提供从程序调用到持久层的匹配。<br>BO(business object):业务对象。主要是将业务逻辑封装为一个对象，该对象可以包含一个或多个其他对象。如，”Principal”(委托人)，有”Name”,”Age”等属性，同时和”Employee”(雇员)有1对多的关系，这个”Principal”就可以作为一个与业务相关的PO。</p><p>代理 —-&gt;Proxy<br>封装—-&gt;encapsulation<br>多态—-&gt;polymiorphism        (polymorphism  多形性[,p.li’m.:fizm])<br>extends (关键字)                继承、扩展 [ik’stend]<br>default (关键字)                默认值 ;  缺省值 [di’f.:lt]<br>delimiter                    定义符;  定界符<br>Encapsulation                 [java]封装 (hiding implementation details)<br>Exception                     [java]例外;  异常 [ik’sep..n]<br>entry                        n.登录项,  输入项,         条目[‘entri]<br>enum (关键字)                   枚举<br>execute                      vt.执行 [‘eksikju:t]<br>exhibit                      v.显示,    陈列 [ig’zibit]<br>exist                        存在,    发生 [ig’zist] ‘(SQL 关键字exists)<br>fragments                    段落;  代码块 [‘fr.gm.nt]<br>FrameWork                     [java]结构,框架 [‘freimw.:k]<br>Generic                       [java]泛型 [d.i’nerik]<br>goto (保留字)                   跳转<br>heap                         n.堆 [hi:p]<br>stack                     n.堆栈 [st.k] (对应heap堆)<br>implements (关键字)             实现 [‘implim.nt]<br>import (关键字)                  引入(进口,输入)<br>Info (information [,inf.’mei..n] )  n.信息<br>Inheritance                 [java]继承 [in’herit.ns] (遗传,遗产)<br>initialize                   预置初始化 [i’ni..laiz]<br>instanceof (关键字)             运算符，用于引用变量，以检查这个对象是否是某种类型。返回 boolean值。<br>interface (关键字)              接口 [‘int.feis]<br>invoke                       vt.调用 [in’v.uk]’ ( invocation [,inv.u’kei..n])<br>Iterator                      [java]迭代器,  迭代程序<br>legal                        合法的 [‘li:g.l]<br>log                          n. 日志,记录 [l.g]<br>native (关键字)                  [‘neitiv]<br>nested                    [java]嵌套的 [‘nestid] ‘如：内部类(nested classes)<br>abstract (关键字)               抽象 [‘.bstr.kt]<br>access                       vt.访问,存取 [‘.kses]’(n.入口,使用权)<br>algorithm                    n.算法 [‘.lg.riem]<br>annotation                   [java]代码注释 [.n.u’tei..n]<br>anonymous                  adj.匿名的[.’n.nim.s]’<br>(反义：directly adv.直接地,立即[di’rektli, dai’rektli])<br>apply                        v.应用,适用 [.’plai]<br>application                  n. 应用, 应用程序 [,.pli’kei..n]’<br>(application crash  程序崩溃)<br>arbitrary                      a.任意的 [‘ɑ:bitr.ri]<br>argument                  n.参数;争论,论据 [‘ɑ:gjum.nt]’(缩写args)<br>assert (关键字)                 断言 [.’s.:t] ‘ (java 1.4  之后成为关键字)<br>associate                    n.关联(同伴,伙伴) [.’s.u.ieit]<br>attribute                    n.属性(品质,特征) [.’tribju:t]<br>boolean (关键字)                逻辑的,      布尔型<br>call                         n.v.调用;    呼叫; [k.:l]<br>circumstance                 n.事件(环境,状况) [‘s.:k.mst.ns]<br>crash                        n.崩溃,破碎 [kr..]<br>cohesion                      内聚,黏聚,结合 [k.u’hi:..n]<br>a class is designed with a single, well-focoused purpose. 应该不止这点<br>command                    n. 命令,指令 <a href="指挥,控制">k.’mɑ:nd</a><br>command-line    命令行<br>comments                     [java]文本注释 [‘k.ments]<br>compile                      [java] v.编译 [k.m’pail]’<br>compilation                  n.编辑[,k.mpi’lei..n]<br>const (保留字)<br>constant                     n.  常量,   常数,  恒量 [‘k.nst.nt]<br>continue (关键字)<br>coupling                     耦合,联结 [‘k.pli.]<br>making sure that classes know about other classes only through their APIs.<br>declare                      [java]声明 [di’kl..]<br>Overload           [java]方法的重载(不同参数列表的同名方法) [,.uv.’l.ud]<br>Override                  [java]方法的覆盖(覆盖父类的方法) [,.uv.’raid]<br>allowing a single object to be seen as having many types.<br>principle                 n.原则,原理,主义 [‘prinsipl]<br>priority                  n. 优先级 [prai’.riti]<br>process                   n. 程序,  进程 [‘pr.ses]<br>protected (关键字)           受保护的,私有的 [pr.’tektid]<br>provide                   v.规定(供应,准备,预防)[pr.’vaid]<br>refer to                  v.引用 [ri’f.:][tu:]<br>reference                 n. 参考(引用,涉及)[‘ref.r.ns]’<br>-reference variable         参量, 参考变量,引用变量<br>reflection                [java]反射 [ri’flek..n]<br>script                    n.手写体,小型程序 [skript]<br>serialized                   vt.序列化,串行化 [‘si.ri.laiz]’<br>(serializable adj.)(deserialize 反序列化,反串行化)<br>socket                    [java]网络套接字[‘s.kit]<br>statement                 程序语句;  语句 [‘steitm.nt]’ n.        陈述,指令<br>subclass                  n.子类 [‘s.bklɑ:s]’ (supertype  父类)<br>switch (关键字)              选择语句。 n.开关,道岔 [swɪtʃ]<br>synchronized (关键字)       同步(锁) [‘si.kr.naiz]<br>Thread                    [java]线程 [θred]<br>throw (关键字) throws (关键字) [θr.u]  抛出(异常)<br>transient (关键字)           瞬变;临时的[‘tr.nzi.nt]’(可序列化)<br>valid                     正确的,有效的 [‘v.lid]<br>variable                  n.变量 a.可变的[‘v..ri.bl]<br>volatile (关键字)            不稳定的[‘v.l.tail]<br>while (关键字)               循环语句。当…的时候 [hwail]</p><p><strong>java</strong> <strong>常用单词以及它的用法</strong></p><p>lang 包：</p><p><strong>字符串类的方法：</strong></p><p>character 类：</p><p>isLetter():判断是不是字母</p><p>isDigit():判断是不是数字</p><p>isWhiteSpace():判断是不是空格</p><p>isUpperCase():判断是不是大写</p><p>isLowerCase():判断是不是小写</p><p>String 类：</p><p>equals():比较对象中值是否相等</p><p>length():返回字符串长度</p><p>CompareTo():比较相同索引位置上字符的ASCII</p><p>StartsWith()：判断是否以…开头</p><p>endsWith():判断是否以…结尾</p><p>toUpperCase():将所有小写转为大写</p><p>toLowerCase():将所有大些转为小写</p><p>trim():截掉空格</p><p>indexOf():搜索某个字符在字符串中是否存在</p><p>LastIndexOf():从后往前搜索第一次遇到字符的索引</p><p>CharAt：根据下标找字符</p><p>subString：截取</p><p>concat：连结</p><p>StringBuffer 类：</p><p>append():追加</p><p>setcharAt():将下表对应的字符更改为某个字符</p><p>insert():插入字符</p><p>reverse():倒置，反置</p><p>replace():替换</p><p>toString():返回当前对象的字符串表现形式</p><p>Math 类:</p><p>static：静态</p><p>Class 类：</p><p>getClass():获得类的描述信息</p><p>getSuperClass():获得父类的描述信息</p><p>forName():java 与 sql 建立连接时使用</p><p>util 包：</p><p>Calendar 类：日历类</p><p>Calendar.getInstance();获得该类的实例</p><p>Date：日期</p><p>Date.gettime();获得毫秒数</p><p>get():获得时间组成部分</p><p>add():加上时间组成部分</p><p>set():修改时间组成部分</p><p>DAY_OF_YEAR                    这一年的第几天</p><p>DAY_OF_MONTH                       这一月的第几天</p><p>DAY_OF_WEEK                     这一周的第几天</p><p>Random          类:</p><p>Rand.nextInt             随机数</p><p>框架集合：</p><p>ArrayList：查询数据比较多时用该类</p><p>size():测试容量</p><p>get():获得集合框架中的数据</p><p>add():向集合框架中添加数据</p><p>set():修改集合框架中的数据</p><p>isEmpty():判断集合框架是否为空</p><p>indexof():搜索内容</p><p>remove():删除</p><p>clear():清空</p><p>LinkedList：当插入修改数据情况多时用该类</p><p>removeFirst():删除第一个元素</p><p>removeLast():删除最后一个元素</p><p>addFirst():添加第一个元素</p><p>addLast():添加最后一个元素</p><p>Vector 类</p><p>addElement():添加</p><p>removeElement():删除</p><p>Hashmap 类</p><p>put():添加方法</p><p>get():查询数据</p><p>remove():删除数据</p><p>IO 包</p><p>length():测试文件容量</p><p>exists():判断文件是否存在</p><p>CreateNewFile():创建新文件</p><p>delete():删除原文件</p><p>getAbsolutePath():获得文件的绝对路径</p><p>FileOutputStream():输出流</p><p>FileInputStream():输入流</p><p>字符流：</p><p>FileReader：读文件</p><p>FileWriter:写文件</p><p>BufferedReader:缓冲读取流</p><p>readline():读取一行内容</p><p>BufferedReader            字符串读取的缓冲流</p><p>write():写</p><p>newLine():换行</p><p>System.in 的read 方法，可以从控制台接受输入：</p><p>InputStreamReader()                配合 BufferedReader()使用</p><p>SQL 包</p><p>Java 与 SQL server 2005                   连接</p><p>六个步骤:</p><p>//建立数据源</p><p>//加载驱动程序</p><p>Class.forName(“sun.jdbc.odbc.JdbcOdbcDriver”);</p><p>//建立连接</p><p>Connection</p><p>con=java.sql.DriverManager.getConnection(“jdbc:\jdbc:myODBC”,”sa”,</p><p>“”);</p><p>//创建语句对象</p><p>Statement sta=con.createStatement();</p><p>//执行</p><p>SQL 语句</p><p>String strsql=”Update teacher set address=’地名’ where name=’姓名’”;</p><p>int count= sta.executeUpdate(strsql);</p><p>System.out.println (“更新了”+count+”行记录”);</p><p>//关闭连接</p><p>sta.close();</p><p>con.close();</p><p>捕捉异常</p><p>catch(ClassNotFoundException cnfe) {</p><p>cnfe.printStackTrace();</p><p>}</p><p>catch(SQLException sqle) {</p><p>sqle.printStackTrace();</p><p>}</p><p><strong>预编译语句对象：**</strong>preparedStatement**</p><p>path                  [ pɑ: θ]  路径</p><p>class                 [klɑ:s]  类</p><p>classpath             [klɑ:s’pɑ: θ]   类路径</p><p>public                [‘p ʌblik] 公共的,公用的</p><p>private               [‘praivit]  私有的,私人的</p><p>static                [‘stæ tik]  静的;静态的;静止的</p><p>void                  [vɔid] 空的,没有返回值的</p><p>main                  [mein]  主要的,重要的</p><p>System                [‘sistəm] 系统,方法</p><p>out                   [aut]  往外,出现,出外</p><p>print                 [print ]  打印</p><p>Demo                  [ ‘deməu ] 演示</p><p>version                [ ‘və:ʃən]  版本</p><p>author                 [ ‘ɔ:θə ]   作者</p><p>byte                   [bait]  字节</p><p>short                  [ʃɔ :t]  短整型</p><p>int                    [int]       整型</p><p>long                   [lɔ:ŋ]    长整形</p><p>char                   [tʃɑ:]  字符型</p><p>String                 [striŋ]    字符串类型</p><p>float                  [fləut]     单精度浮点类型</p><p>double                 [‘dʌbl]  双精度浮点型,双倍</p><p>type                   [taip]  类型</p><p>boolean                [‘bu:li:ən] 布尔类型真假二值</p><p>true                   [tru:]  真，正确的(成立的)</p><p>false                  [fɔ:ls] 假，错误的(不成立的)</p><p>binary                 [‘bainəri]   二进制</p><p>octal                  [‘ɔktəl]  八进制</p><p>hex                    [heks]   十六进制</p><p>count                  [kaunt]     计数；计算；</p><p>sum                    [ s ʌm]     总数,总计</p><p>salary                 [ ‘sæləri ] 薪水</p><p>Random                 [‘ræn dəm]      随机的</p><p>Scanner                [‘skænə]    接收输入</p><p>import                 [im’ pɔ:t]  导入,输入</p><p>if                     [if]        如果</p><p>else                   [els]       否则</p><p>switch                 [switʃ]     判断语句</p><p>case                   [keis]      实例,情况</p><p>break                  [breik]        退出</p><p>continue               [kən ‘tinju]  跳出…继续</p><p>return                 [ri tə:n]   返回</p><p>default         [di’fɔ:lt]或者的意思(在软件配置中还有默认的意思)</p><p>while                  [wail]      当……的时候</p><p>loop                   [lu:p]      循环</p><p>Max                     [ ma: k s]  最大的</p><p>Min                     [ mi n]  最小的</p><p>Function                [ ‘fʌŋ k ʃən ]  功能,函数</p><p>Method                  [ ‘me θə d    ]  方法</p><p>result                  [ ri’zʌlt ]结果</p><p>Compare                 [ kəm’ pεə ]   比较</p><p>temp                    [ tem p ]    临时</p><p>Array                   [   ə’rei   ]   数组</p><p>null                    [nʌl    ]  空,无效的</p><p>pointer                 [‘p ɔi n tə] 指针</p><p>Exception               [ ik ‘sepʃən]   异常</p><p>Error                   [ erə   ]  错误</p><p>Thread                  [  θred ]  线程,线状物</p><p>Lang                    [læŋ] language[‘læŋɡ wi dʒ]       语言的缩写</p><p>index                   [‘indeks]  角标,索引,指针</p><p>Outof                   [ a:ut ɔf] 在…之外</p><p>bound                   [baund]  范围</p><p>length                  [ leŋθ]  长度</p><p>sort                    [sɔ:t]  将…排序//Arrays.sort(arr)</p><p>select                  [si’lekt]  选择 //selectSort</p><p>bubble                  [‘bʌbl]  冒泡,气泡 //bullbeSort</p><p>change                  [ tʃeindʒ ]  改变，交换</p><p>swap                    [ swɔp ]  交换</p><p>nullpointerException       空指针异常</p><p>ArrayIndexOutOfBoundsException             数组角标越界异常</p><p>half                    [ hɑ:f   ]  一半的,半个的</p><p>search                  [ sə: tʃ]  搜索,查找</p><p>mid                     [ mid]   中间的</p><p>number                  [ ‘nʌmbə ]   数字,号码</p><p>util                    [ ju’til]是utility[ ju’tiliti   ]功能,功效 的缩写</p><p>Transition          [ træn’ziʃən]   转换 通常会用trans 为其简写形式</p><p>Object                  [ ‘ɔb    dʒi   kt ]  对象,    物体</p><p>Class member            [ ‘membə      ]  类成员</p><p>Class method               [ ‘meθəd]      ]   类方法</p><p>Class variable             [ ‘vεə riə ble ]  类变量</p><p>Constructor                [ kən’strʌktə ]    构造方法,构造器</p><p>package                    [ ‘pækidʒ]    包</p><p>Car                        [ kɑ: ]  汽车,小轿车</p><p>Color                      [ ‘kʌlə]    颜色</p><p>Red                        [ red ] 红色</p><p>Blue                       [ blu: ]蓝色</p><p>Black                      [ blæ k]     黑色</p><p>White                      [ hwait ]   白色</p><p>run                        [ run]  跑,    运行</p><p>Person                     [ ‘pə:sən ]   人</p><p>People                     [ ‘pi:pl ]  人,人们</p><p>Age                        [ eidʒ]  年龄</p><p>Name                       [ neim ]  名字,名称,名誉,名人</p><p>Speak                      [ spi:k]  说话,讲话,</p><p>set                        [ set]  设置</p><p>reset                      [r i set]  重新设置</p><p>get                        [get ]  获取,获得</p><p>code                       [ kəud ]   代码,代号,编码</p><p>country                    [ ‘kʌn tri ]      国家,国土</p><p>University                 [ju:ni’və:siti]  大学</p><p>College                    [ ‘kɔlidʒ]    大学</p><p>Private                    [ ‘praivit ]  私有的,私人的</p><p>show                       [ʃəu]   显示,展示</p><p>sleep                      [ sli:p ]  睡,   睡觉,     睡眠 1 秒=1000 毫秒</p><p>single                     [    ‘siŋgl]  单一的,单独的,单身的,单程的</p><p>instance                   [   ‘instəns ]实例,情况</p><p>tool                       [   tu:l]  工具</p><p>Data                       [ ‘deitə   ] 资料</p><p>develop                    [ di’veləp ]   开发</p><p>extends                    [ ik’stends]  继承,延伸,推广</p><p>Phone                      [ fəun ]   电话</p><p>Call                    [ kɔ:l] 呼叫,给…打电话</p><p>Study                   [ ‘stʌdi] 学习,研究</p><p>work                    [ wə:k ]  工作,操作</p><p>super                   [‘sju: pə]   父类的,超级的,,超类的</p><p>final                   [‘fai nl]  最终的</p><p>finally</p><p>finalized</p><p>abstract                [‘æbstrækt]  抽象的</p><p>interface               [ ‘intəfeis ] 接口</p><p>implements              [‘impliments] 实现</p><p>mouse                   [maus ]   鼠标,    老鼠</p><p>bonus                   [ ‘bəunəs ]  奖金</p><p>inner                   [ ‘inə ] 内部的</p><p>protect                 [prəu’tekt]  保护，受保护的， 防卫</p><p>equals                  [‘i:kwəls]判断两个字符串是否相等</p><p>memory                  [‘meməri]  记忆，内存，存储器</p><p>OutOfMemoryError            在内存之外的错误：内存溢出（专业说法）</p><p>heap                    [hi:p]  堆</p><p>space                   [speis]  空间</p><p>Java heap space         Java 堆内存</p><p>Throw                   [θrəu]  抛出,投掷</p><p>Throws                  [θrəuz] throw 的复数形式</p><p>finally                 [‘fainəli] 最后,最终</p><p>Message                 [‘mesidʒ]   消息,信息,通知</p><p>try                     [trai]   尝试,试图</p><p>catch                   [kætʃ]  捕获,捕捉,抓住</p><p>close                   [kləuz]  关闭,结束</p><p>open                    [‘əupən]  打开,公开</p><p>add                     [æd]  添加,增加</p><p>prelect                 [pri’lekt ]  讲课,讲演</p><p>directory               [ di’rektəri ]   目录</p><p>throwable       [ ‘θrəuə’ei bl  ] 直译是可抛出的,在Java 中指异常类.</p><p>ClassCastException      (“类型错误”),类型转换异常</p><p>Runtime                 [run’taim]  运行时间</p><p>RuntimeException        运行时异常</p><p>Current                 [‘kʌrənt]    当前的,现在的</p><p>Arithmetic              [ə’riθmətik ]   算数</p><p>synchronized           [ ‘sɪŋkrə,naɪzd]      同步的</p><p>Runnable               [ ‘rʌnəbl]  可捕捉的(在java  中它是一个接口)</p><p>Inter rupted            [,intə’rʌptid]    中断的,被阻止的</p><p>Ticket                  [‘tikit]  票</p><p>Bank                    [bæŋk]    银行</p><p>tank                    坦克</p><p>flag                    [flæɡ]  标记,  旗帜</p><p>dead                    [ded]  死亡的,无生命的</p><p>lock                    [ lɔk] 锁</p><p>unlock</p><p>Resource                [ ri’sɔ:s]  资源</p><p>Notify                  [‘nəutifai ] 唤醒,     告知</p><p>Input                   [‘input]   输入</p><p>Output                  [ ‘autput ]  输出</p><p>bounded                 [‘baundid]  有界限的</p><p>Buffer                  [‘bʌfə]   缓冲区</p><p>boundedbuffer           有界缓冲区</p><p>Signal                  [‘siɡ nəl]   信号,标志</p><p>Condition               [kən’diʃən]     条件</p><p>Producer                [prə’du:sə]   生产者</p><p>Consumer                [ kən’sju:mə ]   消费者</p><p>substring               [ ‘sʌb striŋ]  子字符串,       部分字符串,子链</p><p>Trim                    [trim]    修剪,    修整</p><p>Append                  [ə’pend]    添加</p><p>Add                     [ æd]    增加</p><p>Insert      [in’sə:t]  插入,     比如把一段字符串”cd”  插入到 “abef”</p><p>Delete                  [di’li:t]  删除</p><p>remove</p><p>replace                  [ri’pleis]   代替,取代,更换</p><p>update                   [ ʌp’deit]  更新</p><p>Create                   [ kri’eit ]  创造,创作</p><p>Builder                  [‘bildə] Java 中为 “缓冲器”,  直译为建筑者</p><p>StringBuffer             字符串缓冲区(同步的)</p><p>StringBuilder            字符串缓冲区(不同步的)</p><p>char                     [tʃɑ:]   字符型</p><p>character                [‘kærəktə]    字符</p><p>int                      [int]    整型</p><p>integer                  [‘intidʒə]  整数类型</p><p>parse                    [pɑ:z]  解析,     转换成…</p><p>parseInt                 转换为int 类型</p><p>Retain                   [ri’tein]   保持</p><p>reverse                  [ ri’və:s ]  反转,翻转</p><p>collection               [kə’lekʃən]   集合,聚集,采集</p><p>Remove                   [ri’mu:v]     移除,删除</p><p>clear                    [kliə]   清空,清除,清楚的.</p><p>Iterator                 [itə’rei tə]  迭代器</p><p>list                     [list]  列表,清单(集合之一)</p><p>ArrayList                [‘əri list] 数组列表(最常用的集合,重点掌握)</p><p>HasPrevious              [‘pri:vjəs]  在…之前</p><p>HasNext</p><p>Split                    [split]   切割</p><p>Element                  [‘elimənt]   元素</p><p>NoSuchElementException</p><p>linked                   [ liŋkt]  连接的</p><p>contains                 [kən’teinz]   包含</p><p>Set                      [ set]   集合</p><p>Comparator               [‘kəmpə reitə]      比较仪</p><p>style                    [stail]   风格,类型</p><p>math                     [mæ θ]    数学,算数</p><p>ceil()                [ si:l]  返回大于参数的最小整数。</p><p>floor()               [flɔ:]  返回小于参数的最大整数。</p><p>round()               [raund]    返回四舍五入的整数。</p><p>pow(a,b)              [ p a u]a 的b 次方。</p><p>execute               [‘eksikju:t]  执行</p><p>process               [‘prəuses] 处理,加工</p><p>Notepad               [‘nəutpæd]   笔记本</p><p>destroy               [di’strɔi]  消毁,  破坏,消灭</p><p>Separator             [‘sepə reitə] 分隔符,分离器</p><p>Generic               [dʒi’nerik]   类的,一般的</p><p>vector                [‘vektə] 也是一个集合(早期的一个集合现在几乎不</p><p>用了)</p><p>value                 [‘vælju:]  值,价值</p><p>Calendar              [‘kæ lən dɚ]    日历, 日历表,历法</p><p>Day                   [dei]  一天,   每天</p><p>Week                  [wi:k]  周,星期</p><p>Month                 [ mʌnθ]  月</p><p>Year                  [jiə] 年</p><p>format                [‘fɔ:mæt]  格式,样式</p><p>ParseException        解析异常</p><p>stack                 [stæk]  堆</p><p>trace                 [treis]  痕迹</p><p>printStackTrace</p><p>by                    [bai]  通过,按照</p><p>order                 [‘ɔ:də]  顺序,规则</p><p>byOrder</p><p>line                  [lain]  一行</p><p>readLine()            读取一行</p><p>stream         [stri:m]  流 (生活中常见的流有:  水流,电流,数据流)</p><p>flush                 [flʌʃ]清空缓冲区数据,然后缓冲区的数据就去了它们</p><p>filter                         [filtə]过滤器</p><p>Absolute                       [‘æbsəlju:t]      绝对的</p><p>hidden                         [‘hidən]         隐藏的</p><p>Suffix                         [sə’fiks]      后缀的</p><p>level                          [‘levəl]       标准,水平的</p><p>store                          [stɔ:]         储存</p><p>accept                         [ək’sept]           接受,承认,同意</p><p>sequence                       [‘si:kwəns]  序列</p><p>Enumeration                    [i,nju:mə’reiʃən]          枚举,列举</p><p>merge                          [mə:dʒ]        合并</p><p>access                         [‘ækses]       使用</p><p>Un supported                   [,ʌnsə’pɔ:tid]           不支持的</p><p>Unsupported Encoding Exception</p><p>compare                        [kəm’pεə]           比较</p><p>comparable                     [‘kɔm pə rəbl]                可以比较的</p><p>field                          [‘fi:ld]  字段</p><p>button                         [‘bʌtən]    按钮</p><p>frame                          [freim]      框架,结构</p><p>action                         [‘ækʃən]       行动,动作</p><p>event                          [i’vent]  事件,</p><p>visible                        [‘vizəbl]    看的见的,可见的</p><p>menu                           [‘menju:]  菜单</p><p>area                           [‘εə r iə]     区域,地区</p><p>item                           [‘aitəm]      条目,项目</p><p>Scroll                         [sk r əul]    卷轴,滚动</p><p>pane                           [pein]      窗格</p><p>ScrollPane                     滚动窗口 ；滚动面板</p><p>Content                        [‘kɔntent]      内容</p><p>Context</p><p>choose                         [tʃu:z]     选择</p><p>dialog                         [‘daiəlɔg]      对话,会话</p><p>Relative                       [ ‘relətiv ]    相对的</p><p>Init                           [ i,nit ]  初始化</p><p>Initialization                 [ i,niʃəl’zeiʃən]      初始化</p><p>perform                        [pə’fɔ:m]  执行,运转</p><p>Port                           [ pɔ:t ] (计算机的)端口</p><p>Viewport                       [ ‘vju:pɔ:t ]  视口</p><p>pressed                        [prest]      紧迫的,         加压的</p><p>display                        [,dis’plei]  显示;  表现</p><p>dispose                        [dis’pəuz]      处理,安排</p><p>Operator                       [‘ɔpəreitə]  操作员</p><p>operation                      [,ɔpə’reiʃən]        操作(动词)</p><p>host                           [həust]       主机,主人</p><p>address                        [ə’dres]      地址</p><p>HostAddress</p><p>receive                        [ri’si:v]  接收</p><p>send                           [send]  发送</p><p>client                         [‘klaiənt]     客户</p><p>Server                         [‘sə:və]    服务器</p><p>log                            [lɔ’gin]  注册<br>register                       [‘redʒistə]     登录<br>upload                         [ ‘ʌpləud]       上传</p><p>Download                       [daun’ləud]        下载</p><p>Task                           [tɑ:sk]  任务</p><p>Browse                         [brauz]  浏览</p><p>Browser                        [ brawə:]  浏览器</p><p>connection                     [kə’nekʃən]       连接</p><p>layout                         [‘leiaut]  布局</p><p>Terminate                      [ ‘tə:mineit ]  结束</p><p>Instantiation                  [in,stænʃi’eiʃən]        实例化</p><p>Instance</p><p>declared                       [di’klεəd]       公然的</p><p>Access                         [ ək’ses      ]  进入,接近,入口,通道</p><p>Accessible                          [ək’sesəbl]        可进入的</p><p>invoke                              [in’vəuk]       调用</p><p>board                               [bɔ:d]       木板, 甲板</p><p>MainBoard</p><p>card                                [kɑ:d]  卡片</p><p>Network card</p><p>match                               [mætʃ]       匹配</p><p>matcher                             [‘mætʃə]        匹配器</p><p>pattern                             [‘pætən]         模式,图案</p><p>Regex                               [ ri’dʒeks ]       正则表达式</p><p>title                               [‘taitl]  标题</p><p>untitled                            [,ʌn’taitld]         无标题的</p><p>Charset                             [ tʃɑ: set ]  字符集,编码集</p><p>Encoding</p><p>Rows                                [rəus ]       多行,</p><p>Cols                                [ kɔls]       列数</p><p>Top                                 [ tɔp]    顶部,顶端</p><p>center                              [‘sentə]        中心,        中央</p><p>target                              [‘tɑ:ɡit]      目标</p><p>document                            [‘dɔkjumənt]           文件</p><p>table                               [‘teibl]      表格,桌子</p><p>span                                [spæn]  跨度,范围</p><p>User                                [‘juzə]     用户</p><p>password                            [‘pɑ:swə:d ]  密码</p><p>Radio                               [ ‘reidiəu ]       单选框</p><p>Checkbox                            [ ‘tʃekbɔks ]        复选框</p><p>image                 [‘imidʒ]  图像,影像</p><p>none                  [nʌn]  没有</p><p>option                [‘ɔpʃən]  选项</p><p>Form                  [ fɔ;m]  结构,形式</p><p>Height                [hait]  高度</p><p>Width                 [wi θ]  宽度</p><p>border                [‘bɔ:də]   边框宽度</p><p>alert                 [ə’lə:t] 警告,弹出</p><p>Onclick               [ ɔn’klik] 鼠标单击</p><p>reset                 [ ‘ri:set] 重置,清零</p><p>submit                [səb’mit]   提交</p><p>Stylesheet            [stail’ʃ :t] 样式表</p><p>Background            [‘bækɡraʊnd]    背景</p><p>decoration            [,dekə’reiʃən] 装饰,装潢</p><p>Hover                 [‘hɔvə, ‘hʌvə]   鼠标移动到链接上</p><p>Active                [‘æktiv]  选定的链接</p><p>Visit ed              [‘vi zi tid] 已访问的链接</p><p>Link                  [liŋk]    未访问的链接</p><p>Letter                [‘le tə]</p><p>Focus                 [‘fəukəs]  焦点,中心</p><p>blank                 [blæŋk]    空白的</p><p>Bottom                [‘bɔtəm]   底部,末端</p><p>Botton</p><p>Pad ding              [ pæd iŋ ]    </p><p>Solid                 [‘sɔlid] 实线边框</p><p>Dashed                [dæʃt]  在MAC 平台上IE4+与WINDOWS 和UNIX</p><pre><code>平台上IE5.5+为虚线。否则为实线</code></pre><p>Groove                [ɡru:v]   凹槽</p><p>Dotted                [‘dɔtid]  在 MAC平台上 IE4+与 WINDOWS和UNIX 平台上IE5.5+为点线。否则为实线</p><p>Position                [pə’zɪʃən] 位置</p><p>Var                   [vɑ:]  在Script 中用来定义变量类型的单词</p><p>undefined             [,ʌndi’faind] 未定义的,不明确的</p><p>global                [‘ɡləubəl] 全局的,     总体的</p><p>Generate              [ dʒnəreit] 生成</p><p>Modified              [ ‘mɔdi faid] 改进的,改良的</p><p><strong>其他</strong></p><p>阶乘 factorial</p><p>控制语句  control statement</p><p>闰年  leap year</p><p>循环  Circulation</p><p>乘法表  MultiplicationTable</p><p><strong>运算符**</strong>(operator)**</p><p>加法：addition</p><p>减法：subtraction</p><p>乘法：multiplication</p><p>除法：division</p><p>取余：complementation</p><p>组件：Component</p><p>菜单组件：MenuComponent</p><p>矩形：rectangle</p><p>长方形：square</p><p>圆形：circularity</p><p>734条高频词组笔记</p><p>1.abide by(=be faithful to ; obey)忠于；遵守。??</p><p>\2. be absent from⋯. 缺席，不在??</p><p>\3. absence or mind(=being absent-minded) 心不在焉??</p><p>\4. absorb(=take up the attention of)吸引⋯的注意力(被动语态)be absorbed in 全神贯注于⋯?? 近义：be engrossed ; be lost in ; be rapt in ;be concentrated on??; be focused on ; be centered on??</p><p>\5. (be) abundant in(be rich in; be well supplied with) 富于,富有???? 6. access(to) (不可数名词) 能接近,进入,了解??</p><p>\7. by accident(=by chance, accidentally)偶然地,意外. Without accident(=safely) 安全地,??</p><p>\8. of one’s own accord(=without being asked; willingly; freely)自愿地 ,主 动地??</p><p>\9. in accord with 与⋯一致 . out of one’s accord with 同⋯.不一致??</p><p>\10. with one accord (=with everybody agreeing)一致地??</p><p>\11. in accordance with (=in agreement with) 依照,根据??</p><p>\12. on one’s own account??1) 为了某人的缘故, 为了某人自己的利益??2) (=at one’s own risk) 自行负责??3) (=by oneself)依靠自己??on account 赊账; on account of 因为; on no account不论什么原因也不;of ⋯account 有⋯..重要性.??</p><p>\13. take⋯into account(=consider)把…考虑进去??</p><p>\14. give sb. an account of 说明, 解释 (理由)??</p><p>\15. account for (=give an explanation or reason for) 解释, 说明.??</p><p>\16. on account of (=because of) 由于,因为.??</p><p>\17. on no account(=in no case, for no reason)绝不要,无论如何不要(放句首时句 子要倒装)??</p><p>\18. accuse⋯of⋯(=charge⋯with; blame sb. for sth. ; blame sth. on sb. ; complain about) 指控,控告??</p><p>\19. be accustomed to (=be in the habit of, be used to)习惯于.??</p><p>\20. be acquainted with(=to have knowledge of) 了解; (=to have met socially??) 熟悉??</p><p>\21. act on 奉行,按照⋯行动; act as 扮演; act for 代理??</p><p>\22. adapt oneself to(=adjust oneself to) 使自己适应于??</p><p>\23. adapt⋯(for) (=make sth. Suitable for a new need) 改编, 改写(以适应新的需要)??</p><p>\24. in addition (=besides) 此外, 又, 加之??</p><p>\25. in addition to(=as well as, besides, other than)除⋯外??</p><p>\26. adhere to (=abide by, conform to, comply with, cling to, insist on, pe rsist in, observe, opinion, belief ) 粘附; 坚持, 遵循??</p><p>\27. adjacent(=next to, close to) 毗邻的, 临近的??</p><p>\28. adjust..(to) (=change slightly)调节; 适应;??</p><p>\29. admit of (=be capable of, leave room for) ⋯的可能，留有⋯的余地.??</p><p>\30. in advance (before in time) 预告, 事先.??</p><p>\31. to advantage 有利的,使优点更加突出地.??</p><p>\32. have an advantage over 胜过.??have the advantage of 由于⋯处于有利条件??have the advantage of sb.知道某人所不知道的事??</p><p>\33. take advantage of (=make the best of, utilize, make use of, profit from, harness)利用.??</p><p>\34. agree with 赞同(某人意见) agree to 同意??</p><p>\35. in agreement (with) 同意, 一致??</p><p>\36. ahead of 在⋯之前, 超过⋯;⋯⋯⋯⋯⋯. ahead of time 提前.??</p><p>\37. in the air 1)不肯定, 不具体. 2)在谣传中.??</p><p>\38. above all (=especially, most important of all) 尤其是, 最重要的.??</p><p>\39. in all (=counting everyone or everything, altogether) 总共, 总计??</p><p>\40. after all 毕竟,到底; (not) at all 一点也不;??all at once(=suddenly)突然; once and for all 只此一次; above all 最重要的; first of all 首先; all in all 大体上说; be all in 累极了; all but 几乎.??</p><p>\41. allow for (=take into consideration, take into account) 考虑到, 估计到??.??</p><p>\42. amount to (=to be equal to) 总计, 等于.??</p><p>\43. answer for (undertake responsibility for, be liable for, take charge for) 对⋯负责.??</p><p>\44. answer to (=conform to) 适合,符合.??</p><p>\45. be anxious about 为⋯焦急不安; 或anxious for??</p><p>\46. apologize to sb. for sth. 为⋯向⋯道歉??</p><p>\47. appeal to sb. for sth. 为某事向某人呼吁. appeal to sb. 对某人有吸引力??</p><p>\48. apply to sb. for sth. 为⋯向⋯申请 ; apply for申请; apply to 适用.??</p><p>\49. apply to 与⋯有关;适用??</p><p>\50. approve of (=consent to, be in favor of, favor, agree to, consider good, right) 赞成, approve vt. 批准??</p><p>\51. arise from(=be caused by) 由⋯引起.??</p><p>\52. arrange for sb.sth. to do sth. 安排⋯做⋯??</p><p>\53. arrive on 到达; arrive at 到达某地(小地方);得出,作出; arrive in 到达某地(大地方);??</p><p>\54. be ashamed of (=feel shame, guilt or sorrow because of sth. done) 以⋯??为羞耻??</p><p>\55. assure sb. of sth. (=try to cause to believe or trust in sth.) 向⋯保证, 使⋯确信.??</p><p>\56. attach(to) (=to fix, fasten; join) 缚, 系 ,结??</p><p>\57. make an attempt at doing sth. (to do sth.) 试图做⋯??</p><p>\58. attend to (=give one’s attention, care and thought)注意,照顾;attend on(upon)(=wait upon, serve, look after) 侍候,照料??</p><p>\59. attitude to toward ⋯对⋯的态度.看法??</p><p>\60. attribute⋯to⋯(=to believe sth. to be the result of⋯)把..归因于.., 认为..是..的结果??</p><p>\61. on the average (=on average, on an average) 平均??</p><p>\62. (be) aware of (=be conscious of , having knowledge or consciousness)意识到,知道.??</p><p>\63. at the back of (=behind) 在⋯后面??</p><p>\64. in the back of 在⋯后部(里面); on the back of 在⋯后部(外面); be on one’s back(=be ill in bed) 卧病不起.??</p><p>\65. at one’s back(=supporting or favoring sb.) 支持,维护; have sb. at one ’s back 有⋯支持, 有⋯作后台??</p><p>\66. turn one’s back on sb. (=turn away from sb. in an impolite way) 不理睬(某人),背弃,抛弃??</p><p>\67. behind one’s back 背着某人(说坏话)??</p><p>\68. be based on??upon 基于??</p><p>\69. on the basis of 根据⋯, 在⋯基础上??</p><p>\70. beat⋯at 在⋯运动项目上打赢??</p><p>\71. begin with 以⋯开始. to begin with (=first of all) 首先, 第一(经常用于开始语)??</p><p>\72. on behalf of (=as the representative of) 以⋯名义??</p><p>\73. believe in(=have faith or trust in; consider sth.sb. to be true) 相信,依赖,信仰.??</p><p>\74. benefit (from) 受益,得到好处.??</p><p>\75. for the benefit of 为了⋯的利益(好处)??</p><p>\76. for the better 好转??</p><p>\77. get the better of (=defeat sb.) 打败, 胜过.??</p><p>\78. by birth 在出生上,论出身,按血统 at birth 在出生时; give birth to 出生??</p><p>\79. blame sb. for sth. 因⋯责备某人 . blame sth. on sb. 把⋯推在某人身上??</p><p>\80. in blossom开花(指树木) be in blossom开花(强调状态) come into blossom开花(强调动作)??</p><p>\81. on board 到船上, 在船上, 上火车或飞机??</p><p>\82. boast of (or about) 吹嘘??</p><p>\83. out of breath 喘不过气来??</p><p>\84. in brief(=in as few words as possible)简言之??</p><p>\85. in bulk 成批地,不散装的??</p><p>\86. take the floor 起立发言??</p><p>\87. on business 出差办事.??</p><p>\88. be busy with sth.于某事 。 be busy doing sth. 忙于做某事??</p><p>\89. last but one 倒数第二.??</p><p>\90. but for (=without) 要不是. 表示假设??</p><p>\91. buy sth. for⋯money 用多少钱买??</p><p>\92. be capable of 能够, 有能力??be capable of being +过去分词是能够被⋯的??</p><p>\93. in any case(=for love or money, at any rate, at any price, at any cost??, whatever happens; anyhow)无论如何??</p><p>\94. in case (=for fear that) 万一;??</p><p>\95. in case of (=in the event of)如果发生⋯万一??in the case of 至于⋯, 就⋯而言??</p><p>\96. in no case在任何情况下都不(放句首倒装句)??</p><p>\97. be cautious of 谨防??</p><p>\98. center one’s attention on(=focus one’s attention on) 把某人的注意力集中在⋯上??</p><p>\99. be certain of (=be sure of) 有把握, 一定.??</p><p>\100. for certain of (=for sure )肯定地,有把握地??</p><p>\101. by chance(=accidentally, by accident)偶然??</p><p>\102. for a change换换环境(花样等)??</p><p>\103. charge sb. with ⋯控告某人犯有⋯??</p><p>\104. in charge of (=responsible for) 负责(某事)??in the charge of ⋯由⋯管??</p><p>\105. take charge of (=to be or become responsible for)负责管理(照顾)??</p><p>\106. charge⋯for 因⋯索取(费用) , charge sb. with sth. 控告某人犯有⋯??</p><p>\107. round the clock(=all day and all night, usually without stopping) 昼夜不停地??</p><p>\108. comment on 评论??</p><p>\109. commit oneself to 使自己承担⋯ commit sb. to prison把某人送进监狱; commit one’s idea to writing 把某人的想法写下来; commit a matter to a committee??把某事交给委员会讨论??</p><p>\110. in common (和⋯)有共同之处,共用.??be common to sb. 是与某人所共有的??</p><p>\111. keep company with (=be friendly and go out together) 和⋯要好.??</p><p>\112. compare⋯with ⋯ 把⋯与⋯比较??</p><p>\113. compare⋯to⋯ 把⋯比作⋯??</p><p>\114. by comparison 比较起来??</p><p>\115. in comparison with (=in contrast to) 和⋯比起来??</p><p>\116. compensate for (=give sth. to make up for) 补偿, 赔偿,弥补 compensate??sb. for sth. 赔偿,弥补??</p><p>\117. complain of (or about)抱怨;诉苦;控告;complain about 抱怨某人或事情; complain to sb. about sth. (or sb.) 向某人抱怨⋯; complain (抱怨); complement (补充); compliment (恭维)??</p><p>\118. comply with (=act in accordance with a demand, order, rule etc.) 遵守, 依从??</p><p>\119. conceive of (think of, imagine, consider) 想象,设想??</p><p>\120. concentrate on (or upon) 集中,专心??</p><p>\121. be concerned with (=about) 与⋯有关??</p><p>\122. concern oneself about??with 关心??</p><p>\123. in conclusion(=as the last thing)最后一点; at the conclusion of 当⋯结束时;??</p><p>\124. condemn sb. to 判决??</p><p>\125. on condition that (=if)以⋯为条件, 假如. in that = because因为; now that = since既然??for all that = although 尽管??</p><p>\126. in??out of condition (=thoroughly healthy or fit??not fit) 健康状况好不好 . in good (bad) condition处于良好(坏)状态??</p><p>\127. confess(to)(=admit a fault, crime, or sth. wrong)承认, 供认; confess to a crime 承认罪行.??</p><p>\128. confide in (=to talk freely to sb. about one’s secret) 对⋯讲真心话, 依赖??</p><p>\129. in confidence 推心置腹地; with confidence 满怀信心地; have confidence in 对⋯有信心??</p><p>\130. confidence in sb.??sth. 对⋯的信赖??</p><p>\131. be confident of 有信心; confidential 机密的??</p><p>\132. confine⋯to⋯ 把⋯限制在某范围内??</p><p>\133. confirm sb. in 使某人更坚定(信念等)??</p><p>\134. conform to (=be in agreement with, comply with) 符合,遵照,遵守;1)obey 服从; 2) observe; 3)comply with照⋯办; 4)keep to遵循; 5)abide by服从;6)stick to按..做??</p><p>\135. be confronted with(=be brought face to face with) 面对, 面临??</p><p>\136. congratulate sb. on 祝贺??</p><p>\137. in connection with(=with regard to)关于,??</p><p>\138. be conscious of(=be aware of)觉察,知道??</p><p>\139. consent to(=give agreement to permission)同意??</p><p>\140. in consequence (=as a result) 结果??</p><p>\141. in consequence of (=as a consequence of)由于⋯的结果??</p><p>1.???????? 142. under consideration 在考虑中??</p><p>\143. in consideration of (=in return for, on account of, because of )由于??</p><p>\144. on no consideration(in no case)无论如何也不??</p><p>145.take⋯into consideration (=take account of, take⋯into account)考虑到, 把 ⋯考虑进去??</p><p>\146. considerate (=thoughtful of the needs) 体贴的, 考虑他人需要的, considerable相当大的,值得考虑的??</p><p>\147. consist of(=be composed of)由⋯组成的. consist in主要在于. consist with符合,与⋯一致??</p><p>\148. be consistent with(=be in agreement with)与⋯一致. be consistent in一贯的??,??</p><p>\149. consult sb. on about sth. 向⋯征求⋯方面的意见, 就⋯向⋯请教??</p><p>\150. to one’s heart’s content尽情地,痛痛快快??</p><p>\151. be content with(=be satisfied with) 满足于be content to do sth. 愿意做某事??</p><p>\152. contrary to (=in opposition to) 与⋯相反??</p><p>\153. on the contrary 相反??</p><p>\154. contrast⋯with 把⋯与⋯相对(对照)??</p><p>\155. in contrast towith 和⋯形成对比 by contrast 对比之下??</p><p>\156. contribute to 有助于??</p><p>\157. under control (被)控制住 out of control无法控制??</p><p>\158. at one’s convenience(=where and when it suits one) 在方便的时间或地点 .be convenient to??for 对⋯方便??</p><p>\159. convince sb. of (=cause sb. to believe or feel certain; to persuade sb.)??使某人确信,try to persuade sb. to do sth.劝说某人做⋯??</p><p>\160. cope with(=deal with, try to find a solution to)应付, 处理??</p><p>\161. in the corner(of)在角落里;on(at) the comer of a street在街道拐弯处;round??the comer拐过弯; be in a tight corner陷入困境??</p><p>\162. correspond (with) ( =exchange letters regularly) 通信??</p><p>\163. correspond to 相当于 . correspond with 符合,一致??</p><p>\164. at all costs不惜任何代价 . at the cost of 以⋯为代价??</p><p>\165. a matter of course 理所当然的事??</p><p>\166. as a matter of course 当然地, 自然地??</p><p>\167. in (during) the course 在⋯过程中??</p><p>\168. in due course (=without too much delay) 没经过太久, 到一定时候??</p><p>\169. on credit赊购; with credit以优异成绩; to one’s credit使某人感到光荣; do sb. credit 使⋯感到光荣??</p><p>170．be critical of 爱挑毛病的，批评的??</p><p>\171. cure sb. of+某种疾病 治好某人的疾病??</p><p>172．a danger to对⋯的危险; be in danger(of)处于⋯危险中; be out of danger脱离危险??</p><p>\173. to date(=so far, until now) 到目前为止??</p><p>\174. out of date过时的；up to date新式的,时兴的; date back to可追溯到; date from从某时期开始(有)??</p><p>\175. deal with (=concern) 论及??</p><p>\176. be in debt to sb. 欠⋯的债??</p><p>\177. on the decline 在衰退中, 在减少中??in decline 下降; on the increase 在增加??</p><p>\178. to one’s delight 令某人感到高兴??to one’s regret 遗憾; sorrow悲痛; relief 安心; distress 苦恼; shame羞愧; surprise 惊奇; astonishment 惊奇;??</p><p>\179. delight in(=take great pleasure in doing sth.)喜欢, 取乐??</p><p>\180. take (a) delight in 喜欢干⋯, 以⋯为乐??</p><p>\181. demand sth. of sb. 向某人要求(非物质的)东西. demand sth. from sb. 向某人要求(物质的)东西??</p><p>182.in demand有需求;on demand受到要求时??</p><p>\183. be dependent on 依靠??</p><p>\184. deprive sb. of sth. 剥夺某人某物??</p><p>\185. derive⋯from(=obtain⋯from)从⋯取得,由⋯来的.derive from(=come from)起源于??</p><p>\186. despair of (=lose all hope of) 绝望??</p><p>\187. in despair 绝望??</p><p>\188. despite (=in spite of) 不管, 尽管??</p><p>\189. in detail 详细地??</p><p>\190. deviate from 偏离, 不按⋯办??</p><p>\191. on a diet 吃某种特殊饮食, 节食??</p><p>\192. differ from⋯in 与⋯的区别在于⋯??</p><p>\193. in difficulties⋯有困难,处境困难,??</p><p>\194. discharge sb. (from)⋯for (=dismiss sb. from a job for) 因⋯解雇, 开除??</p><p>\195. fall back (=retreat, turn back) 撤退;??in disorder 慌乱地, 狼狈不堪??</p><p>\196. on display(=being shown publicly)陈列??</p><p>\197. dispose of (=get rid of ,throw away)处理掉??</p><p>\198. beyond dispute不容争议的,无可争议??</p><p>\199. in dispute 在争议中??</p><p>\200. in the distance 在远处. make out 辩认出??</p><p>\201. (be) distinct from ( = be different from) 与⋯截然不同??</p><p>\202. distinguish between (=make or recognize differences) 辨别??</p><p>\203. distinguish⋯from 把⋯与⋯区别开??</p><p>\204. do away with(=get rid of; abolish; discard eliminate) 除去,废除,取消; do away with (=kill) 杀掉, 镇压??</p><p>\205. have⋯to do with 与⋯有关系??</p><p>\206. without doubt (=undoubtedly)无可置疑地??</p><p>\207. in doubt(=in a condition of uncertainty)对⋯表示疑惑??</p><p>\208. be due to 是由于??</p><p>\209. come off duty 下班??</p><p>\210. go on duty 上班??</p><p>\211. be on duty 值班, 值日, 在上班时??</p><p>\212. be in duty bound to (do) (=be required by one’s job or esp. by conscience) 有义务(做)??</p><p>\213. be eager for 想得到, 盼望??</p><p>\214. by ear (=play music from memory without having seen it printed) 凭记忆,不看乐谱??</p><p>\215. have an ear for (=have keen recognition of sounds esp. in music and language)对..有鉴赏力??</p><p>\216. a word in one’s ear 私房话, 秘密话??</p><p>\217. on earth 究竟, 到底, 全然??</p><p>\218. with ease ( = easily) 容易, 不费力??</p><p>\219. at (one’s) ease ( = without worry or nervousness) 自在,不拘束??</p><p>\220. put sb. at his??her ease (=free sb. from worry or nervousness)使某人感到无拘束??</p><p>\221. economize on (=save sth. instead of being wasteful) 节省??</p><p>\222. have an effect on 对⋯有影响??</p><p>\223. be in effect (=be in operation) 有效??</p><p>\224. go into effect 生效. ( 近 come into effect; take effect; be brought into effect)??</p><p>\225. in effect (=in fact, really) 实际上??</p><p>\226. give effect to (=carry out) 实行,使⋯生效??</p><p>\227. to no effect 不起作用,没有取得任何效果??</p><p>\228. (be) of no effect (=useless) 无效??</p><p>\229. to the effect that 大意是⋯,主要内容是⋯??</p><p>\230. to that effect 是那个意思的⋯??</p><p>\231. emerge from ( =appear, become known ) 出现, 暴露(问题. 意见等)??</p><p>\232. place(or put, lay) an emphasis on 强调, 把重点放在⋯上??</p><p>\233. encourage sb. in 鼓励; encourage sb. in hisher work 鼓励某人工作; encourage sb. in hisher idleness 怂恿某人游手好闲??</p><p>\234. encourage sb. in ⋯with sth. 用⋯鼓励某人做某事??</p><p>\235. on end (=continuously) 连续地??</p><p>\236. (be) at an end (=finished) 结束了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA线上故障排查</title>
      <link href="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"/>
      <url>/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>线上故障主要会包括cpu、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如jstack、jmap等工具也是不囿于一个方面的问题的，基本上出问题就是df、free、top 三连，然后依次jstack、jmap伺候，具体问题具体分析即可。</p><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>一般来讲我们首先会排查cpu方面的问题。cpu异常往往还是比较好定位的。原因包括业务逻辑问题(死循环)、频繁gc以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用jstack来分析对应的堆栈情况。</p><h2 id="使用jstack分析cpu问题"><a href="#使用jstack分析cpu问题" class="headerlink" title="使用jstack分析cpu问题"></a>使用jstack分析cpu问题</h2><p>我们先用ps命令找到对应进程的pid(如果你有好几个目标进程，可以先用top看一下哪个占用比较高)。接着用top -H -p pid来找到cpu使用率比较高的一些线程</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/1.png" alt="Image zoo"></p><p>然后将占用最高的pid转换为16进制printf ‘%x\n’ pid得到nid</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/2.png" alt="Image zoo"></p><p>接着直接在jstack中找到相应的堆栈信息jstack pid |grep ‘nid’ -C5 –color</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/3.png" alt="Image zoo"></p><p>可以看到我们已经找到了nid为0x42的堆栈信息，接着只要仔细分析一番即可。</p><p>当然更常见的是我们对整个jstack文件进行分析，通常我们会比较关注WAITING和TIMED_WAITING的部分，BLOCKED就不用说了。我们可以使用命令cat jstack.log | grep “java.lang.Thread.State” | sort -nr | uniq -c来对jstack的状态有一个整体的把握，如果WAITING之类的特别多，那么多半是有问题啦。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/4.png" alt="Image zoo"></p><h2 id="频繁gc"><a href="#频繁gc" class="headerlink" title="频繁gc"></a>频繁gc</h2><p>当然我们还是会使用jstack来分析问题，但有时候我们可以先确定下gc是不是太频繁，使用jstat -gc pid 1000命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析，具体可以参考一下gc章节的描述。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/5.png" alt="Image zoo"></p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>针对频繁上下文问题，我们可以使用vmstat命令来进行查看</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/6.png" alt="Image zoo"></p><p>cs(context switch)一列则代表了上下文切换的次数。如果我们希望对特定的pid进行监控那么可以使用 pidstat -w pid命令，cswch和nvcswch表示自愿及非自愿切换。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/7.png" alt="Image zoo"></p><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p>磁盘问题和cpu一样是属于比较基础的。首先是磁盘空间方面，我们直接使用df -hl来查看文件系统状态</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/8.png" alt="Image zoo"></p><p>更多时候，磁盘问题还是性能上的问题。我们可以通过iostatiostat -d -k -x来进行分析</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/9.png" alt="Image zoo"></p><p>最后一列%util可以看到每块磁盘写入的程度，而rrqpm/s以及wrqm/s分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。</p><p>另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用iotop命令来进行定位文件读写的来源。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/10.png" alt="Image zoo"></p><p>不过这边拿到的是tid，我们要转换成pid，可以通过readlink来找到pidreadlink -f /proc/*/task/tid/../..。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/11.png" alt="Image zoo"></p><p>找到pid之后就可以看这个进程具体的读写情况cat /proc/pid/io</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/12.png" alt="Image zoo"></p><p>我们还可以通过lsof命令来确定具体的文件读写情况lsof -p pid</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/13.png" alt="Image zoo"></p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>内存问题排查起来相对比CPU麻烦一些，场景也比较多。主要包括OOM、GC问题和堆外内存。一般来讲，我们会先用free命令先来检查一发内存的各种情况。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/14.png" alt="Image zoo"></p><h2 id="堆内内存"><a href="#堆内内存" class="headerlink" title="堆内内存"></a>堆内内存</h2><p>内存问题大多还都是堆内内存问题。表象上主要分为OOM和StackOverflow。</p><h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><p>JMV中的内存不足，OOM大致可以分为以下几种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">「Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.OutOfMemoryError: unable to create new native thread」</span><br></pre></td></tr></table></figure><p>这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定Xss来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改/etc/security/limits.confnofile和nproc来增大os对线程的限制</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/15.png" alt="Image zoo"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">「Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space」</span><br></pre></td></tr></table></figure><p>这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">「Caused by: java.lang.OutOfMemoryError: Meta space」</span><br></pre></td></tr></table></figure><p>这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说1.8以前的永久代了)。</p><h2 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h2><p>栈内存溢出，这个大家见到也比较多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">「Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.StackOverflowError」</span><br></pre></td></tr></table></figure><p>表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起OOM。</p><h2 id="使用JMAP定位代码内存泄漏"><a href="#使用JMAP定位代码内存泄漏" class="headerlink" title="使用JMAP定位代码内存泄漏"></a>使用JMAP定位代码内存泄漏</h2><p>上述关于OOM和StackOverflow的代码排查方面，我们一般使用JMAPjmap -dump:format=b,file=filename pid来导出dump文件</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/16.png" alt="Image zoo"></p><p>通过mat(Eclipse Memory Analysis Tools)导入dump文件进行分析，内存泄漏问题一般我们直接选Leak Suspects即可，mat给出了内存泄漏的建议。另外也可以选择Top Consumers来查看最大对象报告。和线程相关的问题可以选择thread overview进行分析。除此之外就是选择Histogram类概览来自己慢慢分析，大家可以搜搜mat的相关教程。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/17.png" alt="Image zoo"></p><p>日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都new对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发gc；ByteBuffer缓存分配不合理等都会造成代码OOM。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">「另一方面，我们可以在启动参数中指定-XX:+HeapDumpOnOutOfMemoryError来保存OOM时的dump文件。」</span><br></pre></td></tr></table></figure><h2 id="gc问题和线程"><a href="#gc问题和线程" class="headerlink" title="gc问题和线程"></a>gc问题和线程</h2><p>gc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常呀等。线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的unable to create new native thread。除了jstack细细分析dump文件外，我们一般先会看下总体线程，通过pstreee -p pid |wc -l。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/18.png" alt="Image zoo"></p><p>或者直接通过查看/proc/pid/task的数量即为线程数量。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/19.png" alt="Image zoo"></p><h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用Netty导致的，那错误日志里可能会出现<strong>「OutOfDirectMemoryError」</strong>错误，如果直接是DirectByteBuffer，那会报<strong>「OutOfMemoryError: Direct buffer memory」</strong>。</p><p>堆外内存溢出往往是和NIO的使用相关，一般我们先通过pmap来查看下进程占用的内存情况pmap -x pid | sort -rn -k3 | head -30，这段意思是查看对应pid倒序前30大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/20.png" alt="Image zoo"></p><p>我们如果确定有可疑的内存端，需要通过gdb来分析<strong>「gdb –batch –pid {pid} -ex “dump memory filename.dump {内存起始地址} {内存起始地址+内存块大小}」</strong>“</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/21.png" alt="Image zoo"></p><p>获取dump文件后可用heaxdump进行查看<strong>「hexdump -C filename | less」</strong>，不过大多数看到的都是二进制乱码。</p><p>NMT是Java7U40引入的HotSpot新特性，配合jcmd命令我们就可以看到具体内存组成了。需要在启动参数中加入 <strong>「-XX:NativeMemoryTracking=summary」</strong> 或者 -<strong>「XX:NativeMemoryTracking=detail」</strong>，会有略微性能损耗。</p><p>一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线<strong>「jcmd pid VM.native_memory baseline」</strong>。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/22.png" alt="Image zoo"></p><p>然后等放一段时间后再去看看内存增长的情况，通过jcmd pid VM.native_memory detail.diff(summary.diff)做一下summary或者detail级别的diff。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/23.png" alt="Image zoo"></p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/24.png" alt="Image zoo"></p><p>可以看到jcmd分析出来的内存十分详细，包括堆内、线程以及gc(所以上述其他内存异常其实都可以用nmt来分析)，这边堆外内存我们重点关注Internal的内存增长，如果增长十分明显的话那就是有问题了。detail级别的话还会有具体内存段的增长情况，如下图。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/25.png" alt="Image zoo"></p><p>此外在系统层面，我们还可以使用strace命令来监控内存分配 strace -f -e “brk,mmap,munmap” -p pid 这边内存分配信息主要包括了pid和内存地址。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/26.png" alt="Image zoo"></p><p>不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如DirectByteBuffer分配内存的话，是需要full GC或者手动system.gc来进行回收的(所以最好不要使用<strong>-XX:+DisableExplicitGC</strong>)。那么其实我们可以跟踪一下DirectByteBuffer对象的内存情况，通过<strong>「jmap -histo:live pid」</strong>手动触发fullGC来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过<strong>-XX:MaxDirectMemorySize</strong>进行调整。如果没有什么变化，那就要使用jmap去分析那些不能被gc的对象，以及和DirectByteBuffer之间的引用关系了。</p><h1 id="GC问题"><a href="#GC问题" class="headerlink" title="GC问题"></a>GC问题</h1><p>堆内内存泄漏总是和GC异常相伴。不过GC问题不只是和内存问题相关，还有可能引起CPU负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下GC相关问题。</p><p>我们在cpu章介绍了使用jstat来获取当前GC分代变化信息。而更多时候，我们是通过GC日志来排查问题的，在启动参数中加上<strong>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</strong>来开启GC日志。常见的Young GC、Full GC日志含义在此就不做赘述了。</p><p>针对gc日志，我们就能大致推断出youngGC与fullGC是否过于频繁或者耗时过长，从而对症下药。我们下面将对G1垃圾收集器来做分析，这边也建议大家使用G1 <strong>「-XX:+UseG1GC」</strong>。</p><h2 id="youngGC过频繁"><a href="#youngGC过频繁" class="headerlink" title="youngGC过频繁"></a>youngGC过频繁</h2><p>youngGC频繁一般是短周期小对象较多，先考虑是不是Eden区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio等参数设置来解决问题。如果参数正常，但是young gc频率还是太高，就需要使用Jmap和MAT对dump文件进行进一步排查了。</p><h2 id="youngGC耗时过长"><a href="#youngGC耗时过长" class="headerlink" title="youngGC耗时过长"></a>youngGC耗时过长</h2><p>耗时过长问题就要看GC日志里耗时耗在哪一块了。以G1日志为例，可以关注Root Scanning、Object Copy、Ref Proc等阶段。Ref Proc耗时长，就要注意引用相关的对象。Root Scanning耗时长，就要注意线程数、跨代引用。Object Copy则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的Root Scanning和正常时间段比增长较多，那就是起的线程太多了。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/27.png" alt="Image zoo"></p><h2 id="触发fullGC"><a href="#触发fullGC" class="headerlink" title="触发fullGC"></a>触发fullGC</h2><p>G1中更多的还是mixedGC，但mixedGC可以和youngGC思路一样去排查。触发fullGC了一般都会有问题，G1会退化使用Serial收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。fullGC的原因可能包括以下这些，以及参数调整方面的一些思路：</p><ol><li>并发阶段失败：在并发标记阶段，MixGC之前老年代就被填满了，那么这时候G1就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数-XX:ConcGCThreads。</li><li>晋升失败：在GC的时候没有足够的内存供存活/晋升对象使用，所以触发了Full GC。这时候可以通过-XX:G1ReservePercent来增加预留内存百分比，减少-XX:InitiatingHeapOccupancyPercent来提前启动标记，-XX:ConcGCThreads来增加标记线程数也是可以的。</li><li>大对象分配失败：大对象找不到合适的region空间进行分配，就会进行fullGC，这种情况下可以增大内存或者增大-XX:G1HeapRegionSize。</li><li>程序主动执行System.gc()：不要随便写就对了。</li></ol><p>另外，我们可以在启动参数中配置<strong>-XX:HeapDumpPath=/xxx/dump.hprof</strong>来dump fullGC相关的文件，并通过jinfo来进行gc前后的dump</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag +HeapDumpBeforeFullGC pid </span><br><span class="line">jinfo -flag +HeapDumpAfterFullGC pid</span><br></pre></td></tr></table></figure><p>这样得到2份dump文件，对比后主要关注被gc掉的问题对象来定位问题。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从tcp层、应用层以及工具的使用等方面进行阐述。</p><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。</p><ol><li>读写超时。readTimeout/writeTimeout，有些框架叫做so_timeout或者socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa的超时指的也是读超时。读写超时一般都只针对客户端设置。</li><li>连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边connectionTimeout就有些五花八门了，jetty中表示空闲连接清理时间，tomcat则表示连接维持的最大时间。</li><li>其他。包括连接获取超时connectionAcquireTimeout和空闲连接清理超时idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。</li></ol><p>我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。</p><p>在实际开发中，我们关心最多的应该是接口的读写超时了。</p><p>如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的tcp连接。而如果接口设置的过短，那么接口超时就会非常频繁。</p><p>服务端接口明明rt降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。</p><h2 id="TCP队列溢出"><a href="#TCP队列溢出" class="headerlink" title="TCP队列溢出"></a>TCP队列溢出</h2><p>tcp队列溢出是个相对底层的错误，它可能会造成超时、rst等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/28.png" alt="Image zoo"></p><p>如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在server收到client的syn后，把消息放到syns queue，回复syn+ack给client，server收到client的ack，如果这时accept queue没满，那就从syns queue拿出暂存的信息放入accept queue中，否则按tcp_abort_on_overflow指示的执行。</p><p>tcp_abort_on_overflow 0表示如果三次握手第三步的时候accept queue满了那么server扔掉client发过来的ack。tcp_abort_on_overflow 1则表示第三步的时候如果全连接队列满了，server发送一个rst包给client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多<strong>「connection reset / connection reset by peer」</strong>。</p><p>那么在实际开发中，我们怎么能快速定位到tcp队列溢出呢？</p><p><strong>「netstat命令，执行netstat -s | egrep “listen|LISTEN”」</strong></p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/29.png" alt="Image zoo"></p><p>如上图所示，overflowed表示全连接队列溢出的次数，sockets dropped表示半连接队列溢出的次数。</p><p><strong>「ss命令，执行ss -lnt」</strong></p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/30.png" alt="Image zoo"></p><p>上面看到Send-Q 表示第三列的listen端口上的全连接队列最大为5，第一列Recv-Q为全连接队列当前使用了多少。</p><p>接着我们看看怎么设置全连接、半连接队列大小吧：</p><p>全连接队列的大小取决于min(backlog, somaxconn)。backlog是在socket创建的时候传入的，somaxconn是一个os级别的系统参数。而半连接队列的大小取决于max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。</p><p>在日常开发中，我们往往使用servlet容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在tomcat中backlog叫做<strong>「acceptCount」</strong>，在jetty里面则是<strong>「acceptQueueSize」</strong>。</p><h2 id="RST异常"><a href="#RST异常" class="headerlink" title="RST异常"></a>RST异常</h2><p>RST包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。</p><p>在实际开发中，我们往往会看到<strong>「connection reset / connection reset by peer」</strong>错误，这种情况就是RST包导致的。</p><p><strong>「端口不存在」</strong></p><p>如果像不存在的端口发出建立连接SYN请求，那么服务端发现自己并没有这个端口则会直接返回一个RST报文，用于中断连接。</p><p><strong>「主动代替FIN终止连接」</strong></p><p>一般来说，正常的连接关闭都是需要通过FIN报文实现，然而我们也可以用RST报文来代替FIN，表示直接终止连接。实际开发中，可设置SO_LINGER数值来控制，这种往往是故意的，来跳过TIMED_WAIT，提供交互效率，不闲就慎用。</p><p><strong>「客户端或服务端有一边发生了异常，该方向对端发送RST以告知关闭连接」</strong></p><p>我们上面讲的tcp队列溢出发送RST包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。</p><p><strong>「接收到的TCP报文不在已知的TCP连接内」</strong></p><p>比如，一方机器由于网络实在太差TCP报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的TCP报文，但由于对应的TCP连接已不存在，那么会直接发一个RST包以便开启新的连接。</p><p><strong>「一方长期未收到另一方的确认报文，在一定时间或重传次数后发出RST报文」</strong></p><p>这种大多也和网络环境相关了，网络环境差可能会导致更多的RST报文。</p><p>之前说过RST报文多会导致程序报错，在一个已关闭的连接上读操作会报connection reset，而在一个已关闭的连接上写操作则会报connection reset by peer。通常我们可能还会看到broken pipe错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到RST，报出connection reset错后继续读写数据报的错，这个在glibc源码注释中也有介绍。</p><p>我们在排查故障时候怎么确定有RST包的存在呢？当然是使用tcpdump命令进行抓包，并使用wireshark进行简单分析了。tcpdump -i en0 tcp -w xxx.cap，en0表示监听的网卡。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/31.png" alt="Image zoo"></p><p>接下来我们通过wireshark打开抓到的包，可能就能看到如下图所示，红色的就表示RST包了。</p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/32.png" alt="Image zoo"></p><p><strong>「TIME_WAIT和CLOSE_WAIT」</strong></p><p>TIME_WAIT和CLOSE_WAIT是啥意思相信大家都知道。在线上时，我们可以直接用命令<strong>netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</strong>来查看time-wait和close_wait的数量</p><p>用ss命令会更快<strong>「ss -ant | awk ‘{++S[$1]} END {for(a in S) print a, S[a]}’」</strong></p><p><img src="/2021/10/09/Troubleshooting/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/33.png" alt="Image zoo"></p><p><strong>「TIME_WAIT」</strong></p><p>time_wait的存在一是为了丢失的数据包被后面连接复用，二是为了在2MSL的时间范围内正常关闭连接。它的存在其实会大大减少RST包的出现。</p><p>过多的time_wait在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="meta">#</span><span class="bash">表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure><p>当然我们不要忘记在NAT环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小<strong>「tcp_max_tw_buckets」</strong>，超过这个数的time_wait都会被干掉，不过这也会导致报<strong>「time wait bucket table overflow」</strong>的错。</p><p><strong>「CLOSE_WAIT」</strong></p><p>close_wait往往都是因为应用程序写的有问题，没有在ACK后再次发起FIN报文。close_wait出现的概率甚至比time_wait要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。</p><p>想要定位这类问题，最好是通过jstack来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。</p><p>开发同学说应用上线后CLOSE_WAIT就一直增多，直到挂掉为止，jstack后找到比较可疑的堆栈是大部分线程都卡在了countdownlatch.await方法，找开发同学了解后得知使用了多线程但是确没有catch异常，修改后发现异常仅仅是最简单的升级sdk后常出现的class not found。</p>]]></content>
      
      
      <categories>
          
          <category> Troubleshooting </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件选型</title>
      <link href="/2021/05/18/Middleware/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B/"/>
      <url>/2021/05/18/Middleware/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h5><ul><li>Pulsar</li><li>Kafka</li><li>RabbitMQ</li><li>ActiveMQ</li><li>RocketMQ</li><li>ZeroMQ</li><li>MNS</li></ul><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><ul><li><p>JMS</p></li><li><p>AMQP</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Middleware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Stream 数据流大数据量下的性能效率怎么样</title>
      <link href="/2021/05/15/CoreJava/Java8%20Stream%20%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E4%B8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%95%88%E7%8E%87%E6%80%8E%E4%B9%88%E6%A0%B7/"/>
      <url>/2021/05/15/CoreJava/Java8%20Stream%20%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E4%B8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%95%88%E7%8E%87%E6%80%8E%E4%B9%88%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CoreJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
            <tag> Java8 </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考资料_Coding</title>
      <link href="/2021/03/31/Coding/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_Coding/"/>
      <url>/2021/03/31/Coding/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_Coding/</url>
      
        <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p><a href="http://sqshijie.cn/blog/Coding/如何快速过滤出一次请求的所有日志.html" target="_blank" rel="noopener">如何快速过滤出一次请求的所有日志</a> </p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">Hexo搭建教程</a> </p>]]></content>
      
      
      <categories>
          
          <category> Coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考资料_CoreJava</title>
      <link href="/2021/03/31/CoreJava/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_CoreJava/"/>
      <url>/2021/03/31/CoreJava/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_CoreJava/</url>
      
        <content type="html"><![CDATA[<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p><a href="http://sqshijie.cn/blog/CoreJava/Java8_Stream1.html" target="_blank" rel="noopener">Java8 Stream：2万字20个实例，玩转集合的筛选、归约、分组、聚合</a> </p><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">Hexo搭建教程</a> </p>]]></content>
      
      
      <categories>
          
          <category> CoreJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型(generics)扫盲贴</title>
      <link href="/2021/03/31/CoreJava/%E6%B3%9B%E5%9E%8B(generics)%E6%89%AB%E7%9B%B2%E8%B4%B4/"/>
      <url>/2021/03/31/CoreJava/%E6%B3%9B%E5%9E%8B(generics)%E6%89%AB%E7%9B%B2%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><h1 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h1><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p><p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class GlmapperGeneric&lt;T&gt; &#123;</span><br><span class="line">  private T t;</span><br><span class="line">    public void set(T t) &#123; this.t = t; &#125;</span><br><span class="line">    public T get() &#123; return t; &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * 不指定类型</span><br><span class="line">    */</span><br><span class="line">  public void noSpecifyType()&#123;</span><br><span class="line">    GlmapperGeneric glmapperGeneric = new GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(&quot;test&quot;);</span><br><span class="line">    // 需要强制类型转换</span><br><span class="line">    String test = (String) glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * 指定类型</span><br><span class="line">    */</span><br><span class="line">  public void specifyType()&#123;</span><br><span class="line">    GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric();</span><br><span class="line">    glmapperGeneric.set(&quot;test&quot;);</span><br><span class="line">    // 不需要强制类型转换</span><br><span class="line">    String test = glmapperGeneric.get();</span><br><span class="line">    System.out.println(test);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。</strong></p><h1 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h1><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p><h2 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h2><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？是这样约定的：</strong></p><ul><li>？表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h2 id="？无界通配符"><a href="#？无界通配符" class="headerlink" title="？无界通配符"></a>？<strong>无界通配符</strong></h2><p>先从一个小例子看起，原文在 这里 。</p><p>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>但是老板的想法确实这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure><p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int countLegs(List&lt;? extends Animal&gt; animals) &#123;</span><br><span class="line">     int retVal = 0;</span><br><span class="line">     for (Animal animal : animals) &#123;</span><br><span class="line">         retVal += animal.countLegs();</span><br><span class="line">     &#125;</span><br><span class="line">     return retVal;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> static int countLegs1(List&lt;Animal&gt; animals) &#123;</span><br><span class="line">     int retVal = 0;</span><br><span class="line">     for (Animal animal : animals) &#123;</span><br><span class="line">         retVal += animal.countLegs();</span><br><span class="line">     &#125;</span><br><span class="line">     return retVal;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">     List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();</span><br><span class="line">     // 不会报错</span><br><span class="line">     countLegs(dogs);</span><br><span class="line">     // 报错</span><br><span class="line">     countLegs1(dogs);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Required type: List&lt;Animal&gt;</span><br><span class="line">Provided: List&lt;Dog&gt;</span><br></pre></td></tr></table></figure><p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p><h2 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h2><blockquote><p>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p></blockquote><p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p><ul><li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li><li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private &lt;K extends A, E extends B&gt; E test(K arg1, E arg2)&#123;</span><br><span class="line">    E result = arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    //.....</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类型参数列表中如果有多个类型参数上限，用逗号分开</p></blockquote><h2 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h2><blockquote><p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p></blockquote><p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src)&#123;</span><br><span class="line">    for (T t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();</span><br><span class="line">    new Test3().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line">// Dog 是 Animal 的子类</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p><h2 id="PECS"><a href="#PECS" class="headerlink" title="PECS"></a>PECS</h2><p>请记住PECS原则：生产者（Producer）使用extends，消费者（Consumer）使用super。</p><ul><li>生产者使用extends</li></ul><p>如果你需要一个列表提供T类型的元素（即你想从列表中读取T类型的元素），你需要把这个列表声明成&lt;? extends T&gt;，比如List&lt;? extends Integer&gt;，因此你不能往该列表中添加任何元素。</p><ul><li>消费者使用super</li></ul><p>如果需要一个列表使用T类型的元素（即你想把T类型的元素加入到列表中），你需要把这个列表声明成&lt;? super T&gt;，比如List&lt;? super Integer&gt;，因此你不能保证从中读取到的元素的类型。</p><ul><li>即是生产者，也是消费者</li></ul><p>如果一个列表即要生产，又要消费，你不能使用泛型通配符声明列表，比如List<Integer>。</Integer></p><p>更多请参考：<a href="https://www.cnblogs.com/lucky_dai/p/5485421.html" target="_blank" rel="noopener">https://www.cnblogs.com/lucky_dai/p/5485421.html</a></p><h2 id="？和-T-的区别"><a href="#？和-T-的区别" class="headerlink" title="？和 T 的区别"></a>？和 T 的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 指定集合元素只能是T类型</span><br><span class="line">List&lt;T&gt; list = new ArrayList&lt;T&gt;();</span><br><span class="line">// 集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</span><br><span class="line">List&lt;?&gt; list = new ArrayList&lt;?&gt;();</span><br></pre></td></tr></table></figure><p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 可以</span><br><span class="line">T t = operate();</span><br><span class="line"></span><br><span class="line">// 不可以</span><br><span class="line">？car = operate();</span><br></pre></td></tr></table></figure><p>简单总结下：</p><p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p><h3 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 通过 T 来 确保 泛型参数的一致性</span><br><span class="line">public &lt;T extends Number&gt; void test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line">// 通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span><br><span class="line">public void</span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure><p>比如一个泛型方法约定的 T 是 Number 的子类，如果申明时是用的 String ，编译就会飘红报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; dest = null;</span><br><span class="line">List&lt;String&gt; src = null;</span><br><span class="line">test(dest, src); // 编译报错</span><br><span class="line">public &lt;T extends Number&gt; void test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br></pre></td></tr></table></figure><p>不能保证两个 List 具有相同的元素类型的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();</span><br><span class="line">List&lt;String&gt; dest = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; src = new ArrayList&lt;&gt;();</span><br><span class="line">glmapperGeneric.testNon(dest, src);</span><br></pre></td></tr></table></figure><p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p><h3 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test4 implements MultiLimitInterfaceA, MultiLimitInterfaceB &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用&quot;&amp;&quot;符号设定多重边界(Multi Bounds)</span><br><span class="line">     * @param t</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T extends MultiLimitInterfaceA &amp; MultiLimitInterfaceB&gt; void test(T t) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MultiLimitInterfaceA &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">interface MultiLimitInterfaceB &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。 </p><h3 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h3><p>类型参数 T 只具有 一种 类型限定方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure><p>但是通配符 ? 可以进行 两种限定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure><h1 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt;T&gt;和 Class&lt;?&gt;区别"></a><code>Class&lt;T&gt;</code>和 <code>Class&lt;?&gt;</code>区别</h1><p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过反射的方式生成  multiLimit</span><br><span class="line">// 对象，这里比较明显的是，我们需要使用强制类型转换</span><br><span class="line">MultiLimit multiLimit = (MultiLimit)</span><br><span class="line">Class.forName(&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;).newInstance();</span><br></pre></td></tr></table></figure><p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p><p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test5 &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        return clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        A a = createInstance(A.class);</span><br><span class="line">        B b = createInstance(B.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Class&lt;T&gt;</code>在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code>它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 可以</span><br><span class="line">public Class&lt;?&gt; clazz;</span><br><span class="line">// 不可以，因为 T 需要指定类型</span><br><span class="line">public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure><p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Test3&lt;T&gt; &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code>这样的话，就必须让当前的类也指定 T </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test3&lt;T&gt; &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    // 不会报错</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html#3-5%E7%BC%96%E8%AF%91%E6%97%B6%E9%9B%86%E5%90%88%E7%9A%84instanceof" target="_blank" rel="noopener">https://www.cnblogs.com/wuqinglong/p/9456193.html#3-5%E7%BC%96%E8%AF%91%E6%97%B6%E9%9B%86%E5%90%88%E7%9A%84instanceof</a></p>]]></content>
      
      
      <categories>
          
          <category> CoreJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考资料_MySQL</title>
      <link href="/2021/03/31/Database/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_MySQL/"/>
      <url>/2021/03/31/Database/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h1><p><a href="http://sqshijie.cn/blog/Database/slow_query1.html" target="_blank" rel="noopener">一张900w的数据表，16s执行的SQL优化到300ms？</a> </p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">Hexo搭建教程</a> </p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考资料_Interview</title>
      <link href="/2021/03/31/Interview/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_Interview/"/>
      <url>/2021/03/31/Interview/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_Interview/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点整理"><a href="#知识点整理" class="headerlink" title="知识点整理"></a>知识点整理</h1><p><a href="http://sqshijie.cn/blog/Interview/JAVA核心知识点整理.html" target="_blank" rel="noopener">JAVA核心知识点整理</a> </p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p><a href="https://www.jianshu.com/p/4eaddcbe4d12" target="_blank" rel="noopener">Hexo搭建教程</a> </p>]]></content>
      
      
      <categories>
          
          <category> Interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>参考资料_架构_系统_性能</title>
      <link href="/2021/03/31/%E6%9E%B6%E6%9E%84_%E7%B3%BB%E7%BB%9F_%E6%80%A7%E8%83%BD/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_%E6%9E%B6%E6%9E%84_%E7%B3%BB%E7%BB%9F_%E6%80%A7%E8%83%BD/"/>
      <url>/2021/03/31/%E6%9E%B6%E6%9E%84_%E7%B3%BB%E7%BB%9F_%E6%80%A7%E8%83%BD/%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99_%E6%9E%B6%E6%9E%84_%E7%B3%BB%E7%BB%9F_%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="系统性能"><a href="#系统性能" class="headerlink" title="系统性能"></a>系统性能</h1><p><a href="http://sqshijie.cn/blog/架构_系统_性能/系统性能分析从入门到进阶.html" target="_blank" rel="noopener">系统性能分析从入门到进阶</a> </p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><p><a href="http://sqshijie.cn/blog/架构_系统_性能/创业公司搭建自己的技术架构.html" target="_blank" rel="noopener">创业公司搭建自己的技术架构</a> </p><p><a href="http://sqshijie.cn/blog/架构_系统_性能/从零开始搭建公司高并发架构技术.html" target="_blank" rel="noopener">从零开始搭建公司高并发架构技术栈，这套架构绝了…</a> </p>]]></content>
      
      
      <categories>
          
          <category> 架构_系统_性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal扫盲贴</title>
      <link href="/2021/03/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E6%89%AB%E7%9B%B2%E8%B4%B4/"/>
      <url>/2021/03/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E6%89%AB%E7%9B%B2%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="在什么场景下会使用-ThreadLocal"><a href="#在什么场景下会使用-ThreadLocal" class="headerlink" title="在什么场景下会使用 ThreadLocal"></a>在什么场景下会使用 ThreadLocal</h1><h2 id="场景一：ThreadLocal-MDC-实现链路日志增强"><a href="#场景一：ThreadLocal-MDC-实现链路日志增强" class="headerlink" title="场景一：ThreadLocal+MDC 实现链路日志增强"></a>场景一：<strong>ThreadLocal+MDC 实现链路日志增强</strong></h2><p>文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&mid=2650325282&idx=1&sn=49bdfb4acb903783031b7dc7e7164a27&fileGuid=Ty8hqrvhtDydKt8V&scene=21#wechat_redirect" target="_blank" rel="noopener">有了链路日志增强，排查 Bug 小意思啦！</a></p><p>比如我们需要在整个链路的日志中输出当前登录的用户 ID，首先就得在拦截器获取过滤器中获取用户 ID，然后将用户 ID 进行存储到 ThreadLocal。</p><p>然后再层层进行透传，如果用的 Dubbo，那么就在 Dubbo 的 Filter 中进行传递到下一个服务中。问题来了，在 Dubbo 的 Filter 中如何获取前面存储的用户 ID 呢？</p><p>答案就是 ThreadLocal。获取后添加到 MDC 中，就可以在日志中输出用户 ID。</p><h2 id="场景二：ThreadLocal-实现线程内的缓存，避免重复调用"><a href="#场景二：ThreadLocal-实现线程内的缓存，避免重复调用" class="headerlink" title="场景二：ThreadLocal 实现线程内的缓存，避免重复调用"></a>场景二：<strong>ThreadLocal 实现线程内的缓存，避免重复调用</strong></h2><p>文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&mid=2650322521&idx=1&sn=4b4ad8c84013b17bce4c7bb287441a2d&fileGuid=Ty8hqrvhtDydKt8V&scene=21#wechat_redirect" target="_blank" rel="noopener">简直骚操作，ThreadLocal 还能当缓存用</a></p><h2 id="场景三：ThreadLocal-实现数据库读写分离下强制读主库"><a href="#场景三：ThreadLocal-实现数据库读写分离下强制读主库" class="headerlink" title="场景三：ThreadLocal 实现数据库读写分离下强制读主库"></a>场景三：<strong>ThreadLocal 实现数据库读写分离下强制读主库</strong></h2><p>首先你的项目中要做了读写分离，如果有对读写分离不了解的同学可以查看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&mid=2650320348&idx=1&sn=524e7e461d8ecb18e6eb3a555b84b517&fileGuid=Ty8hqrvhtDydKt8V&scene=21#wechat_redirect" target="_blank" rel="noopener">读写分离</a></p><p>某些业务场景下，必须保证数据的及时性。主从同步有延迟，可以使用强制读主库来保证数据的一致性。</p><p>在 Sharding JDBC 中，有提供对应的 API 来设置强制路由到主库，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HintManager hintManager = HintManager.getInstance();</span><br><span class="line">hintManager.setMasterRouteOnly();</span><br></pre></td></tr></table></figure><p>HintManager 中就使用了 ThreadLocal 来存储相关信息。这样就可以实现在业务代码中设置路由信息，在底层的数据库路由那块获取信息，实现优雅的数据传递。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final class HintManager implements AutoCloseable &#123;</span><br><span class="line">    private static final ThreadLocal&lt;HintManager&gt; HINT_MANAGER_HOLDER = new ThreadLocal();</span><br><span class="line">    // ...............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="场景四：ThreadLocal-实现同一线程下多个类之间的数据传递"><a href="#场景四：ThreadLocal-实现同一线程下多个类之间的数据传递" class="headerlink" title="场景四：ThreadLocal 实现同一线程下多个类之间的数据传递"></a>场景四：<strong>ThreadLocal 实现同一线程下多个类之间的数据传递</strong></h2><p>在 Spring Cloud Zuul 中，过滤器是必须要用的。用过滤器我们可以实现权限认证，日志记录，限流等功能。</p><p>过滤器有多个，而且是按顺序执行的。过滤器之前要透传数据该如何处理？</p><p>Zuul 中已经提供了 RequestContext 来实现数据传递，比如我们在进行拦截的时候会使用下面的代码告诉负责转发的过滤器不要进行转发操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestContext.getCurrentContext().setSendZuulResponse(false);</span><br></pre></td></tr></table></figure><p>RibbonRoutingFilter 中就可以通过 RequestContext 获取对应的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean shouldFilter() &#123;</span><br><span class="line">   RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">   return (ctx.getRouteHost() == null &amp;&amp; ctx.get(SERVICE_ID_KEY) != null</span><br><span class="line">         &amp;&amp; ctx.sendZuulResponse());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestContext 中就用了 ThreadLocal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class RequestContext extends ConcurrentHashMap&lt;String, Object&gt; &#123;</span><br><span class="line">    protected static final ThreadLocal&lt;? extends RequestContext&gt; threadLocal = new ThreadLocal&lt;RequestContext&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected RequestContext initialValue() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return contextClass.newInstance();</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // .........................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h2><p><img src="/2021/03/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E6%89%AB%E7%9B%B2%E8%B4%B4/02.png" alt="Image png"></p><p><strong>Spring</strong> 采用 <strong>Threadlocal</strong> 的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理 connection 对象，通过传播级别，巧妙地管理多个事务配置之间的切换，挂起和恢复。</p><p>Spring 框架里面就是用的 ThreadLocal 来实现这种隔离，主要是在 <code>**TransactionSynchronizationManager**</code>这个类里面，代码如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static final Log logger = LogFactory.getLog(TransactionSynchronizationManager.class);</span><br><span class="line"></span><br><span class="line"> private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">   new NamedThreadLocal&lt;&gt;(&quot;Transactional resources&quot;);</span><br><span class="line"></span><br><span class="line"> private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">   new NamedThreadLocal&lt;&gt;(&quot;Transaction synchronizations&quot;);</span><br><span class="line"></span><br><span class="line"> private static final ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">   new NamedThreadLocal&lt;&gt;(&quot;Current transaction name&quot;);</span><br><span class="line"></span><br><span class="line">  ……</span><br></pre></td></tr></table></figure><p>Spring 的事务主要是 <strong>ThreadLocal 和 AOP 去做实现</strong>的，大家知道每个线程自己的链接是靠 ThreadLocal 保存的就好了，</p><p>除了源码里面使用到 ThreadLocal 的场景，你自己有使用他的场景么？一般你会怎么用呢？</p><h3 id="使用场景1"><a href="#使用场景1" class="headerlink" title="使用场景1"></a>使用场景1</h3><p>之前我们上线后发现部分用户的日期居然不对了，排查下来是 <code>SimpleDataFormat</code> 的锅，当时我们使用 SimpleDataFormat 的 parse()方法，内部有一个 Calendar 对象，调用 SimpleDataFormat 的 parse()方法会先调用 Calendar.clear（），然后调用 Calendar.add()，如果一个线程先调用了 add()然后另一个线程又调用了 clear()，这时候 parse()方法解析的时间就不对了。</p><p>其实要解决这个问题很简单，让每个线程都 new 一个自己的 <code>SimpleDataFormat</code> 就好了，但是 1000 个线程难道 new1000 个 <code>SimpleDataFormat</code>？</p><p>所以当时我们使用了线程池加上 ThreadLocal 包装 <code>SimpleDataFormat</code>，再调用 initialValue 让每个线程有一个 <code>SimpleDataFormat</code>的副本，从而解决了线程安全的问题，也提高了性能。</p><h3 id="使用场景2"><a href="#使用场景2" class="headerlink" title="使用场景2"></a>使用场景2</h3><p>我在项目中存在一个线程经常遇到横跨若干方法调用，需要传递的对象，也就是上下文（Context），它是一种状态，经常就是是用户身份、任务信息等，就会存在过渡传参的问题。</p><p>使用到<strong>类似责任链模式</strong>，给每个方法增加一个 context 参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，对象参数就传不进去了。</p><p>所以我使用到了 ThreadLocal 去做了一下改造，这样只需要在调用前在 ThreadLocal 中设置参数，其他地方 get 一下就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">  </span><br><span class="line">void work(User user) &#123;</span><br><span class="line">    getInfo(user);</span><br><span class="line">    checkInfo(user);</span><br><span class="line">    setSomeThing(user);</span><br><span class="line">    log(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line">  </span><br><span class="line">void work(User user) &#123;</span><br><span class="line">try&#123;</span><br><span class="line">   threadLocalUser.set(user);</span><br><span class="line">   // 他们内部  User u = threadLocalUser.get(); 就好了</span><br><span class="line">    getInfo();</span><br><span class="line">    checkInfo();</span><br><span class="line">    setSomeThing();</span><br><span class="line">    log();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">     threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看了一下很多场景的 cookie，session 等数据隔离都是通过 ThreadLocal 去做实现的。</p><h3 id="使用场景3"><a href="#使用场景3" class="headerlink" title="使用场景3"></a>使用场景3</h3><p>在 Android 中，<strong>Looper</strong> 类就是利用了 ThreadLocal 的特性，保证每个线程只存在一个 Looper 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadLocal-的原理"><a href="#ThreadLocal-的原理" class="headerlink" title="ThreadLocal 的原理"></a>ThreadLocal 的原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; localName = new ThreadLocal();</span><br><span class="line">localName.set(&quot;张三&quot;);</span><br><span class="line">String name = localName.get();</span><br><span class="line">localName.remove();</span><br></pre></td></tr></table></figure><p>其实使用真的很简单，线程进来之后初始化一个可以泛型的 ThreadLocal 对象，之后这个线程只要在 remove 之前去 get，都能拿到之前 set 的值，注意这里我说的是 remove 之前。他是能做到<strong>线程间数据隔离</strong>的，所以别的线程使用 get（）方法是没办法拿到其他线程的值的，但是有办法可以做到</p><p>ThreadLocal 在使用的时候是单独创建对象的，更像一个全局的容器。但是大家有没有想过一个问题，<strong>就是为啥要设计 ThreadLocal 这个类，而不使用 HashMap 这样的容器类？</strong></p><p>ThreadLocal 本质上是要解决线程之间数据的隔离，以达到互不影响的目的。如果我们用一个 Map 做数据存储，Key 为线程 ID, Value 为你要存储的内容，其实也是能达到隔离的效果。</p><p>没错，效果是能达到，但是性能就不一定好了，涉及到多个线程进行数据操作。如果你不看 ThreadLocal 的源码，你肯定也会以为 ThreadLocal 就是这么实现的。</p><p>ThreadLocal 在设计这块很巧妙，会在 Thread 类中嵌入一个 ThreadLocalMap，ThreadLocalMap 就是一个容器，用于存储数据的，但它在 Thread 类中，也就说存储的就是这个 Thread 类专享的数据。</p><p>原本我们以为的 ThreadLocal 设置值的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocal.put(t.getId(), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置值的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();// 获取当前线程</span><br><span class="line">    ThreadLocalMap map = getMap(t);// 获取 ThreadLocalMap 对象</span><br><span class="line">    if (map != null) // 校验对象是否为空</span><br><span class="line">        map.set(this, value); // 不为空 set</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value); // 为空创建一个 map 对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，先是获取当前线程对象，然后从当前线程中获取线程的 ThreadLocalMap，值是添加到这个 ThreadLocalMap 中的，key 就是当前 ThreadLocal 的对象。从使用的 API 看上去像是把值存储在了 ThreadLocal 中，其实值是存储在线程内部，然后关联了对应的 ThreadLocal，这样通过 ThreadLocal.get 时就能获取到对应的值。</p><p>大家可以发现 set 的源码很简单，主要就是 <strong>ThreadLocalMap</strong> 我们需要关注一下，而 ThreadLocalMap 呢是当前线程 Thread 一个叫 threadLocals 的变量中获取的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">        return t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">      ……</span><br><span class="line"></span><br><span class="line">    /* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line">     * by the ThreadLocal class. */</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="line">     * maintained by the InheritableThreadLocal class.</span><br><span class="line">     */</span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br><span class="line">  </span><br><span class="line">     ……</span><br></pre></td></tr></table></figure><p>这里我们基本上可以找到 ThreadLocal 数据隔离的真相了，每个线程 Thread 都维护了自己的 threadLocals 变量，所以在每个线程创建 ThreadLocal 的时候，实际上数据是存在自己线程 Thread 的 threadLocals 变量里面的，别人没办法拿到，从而实现了隔离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E6%89%AB%E7%9B%B2%E8%B4%B4/01.png" alt="Image png"></p><p>有个 Map 那他的数据结构其实是很像 HashMap 的，但是看源码可以发现，它并未实现 Map 接口，而且他的 Entry 是继承 WeakReference（弱引用）的，也没有看到 HashMap 中的 next，所以不存在链表了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            /** The value associated with this ThreadLocal. */</span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                super(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/03/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E6%89%AB%E7%9B%B2%E8%B4%B4/03.png" alt="Image png"></p><h2 id="为什么需要数组呢？没有了链表怎么解决-Hash-冲突呢？"><a href="#为什么需要数组呢？没有了链表怎么解决-Hash-冲突呢？" class="headerlink" title="为什么需要数组呢？没有了链表怎么解决 Hash 冲突呢？"></a>为什么需要数组呢？没有了链表怎么解决 Hash 冲突呢？</h2><p>用<strong>数组</strong>是因为，我们开发过程中可以一个线程可以有多个 TreadLocal 来<strong>存放不同类型的对象</strong>的，但是他们都将放到你当前线程的 ThreadLocalMap 里，所以肯定要数组来存。</p><p>至于 Hash 冲突，我们先看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line">            int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">            for (Entry e = tab[i];</span><br><span class="line">                 e != null;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                if (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (k == null) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tab[i] = new Entry(key, value);</span><br><span class="line">            int sz = ++size;</span><br><span class="line">            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我从源码里面看到 ThreadLocalMap 在存储的时候会给每一个 ThreadLocal 对象一个 threadLocalHashCode，在插入过程中，根据 ThreadLocal 对象的 hash 值，定位到 table 中的位置 i，<strong>int i = key.threadLocalHashCode &amp; (len-1)</strong>。</p><p>然后会判断一下：</p><ul><li><p>如果当前位置是空的，就初始化一个 Entry 对象放在位置 i 上；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (k == null) &#123;</span><br><span class="line">    replaceStaleEntry(key, value, i);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果位置 i 不为空，如果这个 Entry 对象的 key 正好是即将设置的 key，那么就刷新 Entry 中的 value；</p><p><img src="/2021/03/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E6%89%AB%E7%9B%B2%E8%B4%B4/04.png" alt="Image png"></p></li></ul><p>这样的话，在 get 的时候，也会根据 ThreadLocal 对象的 <strong>hash</strong> 值，定位到 table 中的位置，然后判断该位置 Entry 对象中的 key 是否和 get 的 key 一致，如果不一致，就判断下一个位置，set 和 get 如果冲突严重的话，效率还是很低的。</p><p>以下是 get 的源码，是不是就感觉很好懂了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">            int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">                return e;</span><br><span class="line">            else</span><br><span class="line">                return getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            int len = tab.length;</span><br><span class="line">// get 的时候一样是根据 ThreadLocal 获取到 table 的 i 值，然后查找数据拿到后会对比 key 是否相等  if (e != null &amp;&amp; e.get() == key)。</span><br><span class="line">            while (e != null) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">              // 相等就直接返回，不相等就继续查找，找到相等位置。</span><br><span class="line">                if (k == key)</span><br><span class="line">                    return e;</span><br><span class="line">                if (k == null)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                else</span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="对象存放在哪里"><a href="#对象存放在哪里" class="headerlink" title="对象存放在哪里"></a>对象存放在哪里</h2><p>在 Java 中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，而堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。</p><h2 id="是不是说-ThreadLocal-的实例以及其值存放在栈上呢？"><a href="#是不是说-ThreadLocal-的实例以及其值存放在栈上呢？" class="headerlink" title="是不是说 ThreadLocal 的实例以及其值存放在栈上呢？"></a>是不是说 ThreadLocal 的实例以及其值存放在栈上呢？</h2><p>其实不是的，因为 ThreadLocal 实例实际上也是被其创建的类持有（更顶端应该是被线程持有），而 ThreadLocal 的值其实也是被线程实例持有，它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。</p><h2 id="如果我想共享线程的-ThreadLocal-数据怎么办？"><a href="#如果我想共享线程的-ThreadLocal-数据怎么办？" class="headerlink" title="如果我想共享线程的 ThreadLocal 数据怎么办？"></a>如果我想共享线程的 ThreadLocal 数据怎么办？</h2><p>使用 <code>InheritableThreadLocal</code>可以实现多个线程访问 ThreadLocal 的值，我们在主线程中创建一个 <code>InheritableThreadLocal</code>的实例，然后在子线程中得到这个 <code>InheritableThreadLocal</code>实例设置的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void test() &#123;    </span><br><span class="line">final ThreadLocal threadLocal = new InheritableThreadLocal();       </span><br><span class="line">threadLocal.set(&quot;帅得一匹&quot;);    </span><br><span class="line">Thread t = new Thread() &#123;        </span><br><span class="line">    @Override        </span><br><span class="line">    public void run() &#123;            </span><br><span class="line">      super.run();            </span><br><span class="line">      Log.i( &quot;张三帅么 =&quot; + threadLocal.get());        </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;;          </span><br><span class="line">  t.start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子线程中我是能够正常输出那一行日志的，这也是我之前面试视频提到过的父子线程数据传递的问题。</p><h2 id="怎么传递的呀"><a href="#怎么传递的呀" class="headerlink" title="怎么传递的呀"></a>怎么传递的呀</h2><p>传递的逻辑很简单，我在开头 Thread 代码提到 threadLocals 的时候，你们再往下看看我刻意放了另外一个变量：</p><p><img src="/2021/03/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E6%89%AB%E7%9B%B2%E8%B4%B4/05.png" alt="Image png"></p><p>Thread 源码中，我们看看 Thread.init 初始化创建的时候做了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">  ……</span><br><span class="line">   if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)</span><br><span class="line">      this.inheritableThreadLocals=ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果线程的 <code>inheritThreadLocals</code>变量不为空，比如我们上面的例子，而且父线程的 <code>inheritThreadLocals</code>也存在，那么我就把父线程的 <code>inheritThreadLocals</code> 给当前线程的 <code>inheritThreadLocals</code>。</p><h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p><img src="/2021/03/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E6%89%AB%E7%9B%B2%E8%B4%B4/06.png" alt="Image png"></p><p>ThreadLocal 在保存的时候会把自己当做 Key 存在 ThreadLocalMap 中，正常情况应该是 key 和 value 都应该被外界强引用才对，但是现在 key 被设计成 WeakReference 弱引用了。</p><p><img src="/2021/03/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal%E6%89%AB%E7%9B%B2%E8%B4%B4/07.png" alt="Image png"></p><blockquote><p>只具有弱引用的对象拥有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p></blockquote><blockquote><p>不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p></blockquote><p>这就导致了一个问题，ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，如果创建 ThreadLocal 的线程一直持续运行，那么这个 Entry 对象中的 value 就有可能一直得不到回收，发生内存泄露。</p><p>就比如<strong>线程池里面的线程</strong>，线程都是复用的，那么之前的线程实例处理完之后，出于复用的目的线程依然存活，所以，ThreadLocal 设定的 value 值被持有，导致内存泄露。</p><p>按照道理一个线程使用完，ThreadLocalMap 是应该要被清空的，但是现在线程被复用了。</p><h2 id="怎么解决内存泄露"><a href="#怎么解决内存泄露" class="headerlink" title="怎么解决内存泄露"></a>怎么解决内存泄露</h2><p>在代码的最后使用 remove 就好了，我们只要记得在使用的最后用 remove 把值清空就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; localName = new ThreadLocal();</span><br><span class="line">try &#123;</span><br><span class="line">    localName.set(&quot;张三&quot;);</span><br><span class="line">    ……</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    localName.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 的源码很简单，找到对应的值全部置空，这样在垃圾回收器回收的时候，会自动把他们回收掉。</p><h2 id="那为什么-ThreadLocalMap-的-key-要设计成弱引用？"><a href="#那为什么-ThreadLocalMap-的-key-要设计成弱引用？" class="headerlink" title="那为什么 ThreadLocalMap 的 key 要设计成弱引用？"></a>那为什么 ThreadLocalMap 的 key 要设计成弱引用？</h2><p>key 不设置成<strong>弱引用</strong>的话就会造成和 entry 中 value 一样内存泄漏的场景。</p><p>补充一点：<strong>ThreadLocal 的不足</strong>，我觉得可以通过看看 netty 的 fastThreadLocal 来弥补</p><h1 id="使用-ThreadLocal-需要注意的地方"><a href="#使用-ThreadLocal-需要注意的地方" class="headerlink" title="使用 ThreadLocal 需要注意的地方"></a>使用 ThreadLocal 需要注意的地方</h1><ul><li>避免跨线程异步传递，虽然有解决方案，文末介绍了方案</li><li>使用时记得及时 remove, 防止内存泄露</li><li>注释说明使用场景，方便后人</li><li>对性能有极致要求可以参考开源框架的做法，用一些优化后的类，比如 FastThreadLocal</li></ul><h1 id="有什么方式能提高-ThreadLocal-的性能"><a href="#有什么方式能提高-ThreadLocal-的性能" class="headerlink" title="有什么方式能提高 ThreadLocal 的性能"></a>有什么方式能提高 ThreadLocal 的性能</h1><p>因为在一些开源的框架中也有使用 ThreadLocal 的场景，但是这些框架为了让性能更好，一般都会做一些优化。</p><p>比如 Netty 中就重写了一个 FastThreadLocal 来代替 ThreadLocal，性能在一定场景下比 ThreadLocal 更好。</p><p>性能提升主要表现在如下几点：</p><ul><li>FastThreadLocal 操作数据的时候，会使用下标的方式在数组中进行查找来代替 ThreadLocal 通过哈希的方式进行查找。</li><li>FastThreadLocal 利用字节填充来解决伪共享问题。</li></ul><p>其实除了 Netty 中对 ThreadLocal 进行了优化，自定义了 FastThreadLocal。在其他的框架中也有类似的优化，比如 Dubbo 中就 InternalThreadLocal，根据源码中的注释，也是参考了 FastThreadLocal 的设计，基本上差不多。</p><h1 id="如何将-ThreadLocal-的数据传递到子线程中"><a href="#如何将-ThreadLocal-的数据传递到子线程中" class="headerlink" title="如何将 ThreadLocal 的数据传递到子线程中"></a>如何将 ThreadLocal 的数据传递到子线程中</h1><p>InheritableThreadLocal 可以将值从当前线程传递到子线程中，但这种场景其实用的不多，我相信很多人都没怎么听过 InheritableThreadLocal。</p><p><strong>那为什么 InheritableThreadLocal 就可以呢？</strong></p><p>InheritableThreadLocal 这个类继承了 ThreadLocal，重写了 3 个方法，在当前线程上创建一个新的线程实例 Thread 时，会把这些线程变量从当前线程传递给新的线程实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes the child&apos;s initial value for this inheritable thread-local</span><br><span class="line">     * variable as a function of the parent&apos;s value at the time the child</span><br><span class="line">     * thread is created.  This method is called from within the parent</span><br><span class="line">     * thread before the child is started.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This method merely returns its input argument, and should be overridden</span><br><span class="line">     * if a different behavior is desired.</span><br><span class="line">     *</span><br><span class="line">     * @param parentValue the parent thread&apos;s value</span><br><span class="line">     * @return the child thread&apos;s initial value</span><br><span class="line">     */</span><br><span class="line">    protected T childValue(T parentValue) &#123;</span><br><span class="line">        return parentValue;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Get the map associated with a ThreadLocal.</span><br><span class="line">     *</span><br><span class="line">     * @param t the current thread</span><br><span class="line">     */</span><br><span class="line">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">       return t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Create the map associated with a ThreadLocal.</span><br><span class="line">     *</span><br><span class="line">     * @param t the current thread</span><br><span class="line">     * @param firstValue value for the initial entry of the table.</span><br><span class="line">     */</span><br><span class="line">    void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到 InheritableThreadLocal 重写了 childValue, getMap,createMap 三个方法，当我们往里面 set 值的时候，值保存到了 inheritableThreadLocals 里面，而不是之前的 threadLocals。</p><p>关键的点来了，为什么当创建新的线程时，可以获取到上个线程里的 threadLocal 中的值呢？原因就是在新创建线程的时候，会把之前线程的 inheritableThreadLocals 赋值给新线程的 inheritableThreadLocals，通过这种方式实现了数据的传递。</p><p>源码最开始在 Thread 的 init 方法中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (parent.inheritableThreadLocals != null)</span><br><span class="line">    this.inheritableThreadLocals =</span><br><span class="line">               ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure><p>createInheritedMap 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">        return new ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">      Entry[] parentTable = parentMap.table;</span><br><span class="line">      int len = parentTable.length;</span><br><span class="line">      setThreshold(len);</span><br><span class="line">      table = new Entry[len];</span><br><span class="line">      for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            Entry e = parentTable[j];</span><br><span class="line">            if (e != null) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                if (key != null) &#123;</span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line">                    Entry c = new Entry(key, value);</span><br><span class="line">                    int h = key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                    while (table[h] != null)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程池中如何实现-ThreadLocal-的数据传递"><a href="#线程池中如何实现-ThreadLocal-的数据传递" class="headerlink" title="线程池中如何实现 ThreadLocal 的数据传递"></a>线程池中如何实现 ThreadLocal 的数据传递</h1><p>如果涉及到线程池使用 ThreadLocal, 必然会出现问题。首先线程池的线程是复用的，其次，比如你从 Tomcat 的线程到自己的业务线程，也就是跨线程池了，线程也就不是之前的那个线程了，也就是说 ThreadLocal 就用不了，那么如何解决呢？</p><p>可以使用阿里的 ttl 来解决，之前我也写过一篇文章，可以查看：<a href="https://mp.weixin.qq.com/s?__biz=MzIwMDY0Nzk2Mw==&mid=2650319274&idx=1&sn=0a5bf8ef9148ba8562e0e1c58038da98&fileGuid=Ty8hqrvhtDydKt8V&scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Cloud 中 Hystrix 线程隔离导致 ThreadLocal 数据丢失</a></p><p>贴上 ttl 的链接：<a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local</a></p><p><a href="https://github.com/Nepxion/DiscoveryAgent" target="_blank" rel="noopener">https://github.com/Nepxion/DiscoveryAgent</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 命名规范</title>
      <link href="/2021/03/31/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/2021/03/31/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>在本文中，将从大到小，从外到内，总结Java编程中的命名规范。文中将会涉及到日常工作中常见的命名示例，如包命名，类命名，接口命名，方法命名，变量命名，常类命名，抽象类命名，异常类命名以及扩展类命名等。我将按照项目工程目录结构，从包，类(接口，抽象类，异常类)，方法，变量和常量的顺序展开介绍。</p><p>本文是 Java 命名规范的介绍，建议收藏转发。</p><h4 id="1-包命名规范"><a href="#1-包命名规范" class="headerlink" title="1. 包命名规范"></a>1. 包命名规范</h4><p>包(Package)的作用是将功能相似或相关的类或者接口进行分组管理，便于类的定位和查找，同时也可以使用包来避免类名的冲突和访问控制，使代码更容易维护。通常，包命使用小写英文字母进行命名，并使用“.”进行分割，每个被分割的单元只能包含一个名词。</p><p>一般地，包命名常采用顶级域名作为前缀，例如com，net，org，edu，gov，cn，io等，随后紧跟公司/组织/个人名称以及功能模块名称。下面是一些包命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.boot.autoconfigure.cloud</span><br><span class="line">package org.springframework.boot.util</span><br><span class="line">package org.hibernate.action</span><br><span class="line">package org.hibernate.cfg</span><br><span class="line">package com.alibaba.druid</span><br><span class="line">package com.alibaba.druid.filter</span><br><span class="line">package com.alibaba.nacos.client.config</span><br><span class="line">package com.ramostear.blog.web</span><br></pre></td></tr></table></figure><p>下面是Oracle Java的一些常见包命名例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package java.beans</span><br><span class="line">package java.io</span><br><span class="line">package java.lang</span><br><span class="line">package java.net</span><br><span class="line">package java.util</span><br><span class="line">package javax.annotation</span><br></pre></td></tr></table></figure><h4 id="2-类命名规范"><a href="#2-类命名规范" class="headerlink" title="2. 类命名规范"></a>2. 类命名规范</h4><p>类(Class)通常采用名词进行命名，且首字母大写，如果一个类名包含两个以上名词，建议使用驼峰命名(Camel-Case)法书写类名,每个名词首字母也应该大写。一般地，类名的书写尽量使其保持简单和描述的完整性，因此在书写类名时不建议使用缩写(一些约定俗成的命名除外。</p><p>例如 Internationalization and Localization 缩写成i18n，Uniform Resource Identifier缩写成URI，Data Access Object缩写成DAO，JSON Web Token缩写成JWT，HyperText Markup Language缩写成HTML等等)。下列是一些常见的类命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class UserDTO&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class EmployeeService&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class StudentDAO&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">class OrderItemEntity&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class OrderItemController&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 Oracle Java 中的一些标准命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HTMLEditorKit&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public abstract class HttpContext&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface ImageObserver&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class ArrayIndexOutOfBoundsException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class enum Thread.State&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-接口命名规范"><a href="#2-1-接口命名规范" class="headerlink" title="2.1 接口命名规范"></a>2.1 接口命名规范</h5><p>首先，接口(Interface)是一种表述某一类型对象动作的特殊类；简单来说，接口也是类(不太严谨)，所以，接口的名称的书写也应该符合类名书写规范，首字母应该大写，与普通类名不同的是，接口命名时通常采用形容词或动词来描述接口的动作行为。下列是Oracle Java中一些标准库的接口使用形容词命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface Closeable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface Cloneable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface Runnable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface Comparable&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface CompletionService&lt;V&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface Iterable&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface EventListener&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring Framework标准库中，通常采用名词+动词/形容词的组合方式来命名接口，下列是Spring Framework中一些接口命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface AfterAdvice&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface TargetClassAware&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface ApplicationContextAware&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface MessageSourceResolvable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-抽象类命名规范"><a href="#2-2-抽象类命名规范" class="headerlink" title="2.2 抽象类命名规范"></a>2.2 抽象类命名规范</h5><p>抽象类(Abstract Class)是一种特殊的类，其命名与普通类的命名规范相当。一般地，为了将抽象类与普通类和接口做出区别，提高抽象类的可读性，在命名抽象类时，会以“Abstract”/“Base”作为类命的前缀。下面是编程中一些常规的命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractRepository&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbstractController&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public abstract class BaseDao&lt;T,ID&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbstractCommonService&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是Spring Framework中常见的抽象类示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAspectJAdvice&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbstractSingletonProxyFactoryBean&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbstractBeanFactoryPointcutAdvisor&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbstractCachingConfiguration&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbstractContextLoaderInitializer&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-异常类命名规范"><a href="#2-3-异常类命名规范" class="headerlink" title="2.3 异常类命名规范"></a>2.3 异常类命名规范</h5><p>异常类(Exception Class)也是类的一种，但与普通类命名不同的是，异常类在命名时需要使用“Exception”作为其后缀。下面是常见的异常类命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class FileNotFoundException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class UserAlreadyExistException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class TransactionException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class ClassNotFoundException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class IllegalArgumentException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class IndexOutOfBoundsException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在Java中还有另外一类异常类，它们属于系统异常，这一类异常类的命名使用“Error”作为其后缀，以区分Exception(编码，环境，操作等异常)。下面是系统异常(非检查异常)的命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class VirtualMachineError&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class StackOverflowError&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class OutOfMemoryError&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class IllegalAccessError&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class NoClassDefFoundError&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class NoSuchFieldError&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class NoSuchMethodError&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-方法命名规范"><a href="#3-方法命名规范" class="headerlink" title="3.方法命名规范"></a>3.方法命名规范</h4><p>方法(Method)命名时,其首字母应该小写，如果方法签名由多个单词组成，则从第二个单词起，使用驼峰命名法进行书写。一般地，在对方法进行命名时，通常采用动词/动词+名词的组合，下面是方法命名的一些常见示例。</p><h5 id="3-1-表述获取"><a href="#3-1-表述获取" class="headerlink" title="3.1 表述获取"></a>3.1 表述获取</h5><p>如果一个方法用于获取某个值，通常使用“get”作为其前缀，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public String getUserName()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public List&lt;Integer&gt; getUserIds()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public User getOne()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-表述查询"><a href="#3-2-表述查询" class="headerlink" title="3.2 表述查询"></a>3.2 表述查询</h5><p>如果方法需要通过查询或筛选的方式获取某个数据，通常使用“find”/“query”作为其前缀，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;User&gt; findOne(Integer id)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public List&lt;Integer&gt; findAll()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public List&lt;String&gt; queryOrders()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-表述条件"><a href="#3-3-表述条件" class="headerlink" title="3.3 表述条件"></a>3.3 表述条件</h5><p>如果一个方法需要一些条件参数，则可以使用“by”/“with”等字符作为方法名中条件的连接符，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public User findByUsername(String username)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public List&lt;Integer&gt; getUserIdsWithState(boolean state)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public List&lt;User&gt; findAllByUsernameOrderByIdDesc(String username)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-4-表述设置"><a href="#3-4-表述设置" class="headerlink" title="3.4 表述设置"></a>3.4 表述设置</h5><p>如果一个方法是要设置，插入，修改，删除等操作，应该将对应的动词(set,insert,update,delete)作为其名词的前缀，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setName(String name)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public User insert(User user)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public void update(User user)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public void clearAll()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-其他规范"><a href="#3-5-其他规范" class="headerlink" title="3.5 其他规范"></a>3.5 其他规范</h5><p>如果一个方法用于获取某组数据的长度或数量，则该方法应该使用length或size命名；如果方法的返回值为布尔类型(Boolean)，则该方法应该使用“is”或”has”作为前缀；</p><p>如果方法用于将一种类型的数据转换为另一种数据数类型，则可以使用“to”作为前缀。下面是综合示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public long length()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public int size()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public boolean isOpen()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public boolean isNotEmpty()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public boolean hasLength()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public Set&lt;Integer&gt; mapToSet(Map map)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public UserDto convertTo(User user)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public String toString(Object obj)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-变量命名规范"><a href="#4-变量命名规范" class="headerlink" title="4.变量命名规范"></a>4.变量命名规范</h4><p>变量(Variable)命名包括参数名称，成员变量和局部变量。变量命名通常以小写字母开头，如果变量名由多个单词构成，则从第二个单词起首字母需要大写，在变量命名过程中，不建议使用“_”作为前缀或者单词之间的分割符号。下面是一些常见的变量命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private String nickName;</span><br><span class="line">private String mobileNumber;</span><br><span class="line">private Long id;</span><br><span class="line">private String username;</span><br><span class="line">private Long orderId;</span><br><span class="line">private Long orderItemId;</span><br></pre></td></tr></table></figure><h4 id="5-常量命名规范"><a href="#5-常量命名规范" class="headerlink" title="5.常量命名规范"></a>5.常量命名规范</h4><p>一般地，常量名称采用全部大写的英文单词书写，如果常量名称由多个单词组成，则单词之间统一使用“_”进行分割，下面是常量命名示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static final String LOGIN_USER_SESSION_KEY = &quot;current_login_user&quot;;</span><br><span class="line">public static final int MAX_AGE_VALUE = 120;</span><br><span class="line">public static final int DEFAULT_PAGE_NO = 1;</span><br><span class="line">public static final long MAX_PAGE_SIZE = 1000;</span><br><span class="line">public static final boolean HAS_LICENSE = false;</span><br><span class="line">public static final boolean IS_CHECKED = false;</span><br></pre></td></tr></table></figure><h4 id="6-枚举命名规范"><a href="#6-枚举命名规范" class="headerlink" title="6. 枚举命名规范"></a>6. 枚举命名规范</h4><p>枚举(Enum)类是一种特殊的类，其命名规范遵循普通类的命名约束条件，首字母大写，采用驼峰命名法；枚举类中定义的值的名称遵循常量的命名规范，且枚举值的名称需要与类名有一定的关联性，下面是枚举的一些示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum Color&#123;</span><br><span class="line">    RED,YELLOW,BLUE,GREEN,WHITE;</span><br><span class="line">&#125;</span><br><span class="line">public enum PhysicalSize&#123;</span><br><span class="line">    TINY,SMALL,MEDIUM,LARGE,HUGE,GIGANTIC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Oracle Java标准库中的一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public enum ElementType&#123;</span><br><span class="line">    TYPE,</span><br><span class="line">    FIELD,</span><br><span class="line">    METHOD,</span><br><span class="line">    PARAMETER,</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    PACKAGE,</span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    TYPE_USE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-其他命名规范"><a href="#7-其他命名规范" class="headerlink" title="7. 其他命名规范"></a>7. 其他命名规范</h4><h5 id="7-1-数组"><a href="#7-1-数组" class="headerlink" title="7.1 数组"></a>7.1 数组</h5><p>在定义数组时，为了便于阅读，尽量保持以下的书写规范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int[] array = new int[10];</span><br><span class="line">int[] idArray =&#123;1,2,3,4,5&#125;;</span><br><span class="line">String[] nameArray = &#123;&quot;First&quot;,&quot;Yellow&quot;,&quot;Big&quot;&#125;</span><br><span class="line"></span><br><span class="line">public List&lt;String&gt; getNameById(Integer[] ids)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public List&lt;String&gt; getNameById(Integer...ids)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-表述复数或者集合"><a href="#7-2-表述复数或者集合" class="headerlink" title="7.2 表述复数或者集合"></a>7.2 表述复数或者集合</h5><p>如果一个变量用于描述多个数据时，尽量使用单词的复数形式进行书写，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Order&gt; orders;</span><br><span class="line">int[] values;</span><br><span class="line">List&lt;Item&gt; items;</span><br></pre></td></tr></table></figure><p>另外，如果表述的是一个Map数据，则应使用“map”作为其后缀，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,User&gt; userMap;</span><br><span class="line">Map&lt;String,List&lt;Object&gt;&gt; listMap;</span><br></pre></td></tr></table></figure><h5 id="7-3-泛型类"><a href="#7-3-泛型类" class="headerlink" title="7.3 泛型类"></a>7.3 泛型类</h5><p>在书写泛型类时，通常做以下的约定：</p><ul><li>E表示Element，通常用在集合中；</li><li>ID用于表示对象的唯一标识符类型</li><li>T表示Type(类型)，通常指代类；</li><li>K表示Key(键),通常用于Map中；</li><li>V表示Value(值),通常用于Map中，与K结对出现；</li><li>N表示Number,通常用于表示数值类型；</li><li>？表示不确定的Java类型；</li><li>X用于表示异常；</li><li>U,S表示任意的类型。</li></ul><p>下面时泛型类的书写示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class ThreadLocal&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public interface Functor&lt;T,X extends Throwable&gt;&#123;</span><br><span class="line">    T val() throws X;</span><br><span class="line">&#125;</span><br><span class="line">public class Container&lt;K,V&gt;&#123;</span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line">    Container(K key,V value)&#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface BaseRepository&lt;T,ID&gt;&#123;</span><br><span class="line">    T findById(ID id);</span><br><span class="line"></span><br><span class="line">    void update(T t);</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; findByIds(ID...ids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; methodName(Class&lt;T&gt; clz)&#123;</span><br><span class="line">    List&lt;T&gt; dataList = getByClz(clz);</span><br><span class="line">    return dataList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-4-接口实现类"><a href="#7-4-接口实现类" class="headerlink" title="7.4 接口实现类"></a>7.4 接口实现类</h5><p>为了便于阅读，在通常情况下，建议接口实现类使用“Impl作为后缀”，不建议使用大写的“I”作为接口前缀，下面是接口和接口实现类的书写示例。</p><p>推荐写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface OrderService&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class OrderServiceImpl implements OrderService&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不建议的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IOrderService&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">public class OrderService implements IOrderService&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-5-测试类和测试方法"><a href="#7-5-测试类和测试方法" class="headerlink" title="7.5 测试类和测试方法"></a>7.5 测试类和测试方法</h5><p>在项目中，测试类采用被测试业务模块名/被测试接口/被测试类+“Test”的方法进行书写，测试类中的测试函数采用“test”+用例操作_状态的组合方式进行书写，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceTest&#123;</span><br><span class="line"></span><br><span class="line">    public void testFindByUsernameAndPassword()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testUsernameExist_notExist()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testDeleteById_isOk()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-扩展：速记-Java-开发中的各种O"><a href="#8-扩展：速记-Java-开发中的各种O" class="headerlink" title="8.扩展：速记 Java 开发中的各种O"></a>8.扩展：速记 Java 开发中的各种O</h4><p>最后，通过一张表和图快速对Java中的<code>BO</code>,<code>DTO</code>,<code>DAO</code>,<code>PO</code>,<code>POJO</code>,<code>VO</code>之间的含义，区别以及联系进行梳理。</p><table><thead><tr><th>名称</th><th>使用范围</th><th>解释说明</th></tr></thead><tbody><tr><td>BO</td><td>用于Service,Manager,Business等业务相关类的命名</td><td>Business Object业务处理对象，主要作用是把业务逻辑封装成一个对象。</td></tr><tr><td>DTO</td><td>经过加工后的PO对象，其内部属性可能增加或减少</td><td>Data Transfer Object数据传输对象，主要用于远程调用等需要大量传输数据的地方，例如，可以将一个或多个PO类的部分或全部属性封装为DTO进行传输</td></tr><tr><td>DAO</td><td>用于对数据库进行读写操作的类进行命名</td><td>Data Access Object数据访问对象，主要用来封装对数据库的访问，通过DAO可以将POJO持久化为PO，也可以利用PO封装出VO和DTO</td></tr><tr><td>PO</td><td>Bean,Entity等类的命名</td><td>Persistant Object持久化对象，数据库表中的数据在Java对象中的映射状态，可以简单的理解为一个PO对象即为数据库表中的一条记录</td></tr><tr><td>POJO</td><td>POJO是DO/DTO/BO/VO的统称</td><td>Plain Ordinary Java Object 简单Java对象，它是一个简单的普通Java对象，禁止将类命名为XxxxPOJO</td></tr><tr><td>VO</td><td>通常是视图控制层和模板引擎之间传递的数据对象</td><td>Value Object 值对象，主要用于视图层，视图控制器将视图层所需的属性封装成一个对象，然后用一个VO对象在视图控制器和视图之间进行数据传输。</td></tr><tr><td>AO</td><td>应用层对象</td><td>Application Object，在Web层与Service层之间抽象的复用对象模型，很少用。</td></tr></tbody></table><p>下面将通过一张图来理解上述几种O之间相互转换的关系：</p><p><img src="/2021/03/31/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么阿里巴巴禁止使用BigDecimal的equals方法做等值比较</title>
      <link href="/2021/03/31/CoreJava/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8BigDecimal%E7%9A%84equals%E6%96%B9%E6%B3%95%E5%81%9A%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83/"/>
      <url>/2021/03/31/CoreJava/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8BigDecimal%E7%9A%84equals%E6%96%B9%E6%B3%95%E5%81%9A%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>BigDecimal，相信对于很多人来说都不陌生，很多人都知道他的用法，这是一种 java.math 包中提供的一种可以用来进行精确运算的类型。</p><p>很多人都知道，在进行金额表示、金额计算等场景，不能使用 double、float 等类型；而是要使用对精度支持的更好的 BigDecimal。</p><p>所以，很多支付、电商、金融等业务中，BigDecimal 的使用非常频繁。而且不得不说这是一个非常好用的类，其内部自带了很多方法，如加，减，乘，除等运算方法都是可以直接调用的。</p><p>除了需要用 BigDecimal 表示数字和进行数字运算以外，代码中还经常需要对于数字进行相等判断。</p><p>关于 BigDecimal 等值判断的这个知识点，在最新版的《阿里巴巴 Java 开发手册》中也有说明：</p><p><img src="/2021/03/31/CoreJava/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8BigDecimal%E7%9A%84equals%E6%96%B9%E6%B3%95%E5%81%9A%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83/01.jpeg" alt="Image png"></p><p>那么，为什么会有这样的要求呢？背后的思考是什么呢？</p><p>其实，我在之前的 CodeReview 中，看到过以下这样的低级错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(bigDecimal == bigDecimal1)&#123;</span><br><span class="line">    // 两个数相等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种错误，相信聪明的读者一眼就可以看出问题，<strong>因为 BigDecimal 是对象，所以不能用</strong> == <strong>来判断两个数字的值是否相等。</strong></p><p>以上这种问题，在有一定的经验之后，还是可以避免的，但是聪明的读者，看一下以下这行代码，你觉得他有问题吗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(bigDecimal.equals(bigDecimal1))&#123;</span><br><span class="line">    // 两个数相等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明确的告诉大家，以上这种写法，可能得到的结果和你预想的不一样！</p><p>先来做个实验，运行以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bigDecimal = new BigDecimal(1);</span><br><span class="line">BigDecimal bigDecimal1 = new BigDecimal(1);</span><br><span class="line"></span><br><span class="line">System.out.println(bigDecimal.equals(bigDecimal1));</span><br><span class="line">BigDecimal bigDecimal2 = new BigDecimal(1);</span><br><span class="line">BigDecimal bigDecimal3 = new BigDecimal(1.0);</span><br><span class="line">System.out.println(bigDecimal2.equals(bigDecimal3));</span><br><span class="line">BigDecimal bigDecimal4 = new BigDecimal(&quot;1&quot;);</span><br><span class="line">BigDecimal bigDecimal5 = new BigDecimal(&quot;1.0&quot;);</span><br><span class="line">System.out.println(bigDecimal4.equals(bigDecimal5));</span><br></pre></td></tr></table></figure><p>以上代码，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h1 id="BigDecimal-的-equals-原理"><a href="#BigDecimal-的-equals-原理" class="headerlink" title="BigDecimal 的 equals 原理"></a>BigDecimal 的 equals 原理</h1><p>通过以上代码示例，我们发现，在使用 BigDecimal 的 equals 方法对 1 和 1.0 进行比较的时候，有的时候是 true（当使用 int、double 定义 BigDecimal 时），有的时候是 false（当使用 String 定义 BigDecimal 时）。</p><p>那么，为什么会出现这样的情况呢，我们先来看下 BigDecimal 的 equals 方法。</p><p>在 BigDecimal 的 JavaDoc 中其实已经解释了其中原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compares this BigDecimal with the specified Object for equality.  Unlike compareTo, this method considers two BigDecimal objects equal only if they are equal in value and scale (thus 2.0 is not equal to 2.00 when compared by  this method)</span><br></pre></td></tr></table></figure><p>大概意思就是：</p><p><strong>equals 方法和 compareTo 并不一样，equals 方法会比较两部分内容，分别是值（value）和标度（scale）</strong></p><p>对应的代码如下：</p><p><img src="/2021/03/31/CoreJava/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8BigDecimal%E7%9A%84equals%E6%96%B9%E6%B3%95%E5%81%9A%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83/02.jpeg" alt="Image png"></p><p>所以，我们以上代码定义出来的两个 BigDecimal 对象（bigDecimal4 和 bigDecimal5）的标度是不一样的，所以使用 equals 比较的结果就是 false 了。尝试着对代码进行 debug，在 debug 的过程中我们也可以看到 bigDecimal4 的标度是 0，而 bigDecimal5 的标度是 1。</p><p><img src="/2021/03/31/CoreJava/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8BigDecimal%E7%9A%84equals%E6%96%B9%E6%B3%95%E5%81%9A%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83/03.jpeg" alt="Image png"></p><p>到这里，我们大概解释清楚了，之所以 equals 比较 bigDecimal4 和 bigDecimal5 的结果是 false，是因为标度不同。</p><p>那么，为什么标度不同呢？为什么 bigDecimal2 和 bigDecimal3 的标度是一样的（当使用 int、double 定义 BigDecimal 时），而 bigDecimal4 和 bigDecimal5 却不一样（当使用 String 定义 BigDecimal 时）呢？</p><h1 id="为什么标度不同"><a href="#为什么标度不同" class="headerlink" title="为什么标度不同"></a>为什么标度不同</h1><p>首先，BigDecimal 一共有以下 4 个构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal(int)</span><br><span class="line"></span><br><span class="line">BigDecimal(double) </span><br><span class="line"></span><br><span class="line">BigDecimal(long) </span><br><span class="line"></span><br><span class="line">BigDecimal(String)</span><br></pre></td></tr></table></figure><p>以上四个方法，创建出来的的 BigDecimal 的标度是不同的。</p><h2 id="BigDecimal-long-和-BigDecimal-int"><a href="#BigDecimal-long-和-BigDecimal-int" class="headerlink" title="BigDecimal (long) 和 BigDecimal (int)"></a>BigDecimal (long) 和 BigDecimal (int)</h2><p>首先，最简单的就是 <strong>BigDecimal (long) 和 BigDecimal (int)，因为是整数，所以标度就是 0</strong> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal(int val) &#123;</span><br><span class="line">    this.intCompact = val;</span><br><span class="line">    this.scale = 0;</span><br><span class="line">    this.intVal = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public BigDecimal(long val) &#123;</span><br><span class="line">    this.intCompact = val;</span><br><span class="line">    this.intVal = (val == INFLATED) ? INFLATED_BIGINT : null;</span><br><span class="line">    this.scale = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigDecimal-double"><a href="#BigDecimal-double" class="headerlink" title="BigDecimal(double)"></a>BigDecimal(double)</h2><p>而对于 BigDecimal (double) ，<strong>当我们使用 new BigDecimal (0.1) 创建一个 BigDecimal 的时候，其实创建出来的值并不是正好等于 0.1 的，而是 0.1000000000000000055511151231257827021181583404541015625 。</strong></p><p><strong>这是因为 doule 自身表示的只是一个近似值。</strong></p><p>那么，无论我们使用 new BigDecimal (0.1) 还是 new BigDecimal (0.10) 定义，他的近似值都是 0.1000000000000000055511151231257827021181583404541015625 这个，那么他的标度就是这个数字的位数，即 55。</p><p><img src="/2021/03/31/CoreJava/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8BigDecimal%E7%9A%84equals%E6%96%B9%E6%B3%95%E5%81%9A%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83/04.jpeg" alt="Image png"></p><p>其他的浮点数也同样的道理。对于 new BigDecimal (1.0) 这样的形式来说，因为他本质上也是个整数，所以他创建出来的数字的标度就是 0。</p><p>所以，因为 BigDecimal (1.0) 和 BigDecimal (1.00) 的标度是一样的；</p><p>所以在使用 equals 方法比较的时候，得到的结果就是 true。</p><h2 id="BigDecimal-String"><a href="#BigDecimal-String" class="headerlink" title="BigDecimal(String)"></a>BigDecimal(String)</h2><p>而对于 BigDecimal (String) ，<strong>当我们使用 new BigDecimal (“0.1”) 创建一个 BigDecimal 的时候，其实创建出来的值正好就是等于 0.1 的。那么他的标度也就是 1。</strong></p><p>如果使用 new BigDecimal (“0.10000”)，那么创建出来的数就是 0.10000，标度也就是 5。</p><p>所以，因为 BigDecimal (“1.0”) 和 BigDecimal (“1.00”) 的标度不一样，所以在使用 equals 方法比较的时候，得到的结果就是 false。</p><h1 id="如何比较-BigDecimal"><a href="#如何比较-BigDecimal" class="headerlink" title="如何比较 BigDecimal"></a>如何比较 BigDecimal</h1><p>前面，我们解释了 BigDecimal 的 equals 方法，其实不只是会比较数字的值，还会对其标度进行比较。</p><p>所以，当我们使用 equals 方法判断判断两个数是否相等的时候，是极其严格的。</p><p>那么，如果我们只想判断两个 BigDecimal 的值是否相等，那么该如何判断呢？</p><p><strong>BigDecimal 中提供了 compareTo 方法，这个方法就可以只比较两个数字的值，如果两个数相等，则返回 0。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bigDecimal4 = new BigDecimal(&quot;1&quot;);</span><br><span class="line">BigDecimal bigDecimal5 = new BigDecimal(&quot;1.0000&quot;);</span><br><span class="line">System.out.println(bigDecimal4.compareTo(bigDecimal5));</span><br><span class="line">以上代码，输出结果：0</span><br></pre></td></tr></table></figure><p>其源码如下：</p><p><img src="/2021/03/31/CoreJava/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8BigDecimal%E7%9A%84equals%E6%96%B9%E6%B3%95%E5%81%9A%E7%AD%89%E5%80%BC%E6%AF%94%E8%BE%83/05.jpeg" alt="Image png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BigDecimal 是一个非常好用的表示高精度数字的类，其中提供了很多丰富的方法。</p><p>但是，他的 equals 方法使用的时候需要谨慎，因为他在比较的时候，不仅比较两个数字的值，还会比较他们的标度，只要这两个因素有一个是不相等的，那么结果也是 false</p><p>如果读者想要对两个 BigDecimal 的数值进行比较的话，可以使用 compareTo 方法。</p>]]></content>
      
      
      <categories>
          
          <category> CoreJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoreJava </tag>
            
            <tag> 数据精度问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID生成器组件</title>
      <link href="/2021/03/31/Microservices&amp;DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/"/>
      <url>/2021/03/31/Microservices&amp;DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="研发背景"><a href="#研发背景" class="headerlink" title="研发背景"></a>研发背景</h4><p>在分布式服务中，各种复杂的业务场景需要有一个用于做唯一标识的id，例如订单业务，支付流水，聊天通信等业务场景。尤其是在分库分表场景中，分布式id生成器的使用频率更高。因此分布式id组件的设计应该要能支持以下几个特性：</p><p><strong>1.全局唯一特性</strong></p><p>这个点比较好理解，这里就不做过多的解释。</p><p><strong>2.组件递增特性</strong></p><p>可以是每个id都具有递增的特性也可以是支持区间段内具备递增的特性。</p><p><strong>3.安全性</strong></p><p>有些重要的id如果无意中暴露在了外网环境中，如果没有做过安全防范其实是一件非常危险的事情。例如说订单的id如果只是更具日期加订单数目的格式生成，例如说：2020111100001表示2020年11月11日的第一笔订单，那么如果竞对获取到了</p><p>2020111100999这个id，再根据订单的生成时间则大概可以推断出该公司某日生成的订单数目的大致量级。</p><p><strong>4.高qps</strong></p><p>分布式id生成组件在使用过程中主要是qps偏高，因此在设计起初应该要能支持较高的qps查询，同时对于网络的延迟特性也需要尽可能降低。</p><p><strong>5.高可用</strong></p><p>由于分布式id生成器是一个需要支持多个服务调用方共同使用的公共服务，一旦出现崩溃后果不堪设想，可能会导致大面积的业务线崩塌，所以在高可用方面需要考虑得尤其重要。</p><h4 id="业界常见的分布式id生成方案比对"><a href="#业界常见的分布式id生成方案比对" class="headerlink" title="业界常见的分布式id生成方案比对"></a>业界常见的分布式id生成方案比对</h4><h5 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h5><p>java程序中实现uuid的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String result = UUID.randomUUID().toString();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><p>生成的格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b0b2197d-bc8c-4fab-ad73-2b54e11b0869</span><br></pre></td></tr></table></figure><p>uuid的格式其实是会被 - 符号划分为五个模块，主要是分为了8-4-4-4-12个字符拼接而成的一段字符串。但是这种字符串的格式对于互联网公司中主推的MySQL数据库并不友好。</p><p>尤其是当使用生成的id作为索引的时候，uuid长度过长，大数据量的时候会导致b+树的叶子结点裂变频率加大，而且在进行索引比对的时候需要进行逐个字符比对，性能损耗也较高，应该抛弃该方案。uuid的主要组成由以下几个部位：</p><ul><li>当前日期和时间</li><li>随机数字</li><li>机器的MAC地址（能够保证全球范围内机器的唯一特性）</li></ul><p><a href="https://wangqi-jeffrey.github.io/2020/12/23/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/">扩展阅读</a></p><h5 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h5><p>SnowFlake是Twitter公司采用的一种算法，目的是在分布式系统中产生全局唯一且趋势递增的ID。</p><p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/distributed_id_generate.png" alt="Image zoo"></p><p>稍微解释一些雪花算法的含义：</p><p>第一位通常是0，没有特殊使用含义，因为1通常表示为补码。</p><p>中间的41位是用于存储时间，41位的长度足够容纳69年左右的时长。</p><p>10bit用于标示机器自身的id，从而表示不通机器自身id的不同。</p><p>最后12位bit用于表示某一毫秒内的序列号，12位（bit）可以表示的最大正整数是4096-1=4095，所以也就是说一毫秒内可以同时生成4095个id。</p><p>时间戳位置和序列号位置还不能随意调整，应为要保证逐渐递增的特性。</p><p><strong>好处</strong></p><p>能够保证递增的特性，id具有明确的含义，易懂。</p><p><strong>不足点</strong></p><p>但是对于机器自身的系统时间有所依赖，一旦机器的系统时间发生了变化，在高并发环境下就有可能会有重复id生成的风险。</p><p>有些业务场景希望在id中加入特殊的业务规则名称前缀</p><p>例如短信的id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sms_108678123</span><br></pre></td></tr></table></figure><p>奖券的id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coupon_12908123</span><br></pre></td></tr></table></figure><p>需要基于这种算法进行改造，实现支持id注入“基因”的这一特性。</p><h4 id="mongodb的主键id设计思路"><a href="#mongodb的主键id设计思路" class="headerlink" title="mongodb的主键id设计思路"></a>mongodb的主键id设计思路</h4><p>其实在mongodb里面也有使用到往主键id中注入一些“基因”要素点的这类思路：</p><p>mongodb里面没有自增的id。</p><p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/mongodb_id_generate.png" alt="Image zoo"></p><p>_id是唯一标识的key，value通常我们会设置为objectid对象。</p><p>objectid里面包含了时间戳，宿主机的ip，进程号码，自增号</p><p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/mongodb_id_detail.png" alt="Image zoo"></p><h4 id="自研主要设计思路"><a href="#自研主要设计思路" class="headerlink" title="自研主要设计思路"></a>自研主要设计思路</h4><p>MySQL配置id生成规则，拉取到本地缓存中形成一段本地id，从而降低对于db的访问。</p><p>支持集群配置id生成器，能够支持高qps访问和较好的扩容性。</p><p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/id_generate_customize.png" alt="Image zoo"></p><p>配置表如下方所示：</p><p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/id_generate_customize_config.png" alt="Image zoo"></p><p>建表sql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t_id_builder_config` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `des` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &apos;描述&apos;,</span><br><span class="line">  `init_num` bigint(13) DEFAULT NULL COMMENT &apos;id起步值&apos;,</span><br><span class="line">  `current_threshold` bigint(16) DEFAULT NULL COMMENT &apos;当前id所在阶段的阈值&apos;,</span><br><span class="line">  `step` int(8) DEFAULT NULL COMMENT &apos;id递增区间&apos;,</span><br><span class="line">  `biz_code` varchar(60) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &apos;业务前缀码，如果没有则返回时不携带&apos;,</span><br><span class="line">  `version` int(11) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;乐观锁版本号&apos;,</span><br><span class="line">  `is_seq` smallint(2) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;id连续递增，0 是  1 不是&apos;,</span><br><span class="line">  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>几个核心设计点：</p><p><strong>当同时有多个请求访问mysql获取id配置的时候该如何防止并发问题？</strong></p><p>这里我采用了for update的方式加行锁进行读取，同时对于行信息进行更新的时候加入了version版本号信息字段防止更新重复的情况。</p><p>假设说更新失败，也会有cas的方式进行重试，重试超过一定次数之后直接中断。</p><p><strong>为何不引入redis作为分布式锁来防止并发修改数据库操作？</strong></p><p>不希望将该组件变得过于繁杂，减少系统对于第三方的依赖性</p><p><strong>假设本地id还没使用完，结果当前服务器宕机了，该如何预防？</strong></p><p>每次服务启动都需要更新表的配置，拉去最新的一批id集合到本地，这样就不会出现和之前id冲突的问题了。</p><p><strong>本地id集合中如何判断id是否已经使用过？</strong></p><p>如果是连续递增型的id，这一步可以忽略，因为本地id每次获取的时候都会比上一个id要大。但是如果是拉取了一段区间的id到本地之后进行随机返回就需要加入bitset作为过滤器了。对于已经使用过的id，则对应bit置为1。如果随机返回的区间id多次都已经被占用了，则超过一定频率之后需要重新拉取id到本地。</p><p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/id_generate_customize_bitset.png" alt="Image zoo"></p><p><strong>不通机器的状态表示码该如何设置？</strong></p><p>可以通过启动脚本中配置相关参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DidBuilder.index=1001</span><br></pre></td></tr></table></figure><p>进行配置，然后通过System.getProperty(“idBuilder.index”)的方式来获取.</p><p><strong>核心代码思路：</strong></p><p><strong>接口设计：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface IdBuilderService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据本地步长度来生成唯一id(区间性递增)</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Long unionId(int code);</span><br><span class="line">    /**</span><br><span class="line">     * 对于unionId的算法进行优化(连续性递增)</span><br><span class="line">     *</span><br><span class="line">     * @param code</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Long unionSeqId(int code);</span><br><span class="line">    /**</span><br><span class="line">     * 生成包含业务前缀的自增id(区间性递增)</span><br><span class="line">     *</span><br><span class="line">     * @param code</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String unionIdStr(int code);</span><br><span class="line">    /**</span><br><span class="line">     * 生成包含业务前缀的自增id(连续性递增)</span><br><span class="line">     *</span><br><span class="line">     * @param code</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String unionSeqIdStr(int code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">public class IdBuilderServiceImpl implements IdBuilderService, InitializingBean &#123;</span><br><span class="line">    private static ConcurrentHashMap&lt;Integer, BitSet&gt; bitSetMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    private static Map&lt;Integer, IdBuilderPO&gt; idBuilderNotSeqMap;</span><br><span class="line">    private static Map&lt;Integer, IdBuilderPO&gt; idBuilderSeqMap;</span><br><span class="line">    private static Map&lt;Integer, LocalSeqId&gt; localSeqMap;</span><br><span class="line">    private static Map&lt;Integer, Boolean&gt; newBuilderMap;</span><br><span class="line">    private final static Object monitor = new Object();</span><br><span class="line">    @Resource</span><br><span class="line">    private IdBuilderMapper idBuilderMapper;</span><br><span class="line">  </span><br><span class="line">    private int idBuilderIndex;</span><br><span class="line">    @Override</span><br><span class="line">    public Long unionId(int code) &#123;</span><br><span class="line">        //考虑到锁升级问题，在高并发场景下使用synchronized要比cas更佳</span><br><span class="line">        synchronized (monitor) &#123;</span><br><span class="line">            IdBuilderPO idBuilderPO = idBuilderNotSeqMap.get(code);</span><br><span class="line">            if (idBuilderPO == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean isNew = newBuilderMap.get(code);</span><br><span class="line">            if (isNew) &#123;</span><br><span class="line">                //预防出现id生成器网络中断问题</span><br><span class="line">                IdBuilderPO newIdBuilderPO = this.refreshIdBuilderConfig(idBuilderPO);</span><br><span class="line">                if (newIdBuilderPO == null) &#123;</span><br><span class="line">                    log.error(&quot;[unionId] refreshIdBuilderConfig出现异常&quot;);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                idBuilderPO.setCurrentThreshold(newIdBuilderPO.getCurrentThreshold());</span><br><span class="line">                newBuilderMap.put(code, false);</span><br><span class="line">            &#125;</span><br><span class="line">            long initNum = idBuilderPO.getCurrentThreshold();</span><br><span class="line">            int step = idBuilderPO.getStep();</span><br><span class="line">            int randomIndex = RandomUtils.nextInt((int) initNum, (int) initNum + step);</span><br><span class="line">            BitSet bitSet = bitSetMap.get(code);</span><br><span class="line">            if (bitSet == null) &#123;</span><br><span class="line">                bitSet = new BitSet();</span><br><span class="line">                bitSetMap.put(code, bitSet);</span><br><span class="line">            &#125;</span><br><span class="line">            Long id;</span><br><span class="line">            int countTime = 0;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                boolean indexExist = bitSet.get(randomIndex);</span><br><span class="line">                countTime++;</span><br><span class="line">                if (!indexExist) &#123;</span><br><span class="line">                    bitSet.set(randomIndex);</span><br><span class="line">                    id = Long.valueOf(randomIndex);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果重试次数大于了空间的0.75则需要重新获取新的id区间 测试之后得出 循环一千万次随机函数，16gb内存条件下，大约耗时在124ms左右</span><br><span class="line">                if (countTime &gt;= step * 0.75) &#123;</span><br><span class="line">                    //扩容需要修改表配置</span><br><span class="line">                    IdBuilderPO newIdBuilderPO = this.updateIdBuilderConfig(idBuilderPO);</span><br><span class="line">                    if (newIdBuilderPO == null) &#123;</span><br><span class="line">                        log.error(&quot;重试超过100次没有更新自增id配置成功&quot;);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    initNum = newIdBuilderPO.getCurrentThreshold();</span><br><span class="line">                    step = newIdBuilderPO.getStep();</span><br><span class="line">                    idBuilderPO.setCurrentThreshold(initNum);</span><br><span class="line">                    bitSet.clear();</span><br><span class="line">                    log.info(&quot;[unionId] 扩容IdBuilder，new idBuilderPO is &#123;&#125;&quot;,idBuilderPO);</span><br><span class="line">                &#125;</span><br><span class="line">                randomIndex = RandomUtils.nextInt((int) initNum, (int) initNum + step);</span><br><span class="line">            &#125;</span><br><span class="line">            return id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Long unionSeqId(int code) &#123;</span><br><span class="line">        synchronized (monitor) &#123;</span><br><span class="line">            LocalSeqId localSeqId = localSeqMap.get(code);</span><br><span class="line">            IdBuilderPO idBuilderPO = idBuilderSeqMap.get(code);</span><br><span class="line">            if (idBuilderPO == null || localSeqId == null) &#123;</span><br><span class="line">                log.error(&quot;[unionSeqId] code 参数有误，code is &#123;&#125;&quot;, code);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean isNew = newBuilderMap.get(code);</span><br><span class="line">            long result = localSeqId.getCurrentId();</span><br><span class="line">            localSeqId.setCurrentId(result + 1);</span><br><span class="line">            if (isNew) &#123;</span><br><span class="line">                //预防出现id生成器网络中断问题</span><br><span class="line">                IdBuilderPO updateIdBuilderPO = this.refreshIdBuilderConfig(idBuilderPO);</span><br><span class="line">                if (updateIdBuilderPO == null) &#123;</span><br><span class="line">                    log.error(&quot;[unionSeqId] refreshIdBuilderConfig出现异常&quot;);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                newBuilderMap.put(code, false);</span><br><span class="line">                localSeqId.setCurrentId(updateIdBuilderPO.getCurrentThreshold());</span><br><span class="line">                localSeqId.setNextUpdateId(updateIdBuilderPO.getCurrentThreshold() + updateIdBuilderPO.getStep());</span><br><span class="line">            &#125;</span><br><span class="line">            //需要更新本地步长</span><br><span class="line">            if (localSeqId.getCurrentId() &gt;= localSeqId.getNextUpdateId()) &#123;</span><br><span class="line">                IdBuilderPO newIdBuilderPO = this.updateIdBuilderConfig(idBuilderPO);</span><br><span class="line">                if (newIdBuilderPO == null) &#123;</span><br><span class="line">                    log.error(&quot;[unionSeqId] updateIdBuilderConfig出现异常&quot;);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                idBuilderPO.setCurrentThreshold(newIdBuilderPO.getCurrentThreshold());</span><br><span class="line">                localSeqId.setCurrentId(newIdBuilderPO.getCurrentThreshold());</span><br><span class="line">                localSeqId.setNextUpdateId(newIdBuilderPO.getCurrentThreshold() + newIdBuilderPO.getStep());</span><br><span class="line">                log.info(&quot;[unionSeqId] 扩容IdBuilder，new localSeqId is &#123;&#125;&quot;,localSeqId);</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 刷新id生成器的配置</span><br><span class="line">     *</span><br><span class="line">     * @param idBuilderPO</span><br><span class="line">     */</span><br><span class="line">    private IdBuilderPO refreshIdBuilderConfig(IdBuilderPO idBuilderPO) &#123;</span><br><span class="line">        IdBuilderPO updateResult = this.updateIdBuilderConfig(idBuilderPO);</span><br><span class="line">        if (updateResult == null) &#123;</span><br><span class="line">            log.error(&quot;更新数据库配置出现异常,idBuilderPO is &#123;&#125;&quot;, idBuilderPO);</span><br><span class="line">            throw new RuntimeErrorException(new Error(&quot;更新数据库配置出现异常,idBuilderPO is &quot; + idBuilderPO.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">        return updateResult;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 考虑分布式环境下 多个请求同时更新同一行数据的情况</span><br><span class="line">     *</span><br><span class="line">     * @param idBuilderPO</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private IdBuilderPO updateIdBuilderConfig(IdBuilderPO idBuilderPO) &#123;</span><br><span class="line">        int updateResult = -1;</span><br><span class="line">        //假设重试过程中出现网络异常，那么使用cas的时候必须要考虑退出情况 极限情况下更新100次</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            IdBuilderPO newIdBuilderPO = idBuilderMapper.selectOneForUpdate(idBuilderPO.getId());</span><br><span class="line">            updateResult = idBuilderMapper.updateCurrentThreshold(newIdBuilderPO.getCurrentThreshold() + newIdBuilderPO.getStep(), newIdBuilderPO.getId(), newIdBuilderPO.getVersion());</span><br><span class="line">            if (updateResult &gt; 0) &#123;</span><br><span class="line">                return newIdBuilderPO;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String unionIdStr(int code) &#123;</span><br><span class="line">        long id = this.unionId(code);</span><br><span class="line">        IdBuilderPO idBuilderPO = idBuilderNotSeqMap.get(code);</span><br><span class="line">        return idBuilderPO.getBizCode() + idBuilderIndex + id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String unionSeqIdStr(int code) &#123;</span><br><span class="line">        long id = this.unionSeqId(code);</span><br><span class="line">        IdBuilderPO idBuilderPO = idBuilderSeqMap.get(code);</span><br><span class="line">        return idBuilderPO.getBizCode() + idBuilderIndex + id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        List&lt;IdBuilderPO&gt; idBuilderPOS = idBuilderMapper.selectAll();</span><br><span class="line">        idBuilderNotSeqMap = new ConcurrentHashMap&lt;&gt;(idBuilderPOS.size());</span><br><span class="line">        newBuilderMap = new ConcurrentHashMap&lt;&gt;(idBuilderPOS.size());</span><br><span class="line">        idBuilderSeqMap = new ConcurrentHashMap&lt;&gt;(idBuilderPOS.size());</span><br><span class="line">        localSeqMap = new ConcurrentHashMap&lt;&gt;(0);</span><br><span class="line">        //每次重启到时候，都需要将之前的上一个区间的id全部抛弃，使用新的步长区间</span><br><span class="line">        for (IdBuilderPO idBuilderPO : idBuilderPOS) &#123;</span><br><span class="line">            if (idBuilderPO.getIsSeq() == NEED_SEQ) &#123;</span><br><span class="line">                idBuilderSeqMap.put(idBuilderPO.getId(), idBuilderPO);</span><br><span class="line">                LocalSeqId localSeqId = new LocalSeqId();</span><br><span class="line">                localSeqId.setNextUpdateId(idBuilderPO.getCurrentThreshold() + idBuilderPO.getStep());</span><br><span class="line">                localSeqId.setCurrentId(idBuilderPO.getCurrentThreshold());</span><br><span class="line">                localSeqMap.put(idBuilderPO.getId(), localSeqId);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                idBuilderNotSeqMap.put(idBuilderPO.getId(), idBuilderPO);</span><br><span class="line">            &#125;</span><br><span class="line">            newBuilderMap.put(idBuilderPO.getId(), true);</span><br><span class="line">        &#125;</span><br><span class="line">        this.idBuilderIndex= Integer.parseInt(System.getProperty(&quot;idBuilder.index&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>application.yml配置文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true</span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">  tomcat:</span><br><span class="line">    max-threads: 500</span><br><span class="line">    max-connections: 5000</span><br></pre></td></tr></table></figure><p>注意需要结合实际机器配置nginx的并发线程数目和tomcat的并发访问参数。</p><p><strong>测试环节：</strong></p><p>通过将服务打包部署在机器上边，同时运行多个服务，通过nginx配置负载均衡，请求到不同的机器上边。</p><p>压测的一些相关配置参数：</p><p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E5%99%A8%E7%BB%84%E4%BB%B6/distributed_id_jmeter_test.png" alt="Image zoo"></p><p>当我们需要扩增机器的时候，新加的机器不会对原有发号令机器的id产生影响，可以支持较好的扩容。</p><p><strong>每次拉取的本地id段应该设计在多次较好？</strong></p><p>这里我们先将本地id段简称为segment。</p><p>按照一些过往经验的参考，通常是希望id发号器能够尽量减少对于MySQL的访问次数，同时也需要结合实际部门的运维能力进行把控。</p><p>假设说我们MySQL是采用了1主2从的方式搭建，当某一从节点挂了，切换新的从节点时候需要消耗大约1分钟时长，那么我们的segment至少需要设计为高峰期QPS * 60 * 1 * 4 ，期间考需要额外考虑一些其他因素，例如网络新的节点切换之后带来的一些网络抖动问题等等，这能够保证即使MySQL出现了故障，本地的segment也可以暂时支撑一段时间。</p><p><strong>设计待完善点</strong>：</p><p>该系统的设计不足点在于，当本地id即将用光的时候需要进行数据库查询，因此这个关键点会拖慢系统的响应时长，所以这里可以采用异步更新配置拉取id的思路进行完善。也就是说当本地id列表剩余只有15%可以使用的时候，便可以进行开启一个异步线程去拉取id列表了。</p><p><a href="https://github.com/wangqi-jeffrey/jeffrey-blog-examples/tree/main/Microservices%26DistributedSystem/distributed-id" target="_blank" rel="noopener">代码位置</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务与分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式ID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2021/03/31/Microservices&amp;DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2021/03/31/Microservices&amp;DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul><li>seata</li></ul><p><a href="https://github.com/wangqi-jeffrey/jeffrey-blog-examples/tree/main/distributed-transactional" target="_blank" rel="noopener">代码位置</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务与分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于zookeeper实现分布式配置中心</title>
      <link href="/2021/03/31/Microservices&amp;DistributedSystem/%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>/2021/03/31/Microservices&amp;DistributedSystem/%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/640632-20190606164245241-1700739260.jpg" alt="Image zoo"></p><h3 id="zookeeper介绍"><a href="#zookeeper介绍" class="headerlink" title="zookeeper介绍"></a>zookeeper介绍</h3><p>zookeeper是一个分布式协调框架，主要是解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理、分布式锁等。</p><h3 id="zookeeper使用"><a href="#zookeeper使用" class="headerlink" title="zookeeper使用"></a>zookeeper使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看节点：ls /path</span><br><span class="line">创建节点：create /path data</span><br><span class="line">修改节点：delete /path</span><br><span class="line">获取节点数据：get /path</span><br></pre></td></tr></table></figure><h3 id="zookeeper-C-S连接状态"><a href="#zookeeper-C-S连接状态" class="headerlink" title="zookeeper C/S连接状态"></a>zookeeper C/S连接状态</h3><p>　　1）<strong>KeeperState.Expired</strong>：客户端和服务器在ticktime的时间周期内，是要发送心跳通知的。这是租约协议的一个实现。客户端发送request，告诉服务器其上一个租约时间，服务器收到这个请求后，告诉客户端其下一个租约时间是哪个时间点。当客户端时间戳达到最后一个租约时间，而没有收到服务器发来的任何新租约时间，即认为自己下线（此后客户端会废弃这次连接，并试图重新建立连接）。这个过期状态就是Expired状态</p><p>　　2）<strong>KeeperState.Disconnected</strong>：就像上面那个状态所述，当客户端断开一个连接（可能是租约期满，也可能是客户端主动断开）这是客户端和服务器的连接就是Disconnected状态</p><p>　　3）<strong>KeeperState.SyncConnected</strong>：一旦客户端和服务器的某一个节点建立连接（注意，虽然集群有多个节点，但是客户端一次连接到一个节点就行了），并完成一次version、zxid的同步，这时的客户端和服务器的连接状态就是SyncConnected</p><p>　　4）<strong>KeeperState.AuthFailed</strong>：ookeeper客户端进行连接认证失败时，发生该状态</p><h3 id="zookeeper工作原理"><a href="#zookeeper工作原理" class="headerlink" title="zookeeper工作原理"></a>zookeeper工作原理</h3><p>文件系统+监听机制</p><h4 id="文件系统特点"><a href="#文件系统特点" class="headerlink" title="文件系统特点"></a>文件系统特点</h4><p>同一个目录下文件名称不能重复，同样zookeeper也是这样的，zookeeper中统一叫作znode。znode节点可以包含子znode，也可以同时包含数据。znode只适合存储非常小的数据，不能超过1M，最好都小于1K。</p><h4 id="znode节点类型"><a href="#znode节点类型" class="headerlink" title="znode节点类型"></a>znode节点类型</h4><ul><li><p>临时节点（EPHEMERAL）：客户端关闭zk连接后清除</p></li><li><p>永久节点（persistent）：持久化节点，除非客户端主动删除</p></li><li><p>有编号节点（Persistent_sequential）：自动增加顺序编号的znode持久化节点</p></li><li><p>临时有编号（Ephemral_ sequential）：临时自动编号设置，znode节点编号会自动增加，但是会客户端连接断开而消失。分布式锁用的是这个类型的节点。</p></li></ul><p>　　注：EPHEMERAL 临时类型的节点不能有子节点，对于zk来说，有几个节点数据就会存储几份。</p><h4 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h4><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、节点删除、子目录节 点增加删除）时，zookeeper会通知客户端。</p><p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/640632-20190518235524597-352353804.png" alt="Image zoo"></p><ul><li><p>1、客户端启动时向zookeeper服务器注册信息</p></li><li><p>2、客户端启动同时注册一系列的Watcher类型的监听器到本地的WatchManager中</p></li><li><p>3、zookeeper服务器中节点发生变化后，触发watcher事件后通知给客户端，客户端线程从WatcherManager中取出对应的Watcher对象来执行回调逻辑。</p></li></ul><h4 id="zookeeper监听的事件类型"><a href="#zookeeper监听的事件类型" class="headerlink" title="zookeeper监听的事件类型"></a>zookeeper监听的事件类型</h4><ul><li><p>EventType.NodeCreated：当znode节点被创建时，该事件被触发。</p></li><li><p>EventType.NodeChildrenChanged：当znode节点的直接子节点被创建、被删除、子节点数据发生变更时，该事件被触发。</p></li><li><p>EventType.NodeDataChanged：当znode节点的数据发生变更时，该事件被触发。</p></li><li><p>EventType.NodeDeleted：当znode节点被删除时，该事件被触发。</p></li><li><p>EventType.None：当zookeeper客户端的连接状态发生变更时，即KeeperState.Expired、KeeperState.Disconnected、KeeperState.SyncConnected、KeeperState.AuthFailed状态切换时，描述的事件类型为EventType.None。</p></li></ul><h3 id="zookeeper下server工作状态"><a href="#zookeeper下server工作状态" class="headerlink" title="zookeeper下server工作状态"></a>zookeeper下server工作状态</h3><ul><li><p>LOOKING：当前server不知道leader是谁，正在选举</p></li><li><p>LEADING：当前server即为选举出来的leader</p></li><li><p>FOLLOWING：leader已经选举出来，当前server是follower</p></li></ul><h3 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h3><ul><li><p>ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。</p></li><li><p>ZAB 协议作用：解决分布式数据管理一致性。</p></li><li><p>ZAB 协议定义：ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持 <strong>崩溃恢复 和 消息广播</strong> 协议。<br>基于该协议，Zookeeper 实现了一种 主备模式 的系统架构来保持集群中各个副本之间数据一致性。</p></li></ul><h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><p>​        zookeeper集群采用主从（leader-follower）模式保证服务高可用。leader节点可读可写，follower节点只读，这种模式就需要保证leader节点和follower节点的数据一致性。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果<strong>超过半数成功响应</strong>，则执行 commit 操作（先提交自己，再发送 commit 给所有 Follwer）。</p><p>　　注：上述中有一个概念：两阶段提交过程（分布式系统中数据一致性经常会涉及到的方案）。<strong>follower节点是可以处理写请求的</strong>，会转发给leader节点。leader节点通过消息广播（二阶段提交）同步写操作到follower节点，保证数据一致性。</p><p>　　zookeeper中每个事务都对应一个ZXID（全局的、唯一的、顺序的）。ZXID 是一个 64 位的数字，其中低 32 位可以看作是一个简单的递增的计数器，针对客户端的每一个事务请求，Leader 都会产生一个新的事务 Proposal 并对该计数器进行 + 1 操作。而高 32 位则代表了 Leader 服务器上取出本地日志中最大事务 Proposal 的 ZXID，并从该 ZXID 中解析出对应的 epoch 值，然后再对这个值加一。</p><h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>即如果在消息广播的过程中，leader死掉了，如何保证数据的一致性问题。</p><p>　　假设两种异常情况：<br>　　1、一个事务在 Leader 上提交了，并且过半的 Folower 都响应 Ack 了，但是 Leader 在 Commit 消息发出之前挂了。<br>　　2、假设一个事务在 Leader 提出之后，Leader 挂了。</p><p>　　考虑到上述两种异常情况，Zab 协议崩溃恢复要求满足以下两个要求：<br>　　1）确保已经被 Leader 提交的 Proposal 必须最终被所有的 Follower 服务器提交。<br>　　2）确保丢弃已经被 Leader 提出的但是没有被提交的 Proposal。</p><p>　　崩溃恢复主要包含：leader选举 和 数据恢复。</p><p>　　<strong>leader选举</strong>:</p><p>　　1、要求 可用节点数量 &gt; 总节点数量/2  。注意 是 &gt; , 不是 ≥。</p><p>　    2、新选举出来的 Leader 不能包含未提交的 Proposal（新选举的 Leader 必须都是已经提交了 Proposal 的 Follower 服务器节点） 、新选举的 Leader 节点中含有最大的 zxid（可以避免 Leader 服务器检查 Proposal 的提交和丢弃工作。如果zxid相同，选择server_id【zoo.cfg中的myid】最大的。）</p><p>　　<strong>数据恢复</strong>：</p><p>　　1、上面讲过了ZXID的高 32 位代表了每代 Leader 的唯一性，低 32 代表了每代 Leader 中事务的唯一性。同时，也能让 Follwer 通过高 32 位识别不同的 Leader。简化了数据恢复流程。</p><p>　　2、基于这样的策略：当 Follower 链接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行比对，比对结果要么回滚，要么和 Leader 同步。</p><h3 id="zookeeper集群脑裂"><a href="#zookeeper集群脑裂" class="headerlink" title="zookeeper集群脑裂"></a>zookeeper集群脑裂</h3><p>集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况。</p><h3 id="zookeeper集群节点数（奇数-or-偶数？）"><a href="#zookeeper集群节点数（奇数-or-偶数？）" class="headerlink" title="zookeeper集群节点数（奇数 or 偶数？）"></a>zookeeper集群节点数（奇数 or 偶数？）</h3><p>只要我们清楚集群leader选举的要求（可用节点数量 &gt; 总节点数量/2  。注意 是 &gt; , 不是 ≥），我相信很容易明白奇数节点集群相比偶数节点的集群有更大的优势。</p><p>　　1、发生脑裂（分成2个小集群）的情况下，奇数节点的集群总会有一个小集群满足可用节点数量 &gt; 总节点数量/2，所以zookeeper集群总能选取出leader。</p><p>　　2、在容错能力相同的情况下，奇数集群更节省资源。还是要清楚leader选举的要求哈，举个列子：3个节点的集群，如果集群可以正常工作（即leader选举成功），至少需要2个节点是正常的；4个节点的集群，如果集群可以正常工作（即leader选举成功），至少需要3个节点是正常的。那么3个节点的集群和4个节点的集群都有一个节点宕机的容错能力。很明显，在容错能力相同的情况下，奇数节点的集群更节省资源。</p><h3 id="zookeeper和eureka对比"><a href="#zookeeper和eureka对比" class="headerlink" title="zookeeper和eureka对比"></a>zookeeper和eureka对比</h3><p>在分布式系统领域有个著名的 CAP定理（C- 数据一致性；A-服务可用性；P-服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个）。</p><p>　　zookeeper基于CP，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性；但是它不能保证每次服务请求的可用性（注：也就 是在极端环境下，zookeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果）。至于zookeeper为啥不能保证服务的高可用，大家可以想一下发生脑裂后无法选取leader、选取leader过程中丢弃某些请求。当网络出现故障时，剩余zk集群server会发起投票选举新的leader，但是此过程会持续30~120s，此过程对于高并发来说十分漫长，会导致整个注册服务的瘫痪，这是不可容忍的。 </p><p>　　Eureka基于AP，不会有类似于ZooKeeper的选举leader的过程，采用的是Peer to Peer 对等通信，没有leader/follower的说法，每个peer都是对等的；客户端请求会自动切换 到新的Eureka节点；当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。当Eureka节点接受客户端请求时，所有的操作都会在节点间进行复制（replicate To Peer）操作，将请求复制到该 Eureka Server 当前所知的其它所有节点中。至于为啥Eureka不能保证数据一致性，源于Eureka的自我保护机制：如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： </p><p>　　1. Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 。</p><p>　　2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 。</p><p>　　3. 当网络稳定时，当前实例新的注册信息会被同步到其它节点中。</p><p>　　因此， Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p><h3 id="配置中心的优势："><a href="#配置中心的优势：" class="headerlink" title="配置中心的优势："></a>配置中心的优势：</h3><p>1、各环境配置集中管理。</p><p>2、配置更改，实时推送，jvm环境变量及时生效。</p><p>3、依靠配置变更，动态扩展功能，减少二次上线带来的成本。</p><p>4、减少开发人员、运维人员修改配置带来的额外开销。</p><h3 id="配置中心架构图"><a href="#配置中心架构图" class="headerlink" title="配置中心架构图"></a>配置中心架构图</h3><p><img src="/2021/03/31/Microservices&DistributedSystem/%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/640632-20190605211836118-842920544.jpg" alt="Image zoo"></p><h3 id="配置中心的功能"><a href="#配置中心的功能" class="headerlink" title="配置中心的功能"></a>配置中心的功能</h3><p>1、配置管理平台中，操作人员可以创建项目所属系统、应用名称、实例名称、配置分组等信息。</p><p>2、配置管理平台中，操作人员可以上传配置文件，对属性有增、删、改、查的操作。</p><p>3、配置内容通过配置管理平台后台服务进行持久化（保存到数据库中）。</p><p>4、操作人员通过配置平台进行推送操作，将配置推送到zk集群相应结点（/cfgcenter/系统名称/应用名称/实例名称/分组名称）。</p><p>5、配置中心客户端监听zk集群中对应结点数据发生变化，读取变更后的内容，解析内容，刷新本地备份（分布式容灾）和Spring环境变量。</p><p>6、配置中心客户端如果和zk集群丢失连接，将加载本地本分配置到Spring环境变量。</p><p>7、配置中心客户端重新和zk集群建立连接，从zk集群中拉取最新配置内容，解析配置，刷新本地备份（分布式容灾）和Spring环境变量。</p><p>8、配置中心客户端将Spring环境变量刷新之后，动态刷新依赖配置中心配置的bean。</p><h3 id="补充阅读："><a href="#补充阅读：" class="headerlink" title="补充阅读："></a>补充阅读：</h3><ul><li><a href="http://techblog.netflix.com/2012/09/eureka.html" target="_blank" rel="noopener">Netflix Shares Cloud Load Balancing And Failover Tool: Eureka!</a></li><li><a href="https://groups.google.com/forum/#!topic/eureka_netflix/LXKWoD14RFY" target="_blank" rel="noopener">Thread on ZooKeeper Vs Eureka</a></li><li><a href="https://github.com/Netflix/eureka/wiki/FAQ" target="_blank" rel="noopener">Why Not Use Curator/Zookeeper as a Service Registry?</a></li><li><a href="http://developers.blog.box.com/2012/04/10/a-gotcha-when-using-zookeeper-ephemeral-nodes/" target="_blank" rel="noopener">A Gotcha When Using ZooKeeper Ephemeral Nodes</a></li><li><a href="http://techblog.netflix.com/2011/11/introducing-curator-netflix-zookeeper.html" target="_blank" rel="noopener">Introducing Curator – The Netflix ZooKeeper Library</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务与分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2021/03/31/Microservices&amp;DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2021/03/31/Microservices&amp;DistributedSystem/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li>无锁</li><li>jvm锁</li><li>mysql锁</li><li>redis锁、红锁</li><li>zookeeper锁</li><li>etcd</li></ul><p><a href="https://github.com/wangqi-jeffrey/jeffrey-blog-examples/tree/main/distributed-lock" target="_blank" rel="noopener">代码位置</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务与分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么又采用多线程了</title>
      <link href="/2021/03/29/Redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%86/"/>
      <url>/2021/03/29/Redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p><strong>Redis 不是已经采用了多路复用技术吗？不是号称很高的性能了吗？为啥还要采用多线程模型呢？</strong></p><h2 id="Redis-为什么最开始被设计成单线程的？"><a href="#Redis-为什么最开始被设计成单线程的？" class="headerlink" title="Redis 为什么最开始被设计成单线程的？"></a>Redis 为什么最开始被设计成单线程的？</h2><p>Redis 作为一个成熟的分布式缓存框架，它由很多个模块组成，如网络请求模块、索引模块、存储模块、高可用集群支撑模块、数据操作模块等。很多人说 Redis 是单线程的，就认为 Redis 中所有模块的操作都是单线程的，其实这是不对的。</p><p>我们所说的 Redis 单线程，指的是 “其网络 IO 和键值对读写是由一个线程完成的”。</p><p>也就是说，<strong>Redis 中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。</strong></p><p>所以说，Redis 中并不是没有多线程模型的，早在 Redis 4.0 的时候就已经针对部分命令做了多线程化。</p><p>那么，为什么网络操作模块和数据存储模块最初并没有使用多线程呢？</p><p>这个问题的答案比较简单！因为：”没必要！”</p><p>为什么没必要呢？我们先来说一下，什么情况下要使用多线程？</p><h3 id="多线程适用场景"><a href="#多线程适用场景" class="headerlink" title="多线程适用场景"></a><strong>多线程适用场景</strong></h3><p>一个计算机程序在执行的过程中，主要需要进行两种操作分别是读写操作和计算操作。</p><p>其中读写操作主要是涉及到的就是 I/O 操作，其中包括网络 I/O 和磁盘 I/O。计算操作主要涉及到 CPU。</p><p><strong>而多线程的目的，就是通过并发的方式来提升 I/O 的利用率和 CPU 的利用率。</strong></p><p>那么，Redis 需不需要通过多线程的方式来提升提升 I/O 的利用率和 CPU 的利用率呢？</p><p>首先，我们可以肯定的说，Redis 不需要提升 CPU 利用率，因为 <strong>Redis 的操作基本都是基于内存的，CPU 资源根本就不是 Redis 的性能瓶颈。</strong></p><p><strong>所以，通过多线程技术来提升 Redis 的 CPU 利用率这一点是完全没必要的。</strong></p><p>那么，使用多线程技术来提升 Redis 的 I/O 利用率呢？是不是有必要呢？</p><p>Redis 确实是一个 I/O 操作密集的框架，他的数据操作过程中，会有大量的网络 I/O 和磁盘 I/O 的发生。要想提升 Redis 的性能，是一定要提升 Redis 的 I/O 利用率的，这一点毋庸置疑。</p><p>但是，<strong>提升 I/O 利用率，并不是只有采用多线程技术这一条路可以走！</strong></p><h3 id="多线程的弊端"><a href="#多线程的弊端" class="headerlink" title="多线程的弊端"></a><strong>多线程的弊端</strong></h3><p>如内存模型、锁、CAS 等，这些都是 Java 中提供的一些在多线程情况下保证线程安全的技术。</p><blockquote><p>线程安全：是编程中的术语，指某个函数、函数库在并发环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p></blockquote><p>和 Java 类似，所有支持多线程的编程语言或者框架，都不得不面对的一个问题，那就是如何解决多线程编程模式带来的共享资源的并发控制问题。</p><p>虽然，采用多线程可以帮助我们<strong>提升 CPU 和 I/O 的利用率</strong>，但是多线程带来的并发问题也<strong>给这些语言和框架带来了更多的复杂性</strong>。</p><p>而且，多线程模型中，<strong>多个线程的互相切换也会带来一定的性能开销。</strong></p><p>所以，在提升 I/O 利用率这个方面上，Redis 并没有采用多线程技术，而是选择了<strong>多路复用 I/O</strong> 技术。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>Redis 并没有在网络请求模块和数据操作模块中使用多线程模型，主要是基于以下四个原因：</p><ul><li>1、Redis 操作基于内存，绝大多数操作的性能瓶颈不在 CPU</li><li>2、使用单线程模型，可维护性更高，开发，调试和维护的成本更低</li><li>3、单线程模型，避免了线程间切换带来的性能开销</li><li>4、在单线程中使用多路复用 I/O 技术也能提升 Redis 的 I/O 利用率</li></ul><p>还是要记住：Redis 并不是完全单线程的，只是有关键的网络 IO 和键值对读写是由一个线程完成的。</p><h2 id="Redis-的多路复用"><a href="#Redis-的多路复用" class="headerlink" title="Redis 的多路复用"></a>Redis 的多路复用</h2><p>这里先讲讲 <strong>Linux 多路复用技术，就是多个进程的 IO 可以注册到同一个管道上，这个管道会统一和内核进行交互。</strong></p><p><strong>当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。</strong></p><p><img src="/2021/03/29/Redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%86/01.jpeg" alt="Image png"></p><p>也就是说，通过一个线程来处理多个 IO 流。</p><p>IO 多路复用在 Linux 下包括了三种，select、poll、epoll，抽象来看，他们功能是类似的，但具体细节各有不同。</p><p>其实，Redis 的 IO 多路复用程序的所有功能都是通过包装操作系统的 IO 多路复用函数库来实现的。</p><p>每个 IO 多路复用函数库在 Redis 源码中都有对应的一个单独的文件。</p><p><img src="/2021/03/29/Redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%86/02.jpeg" alt="Image png"></p><p>在 Redis 中，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。</p><p>因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p><img src="/2021/03/29/Redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%86/03.jpeg" alt="Image png"></p><p>一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p><p>所以，Redis 选择使用多路复用 IO 技术来提升 I/O 利用率。</p><p>而之所以 Redis 能够有这么高的性能，不仅仅和采用多路复用技术和单线程有关，此外还有以下几个原因：</p><ol><li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。</li><li>数据结构简单，对数据操作也简单，如哈希表、跳表都有很高的性能。</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU</li><li>使用多路 I/O 复用模型</li></ol><h2 id="为什么-Redis-6-0-引入多线程"><a href="#为什么-Redis-6-0-引入多线程" class="headerlink" title="为什么 Redis 6.0 引入多线程"></a>为什么 Redis 6.0 引入多线程</h2><p>2020 年 5 月份，Redis 正式推出了 6.0 版本，这个版本中有很多重要的新特性，其中多线程特性引起了广泛关注。</p><p>但是，需要提醒大家的是，<strong>Redis 6.0 中的多线程，也只是针对处理网络请求过程采用了多线程，而数据的读写命令，仍然是单线程处理的。</strong></p><p>但是，不知道会不会有人有这样的疑问：</p><blockquote><p>Redis 不是号称单线程也有很高的性能么？</p></blockquote><p><strong>不是说多路复用技术已经大大的提升了 IO 利用率了么，为啥还需要多线程？</strong></p><p>主要是因为我们对 Redis 有着更高的要求。</p><p>根据测算，Redis 将所有数据放在内存中，内存的响应时长大约为 100 纳秒，对于小数据包，Redis 服务器可以处理 80,000 到 100,000 QPS，这么高的对于 80% 的公司来说，单线程的 Redis 已经足够使用了。</p><p>但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的 QPS。</p><p>为了提升 QPS，很多公司的做法是部署 Redis 集群，并且尽可能提升 Redis 机器数。</p><p>但是这种做法的资源消耗是巨大的。</p><p>而经过分析，限制 Redis 的性能的主要瓶颈出现在网络 IO 的处理上，虽然之前采用了多路复用技术。</p><p>但是我们前面也提到过，<strong>多路复用的 IO 模型本质上仍然是同步阻塞型 IO 模型</strong>。</p><p>下面是多路复用 IO 中 select 函数的处理过程：</p><p><img src="/2021/03/29/Redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%86/04.jpeg" alt="Image png"></p><p>从上图我们可以看到，<strong>在多路复用的 IO 模型中，在处理网络请求时，调用 select （其他函数同理）的过程是阻塞的，也就是说这个过程会阻塞线程，如果并发量很高，此处可能会成为瓶颈。</strong></p><p>虽然现在很多服务器都是多个 CPU 核的，但是对于 Redis 来说，因为使用了单线程，在一次数据操作的过程中，有大量的 CPU 时间片是耗费在了网络 IO 的同步处理上的，并没有充分的发挥出多核的优势。</p><p>如果能采用多线程，使得网络处理的请求并发进行，就可以大大的提升性能。多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势。</p><p>所以，Redis 6.0 采用多个 IO 线程来处理网络请求，网络请求的解析可以由其他线程完成，然后把解析后的请求交由主线程进行实际的内存读写。</p><p>提升网络请求处理的并行度，进而提升整体性能。</p><p>但是，Redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，Redis 仍然使用单线程来处理。</p><p><strong>那么，在引入多线程之后，如何解决并发带来的线程安全问题呢？</strong></p><p>这就是为什么我们前面多次提到的 “Redis 6.0 的多线程只用来处理网络请求，而数据的读写还是单线程” 的原因。</p><p>Redis 6.0 只有在网络请求的接收和解析，以及请求后的数据通过网络返回给时，使用了多线程。而数据读写操作还是由单线程来完成的，所以，这样就不会出现并发问题了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/Zzbj/p/13531622.html" target="_blank" rel="noopener">https://www.cnblogs.com/Zzbj/p/13531622.html</a></p><p><a href="https://xie.infoq.cn/article/b3816e9fe3ac77684b4f29348" target="_blank" rel="noopener">https://xie.infoq.cn/article/b3816e9fe3ac77684b4f29348</a></p><p><a href="https://jishuin.proginn.com/p/763bfbd2a1c2" target="_blank" rel="noopener">https://jishuin.proginn.com/p/763bfbd2a1c2</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战分享</title>
      <link href="/2021/03/23/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/Git%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB/"/>
      <url>/2021/03/23/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/Git%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><h5 id="1-git-的四个区域"><a href="#1-git-的四个区域" class="headerlink" title="1. git 的四个区域"></a>1. git 的四个区域</h5><p><img src="/2021/03/23/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/Git%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB/image2019-1-25_20_50_37.png" alt="Image zoo"></p><ul><li>工作区（Workspace）：开发时放代码的目录</li><li>暂存区（Index / Stage）：临时存放改动文件，就是一个二进制文件。路径.git/index</li><li>版本库（Repository）：.git目录，记录所有版本的数据和提交记录。</li><li>远端库（Remote）：托管代码的地方，如gitlab或github等。</li></ul><h5 id="2-文件的四种状态"><a href="#2-文件的四种状态" class="headerlink" title="2. 文件的四种状态"></a>2. 文件的四种状态</h5><p><img src="/2021/03/23/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/Git%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB/image2019-1-25_20_50_50.png" alt="Image zoo"></p><ul><li>未跟踪（Untracked）： 文件在工作区中的文件夹，但没有加入到git的管理，通过git add可以将状态变成Staged。</li><li>未修改（Unmodify）： 文件已经通过git管理，未修改表示当前文件与版本库的文件完全一致。 </li><li>已修改（Modified）： 仅仅是修改, 并没有进行其他的操作。 </li><li>已暂存（Staged）： 文件放到暂存区，执行git commit会将其放到git版本库中。</li></ul><h5 id="3-git-的目录结构"><a href="#3-git-的目录结构" class="headerlink" title="3. git 的目录结构"></a>3. git 的目录结构</h5><p><img src="/2021/03/23/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/Git%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB/image2019-1-25_20_51_1.png" alt="Image zoo"></p><ul><li>hooks/: 钩子，存放脚本，执行git命令前后触发相应的脚本</li><li>info/: 仓库的一些信息</li><li>logs/: 保存所有更新的引用记录</li><li>objects/: 保存所有的git对象，对象为SHA1哈希值，前两位为文件夹，后38位为文件名(快速检索)</li><li>refs/: 主要包括三个文件夹heads、remotes、tags以及一个文件stash，主要记录项目中各个分支指向的commit</li><li>COMMIT_EDITMSG: 保存最新的commit message，git不使用，仅供用户参考展示</li><li>config: git仓库的配置文件</li><li>description: git仓库描述信息，主要给gitlab等托管系统使用</li><li>index: 暂存区，二进制文件</li><li>HEAD: 当前分支的引用，并可获取到下一次commit的parent</li><li>ORIG_HEAD: HEAD指针的前一个状态</li><li>FETCH_HEAD: 版本链接，指向着目前已经从远程仓库取下来的分支的末端版本</li></ul><h5 id="4-git-的对象类型"><a href="#4-git-的对象类型" class="headerlink" title="4. git 的对象类型"></a>4. git 的对象类型</h5><p><img src="/2021/03/23/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/Git%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB/image2019-1-25_20_51_18.png" alt="image2019-1-25 20_51_18"></p><h5 id="5-对象类型概念"><a href="#5-对象类型概念" class="headerlink" title="5. 对象类型概念"></a>5. 对象类型概念</h5><ul><li>blob：表示一个（版本的）文件，只包含文件的数据，无其他元数据比如名称、路径、格式。</li><li>tree: 表示一个目录信息，包括此目录下的 blob、子目录（子 tree）、文件名、路径、文件属性。</li><li>commit: 提交一个更新的所有元数据，如指向的 tree，父 commit，作者、提交者、提交日期、提交日志等。一个 commit 可以有多个父类 commit。</li></ul><h5 id="6-查看对象类型"><a href="#6-查看对象类型" class="headerlink" title="6. 查看对象类型"></a>6. 查看对象类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看index文件内容</span><br><span class="line">git ls-files --stage</span><br><span class="line"># 查看HEAD指向的目录树</span><br><span class="line">git ls-tree -l head</span><br><span class="line"># 查看commit记录</span><br><span class="line">git log</span><br><span class="line"># 查看对象类型</span><br><span class="line">git cat-file -t [id]</span><br><span class="line"># 查看对象内容</span><br><span class="line">git cat-file -p [id]</span><br><span class="line"># 查看分支tree结构</span><br><span class="line">git ls-tree master^&#123;tree&#125;</span><br><span class="line"># 查看所有对象</span><br><span class="line">find ./.git/objects -type f</span><br></pre></td></tr></table></figure><h4 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a>二、基本命令</h4><p>以下命令中<code>[]</code>请替换。</p><h5 id="1-新建-git-版本库"><a href="#1-新建-git-版本库" class="headerlink" title="1. 新建 git 版本库"></a>1. 新建 git 版本库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 当前目录新建git版本库</span><br><span class="line">git init</span><br><span class="line"># 当前目录新建一个目录，初始化为git版本库</span><br><span class="line">git init [project-name]</span><br><span class="line"># 从远端库下载一个项目和代码的提交历史</span><br><span class="line">git clone [url]</span><br><span class="line"># 从远端库下载一个项目和最近一次代码的提交历史，节省拉取时间</span><br><span class="line">git clone --depth=1 [url]</span><br></pre></td></tr></table></figure><blockquote><p>TIP： <code>git clone --depth=1</code>只 clone 默认分支，如想要拉取其他分支</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 克隆</span><br><span class="line">git clone --depth=1 [url]</span><br><span class="line"># 设置远端分支</span><br><span class="line">git remote set-branches origin [remote-branch-name]</span><br><span class="line"># 拉取远端分支</span><br><span class="line">git fetch --depth=1 origin [remote-branch-name]</span><br><span class="line"># 切换分支</span><br><span class="line">git checkout [remote-branch-name]</span><br></pre></td></tr></table></figure><h5 id="2-查看文件状态"><a href="#2-查看文件状态" class="headerlink" title="2. 查看文件状态"></a>2. 查看文件状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有文件的状态</span><br><span class="line">git status</span><br><span class="line"># 查看指定文件的状态</span><br><span class="line">git status [filename]</span><br></pre></td></tr></table></figure><h5 id="3-查看提交日志"><a href="#3-查看提交日志" class="headerlink" title="3. 查看提交日志"></a>3. 查看提交日志</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 表示查看最近几次的提交, n为数字</span><br><span class="line">git log -n</span><br><span class="line"># 显示最近两次提交的不同点</span><br><span class="line">git log -p -2</span><br><span class="line"># 筛选某个author的提交</span><br><span class="line">git log --author [author-name]</span><br></pre></td></tr></table></figure><blockquote><p>TTP：<code>git log</code>按q键退出</p></blockquote><h5 id="4-工作区-lt-–-gt-暂存区"><a href="#4-工作区-lt-–-gt-暂存区" class="headerlink" title="4. 工作区&lt;–&gt;暂存区"></a>4. 工作区&lt;–&gt;暂存区</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 将工作区当前目录下的所有文件添加到暂存区</span><br><span class="line">git add .</span><br><span class="line"># 将工作区指定文件添加到暂存区</span><br><span class="line">git add [filename1] [filename2] [...]</span><br><span class="line"># 将工作区指定目录(包括子目录和文件)添加到暂存区</span><br><span class="line">git add [dir]</span><br><span class="line"> </span><br><span class="line"># 删除暂存区的文件, 但不删除工作区的文件(会脱离git管理)</span><br><span class="line">git rm --cached [filename]</span><br><span class="line"># 删除暂存区的文件同时工作区的文件(慎用)</span><br><span class="line">git rm [filename]</span><br><span class="line"> </span><br><span class="line"># 将暂存区将文件恢复到工作区，如工作区有该文件则覆盖</span><br><span class="line">git checkout -- [filename]</span><br><span class="line"># 从其他分支拉取文件，会同时覆盖工作区和暂存区的文件</span><br><span class="line">git checkout [branch-name] -- [filename]</span><br><span class="line"># 将暂存区所有文件恢复到工作区(慎用)</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure><blockquote><p>TIP： <code>git checkout [filename]</code>可以直接将暂存区将文件恢复到工作区，增加<code>--</code>是为了告知 git 这是一个文件名，与分支名做区分。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 切换分支</span><br><span class="line">git checkout [branch-name]</span><br><span class="line"># 将暂存区将文件恢复到工作区</span><br><span class="line">git checkout -- [filename]</span><br></pre></td></tr></table></figure><blockquote><p>TIP：git 无法提交空目录，如果必须提交空目录，可在该目录下添加<code>.gitkeep</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 批量给空目录添加.gitkeep文件，别忘了最后的分号</span><br><span class="line">find . -type d -empty -and -not -regex ./\.git.* -exec touch &#123;&#125;/.gitkeep \;</span><br></pre></td></tr></table></figure><h5 id="5-工作区-暂存区-lt-–-gt-版本库"><a href="#5-工作区-暂存区-lt-–-gt-版本库" class="headerlink" title="5. 工作区/暂存区&lt;–&gt;版本库"></a>5. 工作区/暂存区&lt;–&gt;版本库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 将暂存区文件提交至版本库</span><br><span class="line">git commit -m &quot;[commit message]&quot;</span><br><span class="line"># 将暂存区已跟踪的文件提交至版本库 </span><br><span class="line">git commit -am &quot;[commit message]&quot;</span><br><span class="line">文件a.txt处于已跟踪，但未暂存状态。这时，如果使用git commit -m是无法提交最新版本的a.txt的，提交的只是最开始空内容的旧版本a.txt</span><br><span class="line">要提交新版本a.txt，即内容为&apos;a&apos;的a.txt，则需要使用git add a.txt，将新版本的a.txt放到staged暂存区，然后才能使用git commit -m进行提交，而如果使用git commit -am，则可以省略git add a.txt这一步，因为git commit -am可以提交跟踪过的文件，而a.txt一开始已经被跟踪过了</span><br><span class="line"></span><br><span class="line"># 追加，如果已经推送到远端库不推荐</span><br><span class="line">git commit --amend</span><br><span class="line"># 移除暂存区的文件(不会脱离git管理)</span><br><span class="line">git reset HEAD -- [filename]</span><br><span class="line"># 去掉上一次提交</span><br><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure><blockquote><p>TIP：<code>git commit -m</code>和<code>git commit -am</code>的区别</p></blockquote><p><code>git commit -m</code>用于提交暂存区文件；</p><p><code>git commit -am</code>用于提交已跟踪的文件，一般可理解成<code>git add .</code>和<code>git commit -m</code>合并，但仍有区别，如果新建文件(未跟踪过的文件)则无法提交。</p><blockquote><p>TIP：<code>git rm --cached [filename]</code>和<code>git reset HEAD -- [filename]</code>两个命令都是删除暂存区，区别</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 该删除会脱离git管理，一般处理不想通过git管理的文件，比如临时文件等</span><br><span class="line">git rm --cached [filename]</span><br><span class="line"># 该删除不会脱离git管理，主要处理某次不想提交的代码</span><br><span class="line">git reset HEAD -- [filename]</span><br></pre></td></tr></table></figure><h5 id="6-工作区-版本库-lt-–-gt-远端库"><a href="#6-工作区-版本库-lt-–-gt-远端库" class="headerlink" title="6. 工作区/版本库&lt;–&gt;远端库"></a>6. 工作区/版本库&lt;–&gt;远端库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 将远端库代码拉取至版本库，不合并工作区代码，使用`git fetch [remote-name]`，一般而言采用下列命令即可</span><br><span class="line">git fetch origin</span><br><span class="line"> </span><br><span class="line"># 将远端库代码拉取至版本库，且会合并工作区代码</span><br><span class="line">git pull origin</span><br><span class="line"># 采用rebase方式拉取代码</span><br><span class="line">git pull --rebase</span><br><span class="line"># 将远端库代码拉取至版本库，并合并工作区指定分支代码</span><br><span class="line">git pull [remote-name] [remote-branch-name]:[branch-name]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 将当前分支的代码推送至远端库</span><br><span class="line">git push origin</span><br><span class="line"># 将本地版本库指定分支的代码推送至远端库</span><br><span class="line">git push origin [branch-name]</span><br><span class="line"># 将本地版本库指定分支的代码推送到指定的远端库</span><br><span class="line">git push -u [remote-name] [branch-name]</span><br><span class="line"># 强制推送(慎用)</span><br><span class="line">git push -f origin [branch-name]</span><br></pre></td></tr></table></figure><blockquote><p>TIP：git fetch/git pull/git pull –rebase 区别</p></blockquote><p><code>git pull</code>相当于<code>git fetch</code>+<code>git merge</code>，<code>git pull --rebase</code>相当于<code>git fetch</code>+<code>git rebase</code>。</p><p>虽说<code>git pull</code>相当于<code>git fetch</code>+<code>git merge</code>，但不推荐直接使用。一般推荐使用<code>git pull --rebase</code>或使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 先拉取代码到版本库，如master</span><br><span class="line">git fetch origin master</span><br><span class="line"># 查看冲突或者是否需要合并，再进行合并</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><h5 id="7-工作区-lt-–-gt-储藏区"><a href="#7-工作区-lt-–-gt-储藏区" class="headerlink" title="7. 工作区&lt;–&gt;储藏区"></a>7. 工作区&lt;–&gt;储藏区</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 将工作区的所有改动，放到储藏区</span><br><span class="line">git stash</span><br><span class="line"># 查看储藏区内容</span><br><span class="line">git stash list</span><br><span class="line"># 弹出储藏区最近一次保存的内容并删除储藏区该条记录</span><br><span class="line">git stash pop</span><br><span class="line"># 储藏时打标记</span><br><span class="line">git stash save &quot;[message]&quot;</span><br><span class="line"># 应用某条储藏，不删除储藏区记录，下列`n`为数字</span><br><span class="line">git stash apply stash@&#123;n&#125;</span><br><span class="line"># 删除某条储藏记录，下列`n`为数字</span><br><span class="line">git stash drop stash@&#123;n&#125;</span><br><span class="line"># 清空储藏记录</span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h5 id="8-git-分支"><a href="#8-git-分支" class="headerlink" title="8. git 分支"></a>8. git 分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 切换分支</span><br><span class="line">git checkout [branch-name]</span><br><span class="line"># 强制切换分支，会丢失当前工作区修改过文件(慎用)</span><br><span class="line">git checkout -f [branch-name]</span><br><span class="line"># 切换到上一个分支</span><br><span class="line">git checkout -</span><br><span class="line"> </span><br><span class="line"># 撤销工作区中当前目录中的所有更改</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure><blockquote><p>TIP：git checkout 可以操作文件和操作分支，一定要注意!</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line">git branch -l</span><br><span class="line"># 列出所有远端分支</span><br><span class="line">git branch -r</span><br><span class="line"># 列出所有分支，包括本地和远端</span><br><span class="line">git branch -a</span><br><span class="line"># 新建一个分支，不切换分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch-name]</span><br><span class="line"># 分支重命名</span><br><span class="line">git branch -m [old-branch-name] [new-branch-name]</span><br><span class="line"># 删除分支,不能删除当前所在的分支</span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"># 强制删除分支(慎用)</span><br><span class="line">git branch -D [branch-name]</span><br><span class="line"># 查看本地分支对应的远端分支</span><br><span class="line">git branch -vv</span><br><span class="line"># 删除远端库分支</span><br><span class="line">git push origin --delete [remote-branch-name]</span><br><span class="line"> </span><br><span class="line"># 新建分支时跟远端特定的分支关联(推荐使用关联创建分支)</span><br><span class="line">git checkout -b [local-branch-name] -t origin/[remote-branch-name]</span><br><span class="line"># 已存在的分支与远端分支关联，本地必须存在该分支</span><br><span class="line">git branch -u origin/[remote-branch-name] [local-branch-name]</span><br></pre></td></tr></table></figure><h5 id="9-git-标签"><a href="#9-git-标签" class="headerlink" title="9. git 标签"></a>9. git 标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有的标签</span><br><span class="line">git tag</span><br><span class="line"># 查看标签附加信息</span><br><span class="line">git tag -n</span><br><span class="line"># 通过*过滤标签,如下就可以过滤出v0.1版本的标签</span><br><span class="line">git tag -l &quot;v0.1.*&quot;</span><br><span class="line"># 显示详细的附注信息</span><br><span class="line">git show [tag-name]</span><br><span class="line"> </span><br><span class="line"># 创建标签</span><br><span class="line">git tag -a [tag-name] -m [tag-message]</span><br><span class="line"># 删除标签</span><br><span class="line">git tag -d [tag-name]</span><br><span class="line"> </span><br><span class="line"># 将所有的标签推送至远端库</span><br><span class="line">git push origin --tags</span><br><span class="line"># 将特定的标签推送至远端库</span><br><span class="line">git push origin [tag-name]</span><br><span class="line"># 获取远端库标签</span><br><span class="line">git fetch origin tag [tag-name]</span><br><span class="line"># 切换标签</span><br><span class="line">git checkout [tag-name]</span><br><span class="line"># 删除远端库标签</span><br><span class="line">git push --delete origin [tag-name]</span><br></pre></td></tr></table></figure><h5 id="10-删除、撤销与回滚"><a href="#10-删除、撤销与回滚" class="headerlink" title="10. 删除、撤销与回滚"></a>10. 删除、撤销与回滚</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看工作区可删除的未跟踪文件</span><br><span class="line">git clean -n</span><br><span class="line"># 移除当前目录下未被跟踪的文件，但不会删除目录和`.gitignore`中指定的未跟踪的文件</span><br><span class="line">git clean -f [path]</span><br><span class="line"># 移除当前目录下未被跟踪的文件和目录</span><br><span class="line">git clean -df</span><br><span class="line"># 移除当前目录下未被跟踪的文件和目录和`.gitignore`中指定的未跟踪的文件</span><br><span class="line">git clean -xf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 将HEAD和暂存区重置到某个commit，不重置工作区</span><br><span class="line">git reset --mixed [commit-id]</span><br><span class="line"># 将HEAD重置到某个commit，不重置工作区和暂存区</span><br><span class="line">git reset --soft [commit-id]</span><br><span class="line"># 将HEAD重置到某个commit，同时也重置工作区和暂存区</span><br><span class="line">git reset --hard [commit-id]</span><br><span class="line"></span><br><span class="line"># 重置前一次commit</span><br><span class="line">git reset HEAD^</span><br><span class="line"># 重置前两次commit</span><br><span class="line">git reset HEAD~2</span><br><span class="line"></span><br><span class="line"># 查看reset前的commit提交</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><blockquote><p>TIP：HEAD的使用。HEAD为当前游标指向，即最近一次commit；HEAD^为上一次commit, HEAD^^为上一次的上一次的commit，即倒数第三次提交；HEAD~3为倒数第四次提交</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 撤销(回滚)到某个commit</span><br><span class="line">git revert [commit-id]</span><br><span class="line"># 工作区出现冲突时，解决后继续执行</span><br><span class="line">git revert --continue</span><br><span class="line"># 工作区出现冲突时，取消revert操作</span><br><span class="line">git revert --abort</span><br></pre></td></tr></table></figure><h5 id="11-合并分支"><a href="#11-合并分支" class="headerlink" title="11. 合并分支"></a>11. 合并分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 允许以fast-forward的方式合并</span><br><span class="line">git merge [branch-name]</span><br><span class="line"># 只能以fast-forward的方式合并</span><br><span class="line">git merge --ff-only [branch-name]</span><br><span class="line"># 不使用fast-forward的方式合并</span><br><span class="line">git merge --no-ff [branch-name]</span><br><span class="line"># 将所有的commit压缩成一个进行合并</span><br><span class="line">git merge --squash [branch-name]</span><br><span class="line"></span><br><span class="line"># 采用rebase的形式合并</span><br><span class="line">git rebase [branch-name]</span><br><span class="line"></span><br><span class="line"># 合并某个特定的commit</span><br><span class="line">git cherry-pick [commmit-id]</span><br></pre></td></tr></table></figure><h5 id="12-分支或文件比较"><a href="#12-分支或文件比较" class="headerlink" title="12. 分支或文件比较"></a>12. 分支或文件比较</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 比较工作区和上一次提交的文件差异</span><br><span class="line">git diff HEAD</span><br><span class="line"># 查看当前分支跟指定的分支的差异</span><br><span class="line">git diff [branch-name]</span><br><span class="line"># 查看两个分支的差异</span><br><span class="line">git diff [branch-name-1] [branch-name-2]</span><br><span class="line"># 查看冲突文件</span><br><span class="line">git diff --name-only --diff-filter=U</span><br></pre></td></tr></table></figure><h4 id="三、配置与别名"><a href="#三、配置与别名" class="headerlink" title="三、配置与别名"></a>三、配置与别名</h4><h5 id="1-忽略文件提交"><a href="#1-忽略文件提交" class="headerlink" title="1. 忽略文件提交"></a>1. 忽略文件提交</h5><p>git中有三种方式可以忽略文件</p><ol><li><p>在git项目中创建.gitignore文件(推荐)</p><p>在项目某个文件夹下创建.gitignore文件，在文件内定义相应的忽略规则，便可管理当前文件夹下的文件是否提交。</p></li><li><p>编辑git项目<code>.git/info/exclude</code>文件</p><p>编辑git项目<code>.git/info/exclude</code>文件也可忽略文件，但这种只针对于跟目录</p></li><li><p>定义全局.gitignore文件</p><p>通过<code>git config --global core.excludesfile ~/.gitignore</code>可定义全局的忽略文件，项目不共享仅限本机用户。</p></li></ol><p>git匹配示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，但不忽略bin文件</span><br><span class="line">bin/</span><br><span class="line"># 忽略根目录下的bin文件</span><br><span class="line">/bin</span><br><span class="line"># 忽略项目中所有以.log结尾的文件</span><br><span class="line">*.log</span><br><span class="line"># 忽略项目根目录下以.log结尾的文件，但不忽略子文件下的.log文件</span><br><span class="line">/*.log</span><br><span class="line"># 忽略/foo, a/foo, a/b/foo等</span><br><span class="line">**/foo</span><br><span class="line"># 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj</span><br><span class="line">debug/*.obj</span><br><span class="line">#表示忽略/src/main/test/目录下的所有文件但不忽略文件夹</span><br><span class="line">src/main/test/*</span><br><span class="line"># 不忽略 bin 目录下的 run.sh 文件</span><br><span class="line">!/bin/run.sh</span><br></pre></td></tr></table></figure><h5 id="2-git配置"><a href="#2-git配置" class="headerlink" title="2. git配置"></a>2. git配置</h5><p>git可以配置用户信息、配置信息、别名等信息，配置有三个不同的路径</p><ol><li>系统级配置<code>/etc/gitconfig</code>，可以通过<code>git config --system</code>添加</li><li>当前用户级配置<code>~/.gitconfig</code>或<code>~/.config/git/config</code>，可以通过<code>git config --global</code>添加</li><li>当前项目配置<code>.git/config</code>，可以通过<code>git config</code>添加</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 配置项目级的用户名</span><br><span class="line">git config user.name &quot;your name&quot;</span><br><span class="line"># 配置全局用户名</span><br><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line"># 配置全局邮箱</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br><span class="line"></span><br><span class="line"># 查看全部配置信息</span><br><span class="line">git config --list</span><br><span class="line"># 删除某些全部配置，如删除全局用户名</span><br><span class="line">git config --global --unset user.name</span><br><span class="line"># 编辑配置文件</span><br><span class="line">git config --global --edit</span><br></pre></td></tr></table></figure><h5 id="3-别名"><a href="#3-别名" class="headerlink" title="3. 别名"></a>3. 别名</h5><p>通过<code>git config</code>可以设置别名，便于用户使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 给checkout起别名co，可以通过git co进行分支切换</span><br><span class="line">git config --global alias.co checkout</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">co = checkout</span><br><span class="line">br = branch</span><br><span class="line">ci = commit</span><br><span class="line">cm = commit -m</span><br><span class="line">st = status</span><br><span class="line">ss = status --short</span><br><span class="line">cp = cherry-pick</span><br><span class="line">lm = log --no-merges --color --date=format:&apos;%Y-%m-%d %H:%M:%S&apos; --pretty=format:&apos;%Cgreen%h%Creset -%C(bold white) %s %C(yellow)%d %Cred(%cd) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br><span class="line">ll = log --no-merges --color --date=format:&apos;%Y-%m-%d %H:%M:%S&apos; --pretty=format:&apos;%Cgreen%h%Creset -%C(bold white) %s %C(yellow)%d %Cred(%cd) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit -10</span><br><span class="line">lg = log --graph --color --date=format:&apos;%Y-%m-%d %H:%M:%S&apos; --pretty=format:&apos;%Cgreen%h%Creset -%C(bold white) %s %C(yellow)%d %Cred(%cd) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br><span class="line">ls = log --stat --color --date=format:&apos;%Y-%m-%d %H:%M:%S&apos; --pretty=format:&apos;%Cgreen%h%Creset -%C(bold white) %s %C(yellow)%d %Cred(%cd) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br><span class="line">reflg = reflog --pretty=reflog</span><br><span class="line">undo = &quot;!f() &#123; git reset --hard $(git rev-parse --abbrev-ref HEAD)@&#123;$&#123;1-1&#125;&#125;; &#125;; f&quot;</span><br><span class="line">[pretty]</span><br><span class="line">  reflog = %C(green)%h -%Cred%gd %C(bold white) %s %C(yellow)%d  %C(blue)%cr%C(reset) %gs (%s)</span><br></pre></td></tr></table></figure><p>其中lm表示无合并commit的日志，ll查看近10条记录，lg查看个分支关系图，ls查看日志并比较各commit，undo撤销</p><blockquote><p>TIP：日志的查看可以使用<code>gitk &amp;</code>进行查看当前分支，或通过<code>gitk --all &amp;</code>查看各个分支的情况</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么MySQL不推荐使用uuid或者雪花id作为主键</title>
      <link href="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/"/>
      <url>/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>在mysql中设计表的时候,mysql官方推荐不要使用uuid或者不连续不重复的雪花id(long形且唯一，单机递增),而是推荐连续自增的主键id,官方的推荐是auto_increment,那么为什么不建议采用uuid,使用uuid究竟有什么坏处？</p><h4 id="一、mysql和程序实例"><a href="#一、mysql和程序实例" class="headerlink" title="一、mysql和程序实例"></a>一、mysql和程序实例</h4><h5 id="1-1-要说明这个问题-我们首先来建立三张表"><a href="#1-1-要说明这个问题-我们首先来建立三张表" class="headerlink" title="1.1.要说明这个问题,我们首先来建立三张表"></a>1.1.要说明这个问题,我们首先来建立三张表</h5><p>分别是user_auto_key,user_uuid,user_random_key,分别表示自动增长的主键,uuid作为主键,随机key作为主键,其它我们完全保持不变.</p><p>根据控制变量法,我们只把每个表的主键使用不同的策略生成,而其他的字段完全一样，然后测试一下表的插入速度和查询速度：</p><h6 id="注：这里的随机key其实是指用雪花算法算出来的前后不连续不重复无规律的id-一串18位长度的long值"><a href="#注：这里的随机key其实是指用雪花算法算出来的前后不连续不重复无规律的id-一串18位长度的long值" class="headerlink" title="注：这里的随机key其实是指用雪花算法算出来的前后不连续不重复无规律的id:一串18位长度的long值"></a>注：这里的随机key其实是指用雪花算法算出来的前后不连续不重复无规律的id:一串18位长度的long值</h6><p>id自动生成表：</p><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/01.png" alt="Image zoo"></p><p>用户uuid表：</p><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/02.png" alt="Image zoo"></p><p>随机主键表：</p><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/03.png" alt="Image zoo"></p><h5 id="1-2-光有理论不行-直接上程序-使用spring的jdbcTemplate来实现增查测试："><a href="#1-2-光有理论不行-直接上程序-使用spring的jdbcTemplate来实现增查测试：" class="headerlink" title="1.2.光有理论不行,直接上程序,使用spring的jdbcTemplate来实现增查测试："></a>1.2.光有理论不行,直接上程序,使用spring的jdbcTemplate来实现增查测试：</h5><p>技术框架：springboot+jdbcTemplate+junit+hutool,程序的原理就是连接自己的测试数据库,然后在相同的环境下写入同等数量的数据，来分析一下insert插入的时间来进行综合其效率，为了做到最真实的效果,所有的数据采用随机生成，比如名字、邮箱、地址都是随机生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">import cn.hutool.core.collection.CollectionUtil;</span><br><span class="line">import com.wyq.mysqldemo.databaseobject.UserKeyAuto;</span><br><span class="line">import com.wyq.mysqldemo.databaseobject.UserKeyRandom;</span><br><span class="line">import com.wyq.mysqldemo.databaseobject.UserKeyUUID;</span><br><span class="line">import com.wyq.mysqldemo.diffkeytest.AutoKeyTableService;</span><br><span class="line">import com.wyq.mysqldemo.diffkeytest.RandomKeyTableService;</span><br><span class="line">import com.wyq.mysqldemo.diffkeytest.UUIDKeyTableService;</span><br><span class="line">import com.wyq.mysqldemo.util.JdbcTemplateService;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.util.StopWatch;</span><br><span class="line">import java.util.List;</span><br><span class="line">@SpringBootTest</span><br><span class="line">class MysqlDemoApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplateService jdbcTemplateService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AutoKeyTableService autoKeyTableService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UUIDKeyTableService uuidKeyTableService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RandomKeyTableService randomKeyTableService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void testDBTime() &#123;</span><br><span class="line"></span><br><span class="line">        StopWatch stopwatch = new StopWatch(&quot;执行sql时间消耗&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * auto_increment key任务</span><br><span class="line">         */</span><br><span class="line">        final String insertSql = &quot;INSERT INTO user_key_auto(user_id,user_name,sex,address,city,email,state) VALUES(?,?,?,?,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">        List&lt;UserKeyAuto&gt; insertData = autoKeyTableService.getInsertData();</span><br><span class="line">        stopwatch.start(&quot;自动生成key表任务开始&quot;);</span><br><span class="line">        long start1 = System.currentTimeMillis();</span><br><span class="line">        if (CollectionUtil.isNotEmpty(insertData)) &#123;</span><br><span class="line">            boolean insertResult = jdbcTemplateService.insert(insertSql, insertData, false);</span><br><span class="line">            System.out.println(insertResult);</span><br><span class="line">        &#125;</span><br><span class="line">        long end1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;auto key消耗的时间:&quot; + (end1 - start1));</span><br><span class="line"></span><br><span class="line">        stopwatch.stop();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * uudID的key</span><br><span class="line">         */</span><br><span class="line">        final String insertSql2 = &quot;INSERT INTO user_uuid(id,user_id,user_name,sex,address,city,email,state) VALUES(?,?,?,?,?,?,?,?)&quot;;</span><br><span class="line"></span><br><span class="line">        List&lt;UserKeyUUID&gt; insertData2 = uuidKeyTableService.getInsertData();</span><br><span class="line">        stopwatch.start(&quot;UUID的key表任务开始&quot;);</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line">        if (CollectionUtil.isNotEmpty(insertData)) &#123;</span><br><span class="line">            boolean insertResult = jdbcTemplateService.insert(insertSql2, insertData2, true);</span><br><span class="line">            System.out.println(insertResult);</span><br><span class="line">        &#125;</span><br><span class="line">        long over = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;UUID key消耗的时间:&quot; + (over - begin));</span><br><span class="line"></span><br><span class="line">        stopwatch.stop();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 随机的long值key</span><br><span class="line">         */</span><br><span class="line">        final String insertSql3 = &quot;INSERT INTO user_random_key(id,user_id,user_name,sex,address,city,email,state) VALUES(?,?,?,?,?,?,?,?)&quot;;</span><br><span class="line">        List&lt;UserKeyRandom&gt; insertData3 = randomKeyTableService.getInsertData();</span><br><span class="line">        stopwatch.start(&quot;随机的long值key表任务开始&quot;);</span><br><span class="line">        Long start = System.currentTimeMillis();</span><br><span class="line">        if (CollectionUtil.isNotEmpty(insertData)) &#123;</span><br><span class="line">            boolean insertResult = jdbcTemplateService.insert(insertSql3, insertData3, true);</span><br><span class="line">            System.out.println(insertResult);</span><br><span class="line">        &#125;</span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;随机key任务消耗时间:&quot; + (end - start));</span><br><span class="line">        stopwatch.stop();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String result = stopwatch.prettyPrint();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-程序写入结果"><a href="#1-3-程序写入结果" class="headerlink" title="1.3.程序写入结果"></a>1.3.程序写入结果</h5><p>user_key_auto写入结果：</p><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/04.png" alt="Image zoo"></p><p>user_random_key写入结果：</p><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/05.png" alt="Image zoo"></p><p>user_uuid表写入结果：</p><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/06.png" alt="Image zoo"></p><h5 id="1-4-效率测试结果"><a href="#1-4-效率测试结果" class="headerlink" title="1.4.效率测试结果"></a>1.4.效率测试结果</h5><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/07.png" alt="Image zoo"></p><p>在已有数据量为130W的时候：我们再来测试一下插入10w数据，看看会有什么结果：</p><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/08.png" alt="Image zoo"></p><p>可以看出在数据量100W左右的时候,uuid的插入效率垫底，并且在后序增加了130W的数据，uudi的时间又直线下降。</p><p>时间占用量总体可以打出的效率排名为：auto_key&gt;random_key&gt;uuid,uuid的效率最低，在数据量较大的情况下，效率直线下滑。</p><p>那么为什么会出现这样的现象呢？带着疑问,我们来探讨一下这个问题：</p><h4 id="二、使用uuid和自增id的索引结构对比"><a href="#二、使用uuid和自增id的索引结构对比" class="headerlink" title="二、使用uuid和自增id的索引结构对比"></a>二、使用uuid和自增id的索引结构对比</h4><h5 id="2-1-使用自增id的内部结构"><a href="#2-1-使用自增id的内部结构" class="headerlink" title="2.1.使用自增id的内部结构"></a>2.1.使用自增id的内部结构</h5><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/09.png" alt="Image zoo"></p><p>自增的主键的值是顺序的,所以Innodb把每一条记录都存储在一条记录的后面。当达到页面的最大填充因子时候(innodb默认的最大填充因子是页大小的15/16,会留出1/16的空间留作以后的修改)：</p><p>①下一条记录就会写入新的页中，一旦数据按照这种顺序的方式加载，主键页就会近乎于顺序的记录填满，提升了页面的最大填充率，不会有页的浪费</p><p>②新插入的行一定会在原有的最大数据行下一行,mysql定位和寻址很快，不会为计算新行的位置而做出额外的消耗</p><p>③减少了页分裂和碎片的产生</p><h5 id="2-2-使用uuid的索引内部结构"><a href="#2-2-使用uuid的索引内部结构" class="headerlink" title="2.2.使用uuid的索引内部结构"></a>2.2.使用uuid的索引内部结构</h5><p><img src="/2021/03/19/Database/%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8uuid%E6%88%96%E8%80%85%E9%9B%AA%E8%8A%B1id%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE/10.png" alt="Image zoo"></p><p>因为uuid相对顺序的自增id来说是毫无规律可言的,新行的值不一定要比之前的主键的值要大,所以innodb无法做到总是把新行插入到索引的最后,而是需要为新行寻找新的合适的位置从而来分配新的空间。</p><p>这个过程需要做很多额外的操作，数据的毫无顺序会导致数据分布散乱，将会导致以下的问题：</p><p>①写入的目标页很可能已经刷新到磁盘上并且从缓存上移除，或者还没有被加载到缓存中，innodb在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO</p><p>②因为写入是乱序的,innodb不得不频繁的做页分裂操作,以便为新的行分配空间,页分裂导致移动大量的数据，一次插入最少需要修改三个页以上</p><p>③由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终会导致数据会有碎片</p><p>在把随机值（uuid和雪花id）载入到聚簇索引(innodb默认的索引类型)以后,有时候会需要做一次OPTIMEIZE TABLE来重建表并优化页的填充，这将又需要一定的时间消耗。</p><p>结论：使用innodb应该尽可能的按主键的自增顺序插入，并且尽可能使用单调的增加的聚簇键的值来插入新行。</p><h5 id="2-3-使用自增id的缺点"><a href="#2-3-使用自增id的缺点" class="headerlink" title="2.3.使用自增id的缺点"></a>2.3.使用自增id的缺点</h5><p>那么使用自增的id就完全没有坏处了吗？并不是，自增id也会存在以下几点问题：</p><p>①别人一旦爬取你的数据库,就可以根据数据库的自增id获取到你的业务增长信息，很容易分析出你的经营情况</p><p>②对于高并发的负载，innodb在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点，因为所有的插入都发生在这里，并发插入会导致间隙锁竞争</p><p>③Auto_Increment锁机制会造成自增锁的抢夺,有一定的性能损失</p><h6 id="附：Auto-increment的锁争抢问题，如果要改善需要调优innodb-autoinc-lock-mode的配置"><a href="#附：Auto-increment的锁争抢问题，如果要改善需要调优innodb-autoinc-lock-mode的配置" class="headerlink" title="附：Auto_increment的锁争抢问题，如果要改善需要调优innodb_autoinc_lock_mode的配置"></a>附：Auto_increment的锁争抢问题，如果要改善需要调优innodb_autoinc_lock_mode的配置</h6><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>本篇博客首先从开篇的提出问题,建表到使用jdbcTemplate去测试不同id的生成策略在大数据量的数据插入表现，然后分析了id的机制不同在mysql的索引结构以及优缺点，深入的解释了为何uuid和随机不重复id在数据插入中的性能损耗，详细的解释了这个问题。</p><p>在实际的开发中还是根据mysql的官方推荐最好使用自增id，mysql博大精深，内部还有很多值得优化的点需要我们学习。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永远不要在MySQL中使用UTF-8</title>
      <link href="/2021/03/19/Database/%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%9C%A8MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8UTF-8/"/>
      <url>/2021/03/19/Database/%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%9C%A8MySQL%E4%B8%AD%E4%BD%BF%E7%94%A8UTF-8/</url>
      
        <content type="html"><![CDATA[<p>最近我遇到了一个bug，我试着通过Rails在以“utf8”编码的MariaDB中保存一个UTF-8字符串，然后出现了一个离奇的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Incorrectstring value:‘\xF0\x9F\x98\x83 &lt;…’ for column ‘summary’ at row 1</span><br></pre></td></tr></table></figure><p>我用的是UTF-8编码的客户端，服务器也是UTF-8编码的，数据库也是，就连要保存的这个字符串“ &lt;…”也是合法的UTF-8。</p><p>问题的症结在于，MySQL的“utf8”实际上不是真正的UTF-8。</p><p>“utf8”只支持每个字符最多三个字节，而真正的UTF-8是每个字符最多四个字节。</p><p>MySQL一直没有修复这个bug，他们在2010年发布了一个叫作“utf8mb4”的字符集，绕过了这个问题。</p><p>当然，他们并没有对新的字符集广而告之（可能是因为这个bug让他们觉得很尴尬），以致于现在网络上仍然在建议开发者使用“utf8”，但这些建议都是错误的。</p><p>简单概括如下：</p><p>1.MySQL的“utf8mb4”是真正的“UTF-8”。</p><p>2.MySQL的“utf8”是一种“专属的编码”，它能够编码的Unicode字符并不多。</p><p>我要在这里澄清一下：所有在使用“utf8”的MySQL和MariaDB用户都应该改用“utf8mb4”，永远都不要再使用“utf8”。</p><h3 id="那么什么是编码？什么是UTF-8？"><a href="#那么什么是编码？什么是UTF-8？" class="headerlink" title="那么什么是编码？什么是UTF-8？"></a>那么什么是编码？什么是UTF-8？</h3><p>我们都知道，计算机使用0和1来存储文本。比如字符“C”被存成“01000011”，那么计算机在显示这个字符时需要经过两个步骤：</p><p>1.计算机读取“01000011”，得到数字67，因为67被编码成“01000011”。</p><p>2.计算机在Unicode字符集中查找67，找到了“C”。</p><p>同样的：</p><p>1.我的电脑将“C”映射成Unicode字符集中的67。</p><p>2.我的电脑将67编码成“01000011”，并发送给Web服务器。</p><p>几乎所有的网络应用都使用了Unicode字符集，因为没有理由使用其他字符集。</p><p>Unicode字符集包含了上百万个字符。最简单的编码是UTF-32，每个字符使用32位。这样做最简单，因为一直以来，计算机将32位视为数字，而计算机最在行的就是处理数字。但问题是，这样太浪费空间了。</p><p>UTF-8可以节省空间，在UTF-8中，字符“C”只需要8位，一些不常用的字符，比如“”需要32位。其他的字符可能使用16位或24位。一篇类似本文这样的文章，如果使用UTF-8编码，占用的空间只有UTF-32的四分之一左右。</p><p>MySQL的“utf8”字符集与其他程序不兼容，它所谓的“”，可能真的是一坨……</p><h3 id="MySQL简史"><a href="#MySQL简史" class="headerlink" title="MySQL简史"></a>MySQL简史</h3><p>为什么MySQL开发者会让“utf8”失效？我们或许可以从提交日志中寻找答案。</p><p>MySQL从4.1版本开始支持UTF-8，也就是2003年，而今天使用的UTF-8标准（RFC 3629）是随后才出现的。</p><p>旧版的UTF-8标准（RFC 2279）最多支持每个字符6个字节。2002年3月28日，MySQL开发者在第一个MySQL 4.1预览版中使用了RFC 2279。</p><p>同年9月，他们对MySQL源代码进行了一次调整：“UTF8现在最多只支持3个字节的序列”。</p><p>是谁提交了这些代码？他为什么要这样做？这个问题不得而知。在迁移到Git后（MySQL最开始使用的是BitKeeper），MySQL代码库中的很多提交者的名字都丢失了。2003年9月的邮件列表中也找不到可以解释这一变更的线索。</p><p>不过我可以试着猜测一下。</p><p>2002年，MySQL做出了一个决定：如果用户可以保证数据表的每一行都使用相同的字节数，那么MySQL就可以在性能方面来一个大提升。为此，用户需要将文本列定义为“CHAR”，每个“CHAR”列总是拥有相同数量的字符。如果插入的字符少于定义的数量，MySQL就会在后面填充空格，如果插入的字符超过了定义的数量，后面超出部分会被截断。</p><p>MySQL开发者在最开始尝试UTF-8时使用了每个字符6个字节，CHAR(1)使用6个字节，CHAR(2)使用12个字节，并以此类推。</p><p>应该说，他们最初的行为才是正确的，可惜这一版本一直没有发布。但是文档上却这么写了，而且广为流传，所有了解UTF-8的人都认同文档里写的东西。</p><p>不过很显然，MySQL开发者或厂商担心会有用户做这两件事：</p><p>1.使用CHAR定义列（在现在看来，CHAR已经是老古董了，但在那时，在MySQL中使用CHAR会更快，不过从2005年以后就不是这样子了）。</p><p>2.将CHAR列的编码设置为“utf8”。</p><p>我的猜测是MySQL开发者本来想帮助那些希望在空间和速度上双赢的用户，但他们搞砸了“utf8”编码。</p><p>所以结果就是没有赢家。那些希望在空间和速度上双赢的用户，当他们在使用“utf8”的CHAR列时，实际上使用的空间比预期的更大，速度也比预期的慢。而想要正确性的用户，当他们使用“utf8”编码时，却无法保存像“”这样的字符。</p><p>在这个不合法的字符集发布了之后，MySQL就无法修复它，因为这样需要要求所有用户重新构建他们的数据库。最终，MySQL在2010年重新发布了“utf8mb4”来支持真正的UTF-8。</p><h3 id="为什么这件事情会让人如此抓狂"><a href="#为什么这件事情会让人如此抓狂" class="headerlink" title="为什么这件事情会让人如此抓狂"></a>为什么这件事情会让人如此抓狂</h3><p>因为这个问题，我整整抓狂了一个礼拜。我被“utf8”愚弄了，花了很多时间才找到这个bug。但我一定不是唯一的一个，网络上几乎所有的文章都把“utf8”当成是真正的UTF-8。</p><p>“utf8”只能算是个专有的字符集，它给我们带来了新问题，却一直没有得到解决。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你在使用MySQL或MariaDB，不要用“utf8”编码，改用“utf8mb4”。这里（ <a href="https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4" target="_blank" rel="noopener">https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4</a> ）提供了一个指南用于将现有数据库的字符编码从“utf8”转成“utf8mb4”。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL幻读详解</title>
      <link href="/2021/03/19/Database/MySQL%E5%B9%BB%E8%AF%BB%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/03/19/Database/MySQL%E5%B9%BB%E8%AF%BB%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h3><blockquote><p>The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.</p></blockquote><p>上面这句话摘自MySQL的官方手册。它只说明了读会读到上一次没有返回的记录，看起来是幻影一般。如果你理解到这里，那么恭喜你，你会遇到各种困惑。 其实幻读的现象远不止于此，更不仅仅只是两次「读」，第二次「读」来发现有幻觉。</p><h3 id="MySQL的隔离级别"><a href="#MySQL的隔离级别" class="headerlink" title="MySQL的隔离级别"></a>MySQL的隔离级别</h3><p>MySQL的InnoDb存储引擎默认的隔离级别是REPEATABLE-READ，即可重复读。 那什么是「可重复读」呢，简单来说就是一个事务里的两个相同条件的查询查到的结果应该是一致的，即结果是「可以重复读到的」，所以就解决了「幻读」。</p><p>OK，听起来很简单，一个隔离级别就可以搞定了，但是内部的机制和原理并不简单，并且有些概念的作用可能大家并不知道具体解决了什么问题。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><h4 id="MVCC的原理"><a href="#MVCC的原理" class="headerlink" title="MVCC的原理"></a>MVCC的原理</h4><p>MVCC(Multi-Version Concurrency Control多版本并发控制)：</p><ul><li>MVCC每次更新操作都会复制一条新的记录，新纪录的创建时间为当前事务id</li><li>优势为读不加锁，读写不冲突</li><li>InnoDb存储引擎中，每行数据包含了一些隐藏字段 DATA_TRX_ID，DATA_ROLL_PTR，DB_ROW_ID，DELETE BIT</li><li>DATA_TRX_ID 字段记录了数据的创建和删除时间，这个时间指的是对数据进行操作的事务的id</li><li>DATA_ROLL_PTR 指向当前数据的undo log记录，回滚数据就是通过这个指针</li><li>DELETE BIT位用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除。真正意义的删除是在mysql进行数据的GC，清理历史版本数据的时候。</li></ul><p>具体的DML：</p><ul><li>INSERT：创建一条新数据，DB_TRX_ID中的创建时间为当前事务id，DB_ROLL_PT为NULL</li><li>UPDATE：将当前行的DB_TRX_ID中的删除时间设置为当前事务id，DELETE BIT设置为1</li><li>DELETE：复制了一行，新行的DB_TRX_ID中的创建时间为当前事务id，删除时间为空，DB_ROLL_PT指向了上一个版本的记录，事务提交后DB_ROLL_PT置为NULL</li></ul><p>可知，为了提高并发度，InnoDb提供了这个「非锁定读」，即不需要等待访问行上的锁释放，读取行的一个快照即可。 既然是多版本读，那么肯定读不到隔壁事务的新插入数据了，所以解决了幻读。</p><h4 id="MVCC与隔离级别"><a href="#MVCC与隔离级别" class="headerlink" title="MVCC与隔离级别"></a>MVCC与隔离级别</h4><ul><li>Read Uncommitted每次都读取记录的最新版本，会出现脏读，未实现MVCC</li><li>Serializable对所有读操作都加锁，读写发生冲突，不会使用MVCC</li><li>SELECT<ul><li>(RR级别)InnoDb检查每行数据，确保它们符合两个标准：</li><li>只查找创建时间早于当前事务id的记录，这确保当前事务读取的行都是事务之前已经存在的，或者是由当前事务创建或修改的行</li><li>行的DELETE BIT为1时，查找删除时间晚于当前事务id的记录，确定了当前事务开始之前，行没有被删除</li><li>(RC级别)每次重新计算read view，read view的范围为InnoDb中最大的事务id，为避免脏读读取的是DB_ROLL_PT指向的记录</li></ul></li></ul><p>就这么简单吗？ 其实幻读有很多种出现形式，简单的SELECT不加条件的查询在RR下肯定是读不到隔壁事务提交的数据的。但是仍然可能在执行INSERT/UPDATE时遇到幻读现象。因为SELECT 不加锁的快照读行为是无法限制其他事务对新增重合范围的数据的插入的。</p><p>所以还要引入第二个机制。</p><h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p>其实更多的幻读现象是通过写操作来发现的，如SELECT了3条数据，UPDATE的时候可能返回了4个成功结果，或者INSERT某条不在的数据时忽然报错说唯一索引冲突等。</p><p>首先来了解一下InnoDb的锁机制，InnoDB有三种行锁：</p><ul><li>Record Lock：单个行记录上的锁</li><li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</li><li>Next-Key Lock：前两个锁的加和，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题</li></ul><p>如果是带排他锁操作（除了INSERT/UPDATE/DELETE这种，还包括SELECT FOR UPDATE/LOCK IN SHARE MODE等），它们默认都在操作的记录上加了Next-Key Lock。只有使用了这里的操作后才会在相应的记录周围和记录本身加锁，即Record Lock + Gap Lock，所以会导致有冲突操作的事务阻塞进而超时失败。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>隔离级别越高并发度越差，性能越差，虽然MySQL默认的是RR，但是如果业务不需要严格的没有幻读现象，是可以降低为RC的或修改配置innodb_locks_unsafe_for_binlog为1 来避免Gap Lock的。 注意有的时候MySQL会自动对Next-Key Lock进行优化，退化为只加Record Lock，不加Gap Lock，如相关条件字段为主键时直接加Record Lock。</p><h3 id="REPEATABLE-READ的误解"><a href="#REPEATABLE-READ的误解" class="headerlink" title="REPEATABLE-READ的误解"></a>REPEATABLE-READ的误解</h3><h4 id="误解零"><a href="#误解零" class="headerlink" title="误解零"></a>误解零</h4><blockquote><p>凡是在REPEATABLE-READ中执行的语句均不会遇到幻读现象。</p></blockquote><p>这个显然是错误的。REPEATABLE-READ只是有机制可以用来防止幻读的发生，但如果你没有「使用」或「激活」它相关机制，你仍然会遇到幻读现象。</p><h4 id="误解一"><a href="#误解一" class="headerlink" title="误解一"></a>误解一</h4><blockquote><p>REPEATABLE-READ肯定不会读到隔壁事务已经提交的数据，即使某个数据已经由隔壁事务提交，当前事务插入不会报错，否则就是发生了幻读。</p></blockquote><p>简单来说前半句话是对的，后半句有什么问题呢？可REPEATABLE-READ中如何「读」是我们自己来写SELECT 的，如果不加锁则属于快照读，当前事务读不到的数据并不一定是不存在的，如果已经存在对应的数据，那么当前事务尝试插入的时候是可能会失败的。 而插入失败的原因可能是因为主键冲突导致数据库报异常，跟隔离级别无直接关系。任何隔离级别下插入已经存在的数据都会报错。</p><p>一句话，看不到并不代表没有，并不代表可以自以为然的插入无忧。</p><h4 id="误解二"><a href="#误解二" class="headerlink" title="误解二"></a>误解二</h4><blockquote><p>REPEATABLE-READ的事务里查不到的数据一定是不存在的，所以我可以放心插入，100%成功。</p></blockquote><p>这个观点也是错的，查不到只能说明当前事务里读不到，并不代表此时其他事务没有插入这样的数据。 如何保证判断某个数据不存在以后其他事务也不会插入成功？答案是上Next-Key Lock。不上锁是无法阻止其他事务插入的。</p><blockquote><p>SELECT * FROM table1 WHERE id &gt;100</p></blockquote><p>上面这个语句在事务里判断后如果不存在数据是无法保证其他事务插入符合条件的数据的，需要加锁</p><blockquote><p>SELECT * FROM table1 WHERE id &gt;100 FOR UPDATE;</p></blockquote><p>此时如果有隔壁事务尝试插入大于100的id的数据则会等待当前事务释放锁，直到超时后中断当前事务。</p><blockquote><p>(waiting for lock … then timeout) ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</p></blockquote><p>但是如果当前事务使用的加锁的条件仅仅是某一个行锁的话最多会在前后加Next-Key Lock，影响范围较小，但仍然可能阻塞其他事务的插入，如恰好新数据的位置被GAP Lock锁住了，那只能等待当前事务释放锁了。</p><p>说了这么多，有一点要注意，就是这个Next-Key Lock一定是在REPEATABLE-READ下才有，READ-COMMITTED是不存在的。</p><blockquote><p>To prevent phantoms, InnoDB uses an algorithm called next-key locking that combines index-row locking with gap locking. You can use next-key locking to implement a uniqueness check in your application: If you read your data in share mode and do not see a duplicate for a row you are going to insert, then you can safely insert your row and know that the next-key lock set on the successor of your row during the read prevents anyone meanwhile inserting a duplicate for your row. Thus, the next-key locking enables you to “lock” the nonexistence of something in your table.</p></blockquote><p>即InnoDb在REPEATABLE-READ下提供Next-Key Lock机制，但是需要业务自己去加锁，如果不加锁，只是简单的SELECT查询，是无法限制并行事务的插入的。</p><h4 id="误解三"><a href="#误解三" class="headerlink" title="误解三"></a>误解三</h4><blockquote><p>凡是REPEATABLE-READ中的读都无法读取最新的数据。</p></blockquote><p>这个观点也是错误的，虽然我们读取的记录都是可重复读取的，但是如果你想读取最新的记录可以用加锁的方式读。</p><blockquote><p>If you want to see the “freshest” state of the database, you should use either the READ COMMITTED isolation level or a locking read:</p></blockquote><p>以下任意一种均：</p><ul><li>SELECT * FROM table1 LOCK IN SHARE MODE;</li><li>SELECT * FROM table1 FOR UPDATE;</li></ul><p>但这里要说明的是这样做跟SERIALIZABLE没有什么区别，即读也加了锁，性能大打折扣。</p><h4 id="误解四"><a href="#误解四" class="headerlink" title="误解四"></a>误解四</h4><blockquote><p>如果使用了当前读加了锁，但是锁的行并不存在则不会阻止隔壁事务插入符合条件的数据。</p></blockquote><p>其实记录存在与否和事务加锁成功与否无关，如SELECT * FROM user WHERE id = 5 FOR UPDATE，此时id=5的记录不存在，隔壁事务仍然无法插入记录（假设当前自增的主键id已经是4了）。因为锁定的是索引，故记录实体存在与否没关系。</p><h4 id="误解五"><a href="#误解五" class="headerlink" title="误解五"></a>误解五</h4><blockquote><p>MySQL中的幻读只有在读的时候才会发生，读这里特指SELECT操作。</p></blockquote><p>其实INSERT也是隐式的读取，只不过是在MySQL的机制中读取的，插入数据也是要先读取一下有没有主键冲突才能决定是否执行插入的。 不可重复读侧重「读-读」，而幻读侧重「读-写」，用写来证实读的是幻影。为啥幻读不是侧重「读-读」呢？因为MVCC保证了一个事务是不可能读到另外一个事务的新插入数据的，所以这种场景下不会发生幻读。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cherry-pick一个可以提高开发效率的命令</title>
      <link href="/2021/02/24/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/cherry-pick%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/02/24/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/cherry-pick%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>各位码农朋友们一定有碰到过这样的情况：在develop分支上辛辛苦苦撸了一通代码后开发出功能模块A，B，C，这时老板过来说，年青人，我们现在先上线功能模块A，B。你一定心里一万只草泥马奔腾而过，但为了混口饭吃必须得按老板的意思办事啊。</p><p>怎么办？一个办法就是，重新建一个分支，然后再把功能模块C回退，留下功能模块A，B。这种做法不是不行，但是有更好的办法，那就是git所提供的cherry-pick功能。</p><p>cherry-pick类似于一个定制化的merge，它可以把其它分支上的commit一个个摘下来，合并到当前分支。</p><p>废话不多说，直接上实例。</p><p>比如我现在有个文件a.c，我在develop分支完成了三个功能模块：feature A，feature B，feature C。如下图：</p><p><img src="/2021/02/24/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/cherry-pick%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%91%BD%E4%BB%A4/01.jpeg" alt="Image zoo"></p><p>现在，坑爹的老板只要feature A，feature B，我们现在用cherry-pick命令直接把feature A，feature B的提交合并到master分支里，如下操作：</p><p><img src="/2021/02/24/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/cherry-pick%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%91%BD%E4%BB%A4/02.jpeg" alt="Image zoo"></p><p>可以看到，功能模块feature A，feature B已经被合并到master分支里。请注意，合并到master分支里的提交哈希值发生了改变，与原来的不同。</p><p>可以看出，cherry-pick命令使用方法很简单，即：</p><p><code>git cherry-pick commitID</code></p><p>刚刚是一个个提交cherry-pick到master分支，但如果有100个commit要合并到master分支呢？总不能这样一个个操作吧？git一样帮你想到了，它提供了一个区间操作方法。具体来讲是这样的：</p><p><code>git cherry-pick commit1..commit100</code></p><p>但是要注意，这是一个左开右闭的操作，也就是说，commit1不会被合并到master分支，而commit100则会。这样的话上面的需求可以如下操作来实现：</p><p><img src="/2021/02/24/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/cherry-pick%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%91%BD%E4%BB%A4/03.jpeg" alt="Image zoo"></p><p>注意：上面讲到cherry-pick命令每拣选一个commit就会提交一次生成一个新的commit id。 如果我们想让每个commit 拣选后暂缓提交，等到所有commit都拣选完成后，自己手动commit，应该怎么办呢？答案是用-n 选项：</p><p><img src="/2021/02/24/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/cherry-pick%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%91%BD%E4%BB%A4/04.jpeg" alt="Image zoo"></p>]]></content>
      
      
      <categories>
          
          <category> 项目工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StackOverflowError与OutOfMemoryError</title>
      <link href="/2021/02/20/JVM/StackOverflowError%E4%B8%8EOutOfMemoryError/"/>
      <url>/2021/02/20/JVM/StackOverflowError%E4%B8%8EOutOfMemoryError/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文基于 Java 15</p></blockquote><p>StackOverflowError 与 OutOfMemoryError 是两个老生常谈的 Java 错误。Java 中的虚拟机错误 VirtualMachineError 包括以下四种：</p><p><img src="/2021/02/20/JVM/StackOverflowError%E4%B8%8EOutOfMemoryError/01.png" alt="Image png"></p><p>我们比较关心的就是 StackOverflowError 与 OutOfMemoryError，剩下的 InternalError 一般是内部使用错误，UnknownError 是虚拟机发生未知异常，这两种我们这里不讨论。</p><h4 id="虚拟机规范中的-StackOverflowError-与-OutOfMemoryError"><a href="#虚拟机规范中的-StackOverflowError-与-OutOfMemoryError" class="headerlink" title="虚拟机规范中的 StackOverflowError 与 OutOfMemoryError"></a>虚拟机规范中的 StackOverflowError 与 OutOfMemoryError</h4><p>参考 Java 虚拟机规范官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">Run-Time Data Areas</a>，可以知道，在如下情况下，会抛出这两种错误：</p><ul><li>当某次线程运行计算时，需要占用的 Java 虚拟机栈（Java Virtual Machine Stack）大小，也就是 Java 线程栈大小，超过规定大小时，抛出 StackOverflowError</li><li>如果 Java 虚拟机栈大小可以动态扩容，发生扩容时发现内存不足，或者新建Java 虚拟机栈时发现内存不足，抛出 OutOfMemoryError</li><li>当所需要的堆（heap）内存大小不足时，抛出 OutOfMemoryError</li><li>当方法区（Method Area）大小不够分配时，抛出 OutOfMemoryError</li><li>当创建一个类或者接口时，运行时常量区剩余大小不够时，抛出 OutOfMemoryError</li><li>本地方法栈（Native Method Stack）大小不足时，抛出 StackOverflowError</li><li>本地方法栈（Native Method Stack）扩容时发现内存不足，或者新建本地方法栈发现内存不足，抛出 OutOfMemoryError</li></ul><h4 id="Hotspot-JVM-的实现"><a href="#Hotspot-JVM-的实现" class="headerlink" title="Hotspot JVM 的实现"></a>Hotspot JVM 的实现</h4><p>为了进一步搞清楚 StackOverflowError 与 OutOfMemoryError，我们来看具体实现。一般的 JVM 采用的都是官网的 HotSpot JVM，我们这里就用 Hotspot JVM 的实现来说明。</p><h4 id="JVM-内存包括什么"><a href="#JVM-内存包括什么" class="headerlink" title="JVM 内存包括什么"></a>JVM 内存包括什么</h4><p>我们一般通过两个工具 pmap 还有 jcmd 中的 VM.native_memory 命令去查看 Java 进程内存占用，由于 pmap 命令有点复杂而且很多内存映射是 anon 的，这里采用 jcmd 中的 VM.native_memory 命令，去看一下 JVM 内存的每一部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Native Memory Tracking:</span><br><span class="line"></span><br><span class="line">Total: reserved=6308603KB, committed=4822083KB</span><br><span class="line">-                 Java Heap (reserved=4194304KB, committed=4194304KB)</span><br><span class="line">                            (mmap: reserved=4194304KB, committed=4194304KB) </span><br><span class="line"> </span><br><span class="line">-                     Class (reserved=1161041KB, committed=126673KB)</span><br><span class="line">                            (classes #21662)</span><br><span class="line">                            (  instance classes #20542, array classes #1120)</span><br><span class="line">                            (malloc=3921KB #64030) </span><br><span class="line">                            (mmap: reserved=1157120KB, committed=122752KB) </span><br><span class="line">                            (  Metadata:   )</span><br><span class="line">                            (    reserved=108544KB, committed=107520KB)</span><br><span class="line">                            (    used=105411KB)</span><br><span class="line">                            (    free=2109KB)</span><br><span class="line">                            (    waste=0KB =0.00%)</span><br><span class="line">                            (  Class space:)</span><br><span class="line">                            (    reserved=1048576KB, committed=15232KB)</span><br><span class="line">                            (    used=13918KB)</span><br><span class="line">                            (    free=1314KB)</span><br><span class="line">                            (    waste=0KB =0.00%)</span><br><span class="line"> </span><br><span class="line">-                    Thread (reserved=355251KB, committed=86023KB)</span><br><span class="line">                            (thread #673)</span><br><span class="line">                            (stack: reserved=353372KB, committed=84144KB)</span><br><span class="line">                            (malloc=1090KB #4039) </span><br><span class="line">                            (arena=789KB #1344)</span><br><span class="line"> </span><br><span class="line">-                      Code (reserved=252395KB, committed=69471KB)</span><br><span class="line">                            (malloc=4707KB #17917) </span><br><span class="line">                            (mmap: reserved=247688KB, committed=64764KB) </span><br><span class="line"> </span><br><span class="line">-                        GC (reserved=199635KB, committed=199635KB)</span><br><span class="line">                            (malloc=11079KB #29639) </span><br><span class="line">                            (mmap: reserved=188556KB, committed=188556KB) </span><br><span class="line"> </span><br><span class="line">-                  Compiler (reserved=2605KB, committed=2605KB)</span><br><span class="line">                            (malloc=2474KB #2357) </span><br><span class="line">                            (arena=131KB #5)</span><br><span class="line"> </span><br><span class="line">-                  Internal (reserved=3643KB, committed=3643KB)</span><br><span class="line">                            (malloc=3611KB #8683) </span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB) </span><br><span class="line"> </span><br><span class="line">-                     Other (reserved=67891KB, committed=67891KB)</span><br><span class="line">                            (malloc=67891KB #2859) </span><br><span class="line"> </span><br><span class="line">-                    Symbol (reserved=26220KB, committed=26220KB)</span><br><span class="line">                            (malloc=22664KB #292684) </span><br><span class="line">                            (arena=3556KB #1)</span><br><span class="line"> </span><br><span class="line">-    Native Memory Tracking (reserved=7616KB, committed=7616KB)</span><br><span class="line">                            (malloc=585KB #8238) </span><br><span class="line">                            (tracking overhead=7031KB)</span><br><span class="line"> </span><br><span class="line">-               Arena Chunk (reserved=10911KB, committed=10911KB)</span><br><span class="line">                            (malloc=10911KB) </span><br><span class="line"> </span><br><span class="line">-                   Tracing (reserved=25937KB, committed=25937KB)</span><br><span class="line">                            (malloc=25937KB #8666) </span><br><span class="line"> </span><br><span class="line">-                   Logging (reserved=5KB, committed=5KB)</span><br><span class="line">                            (malloc=5KB #196) </span><br><span class="line"> </span><br><span class="line">-                 Arguments (reserved=18KB, committed=18KB)</span><br><span class="line">                            (malloc=18KB #486) </span><br><span class="line"> </span><br><span class="line">-                    Module (reserved=532KB, committed=532KB)</span><br><span class="line">                            (malloc=532KB #3579) </span><br><span class="line"> </span><br><span class="line">-              Synchronizer (reserved=591KB, committed=591KB)</span><br><span class="line">                            (malloc=591KB #4777) </span><br><span class="line"> </span><br><span class="line">-                 Safepoint (reserved=8KB, committed=8KB)</span><br><span class="line">                            (mmap: reserved=8KB, committed=8KB)</span><br></pre></td></tr></table></figure><p>这里的 <a href="https://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener">mmap</a>，<a href="https://man7.org/linux/man-pages/man3/malloc.3.html" target="_blank" rel="noopener">malloc</a> 是两种不同的内存申请分配方式，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Internal (reserved=3643KB, committed=3643KB)</span><br><span class="line">                            (malloc=3611KB #8683) </span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB)</span><br></pre></td></tr></table></figure><p>代表 Internal 一共占用 3643KB，其中3611KB是通过 malloc 方式，32KB 是通过 mmap 方式。<br>arena 是通过 malloc 方式分配的内存但是代码执行完并不释放，放入 arena chunk 中之后还会继续使用，参考：<a href="https://sourceware.org/glibc/wiki/MallocInternals" target="_blank" rel="noopener">MallocInternals</a></p><p>可以看出，Java 进程内存包括：</p><ul><li>Java Heap: 堆内存，即-Xmx限制的最大堆大小的内存。</li><li>Class：加载的类与方法信息，其实就是 metaspace，包含两部分： 一是 metadata，被-XX:MaxMetaspaceSize限制最大大小，另外是 class space，被-XX:CompressedClassSpaceSize限制最大大小</li><li>Thread：线程与线程栈占用内存，每个线程栈占用大小受-Xss限制，但是总大小没有限制。</li><li>Code：JIT 即时编译后（C1 C2 编译器优化）的代码占用内存，受-XX:ReservedCodeCacheSize限制</li><li>GC：垃圾回收占用内存，例如垃圾回收需要的 CardTable，标记数，区域划分记录，还有标记 GC Root 等等，都需要内存。这个不受限制，一般不会很大的。</li><li>Compiler：C1 C2 编译器本身的代码和标记占用的内存，这个不受限制，一般不会很大的</li><li>Internal：命令行解析，JVMTI 使用的内存，这个不受限制，一般不会很大的</li><li>Symbol: 常量池占用的大小，字符串常量池受-XX:StringTableSize个数限制，总内存大小不受限制</li><li>Native Memory Tracking：内存采集本身占用的内存大小，如果没有打开采集（那就看不到这个了，哈哈），就不会占用，这个不受限制，一般不会很大的</li><li>Arena Chunk：所有通过 arena 方式分配的内存，这个不受限制，一般不会很大的</li><li>Tracing：所有采集占用的内存，如果开启了 JFR 则主要是 JFR 占用的内存。这个不受限制，一般不会很大的</li><li>Logging，Arguments，Module，Synchronizer，Safepoint，Other，这些一般我们不会关心。</li></ul><p>除了 Native Memory Tracking 记录的内存使用，还有两种内存 <strong>Native Memory Tracking</strong> 没有记录，那就是：</p><ul><li>Direct Buffer：直接内存</li><li>MMap Buffer：文件映射内存</li></ul><h4 id="各种-StackOverflowError-与-OutOfMemoryError-场景以及定位方式"><a href="#各种-StackOverflowError-与-OutOfMemoryError-场景以及定位方式" class="headerlink" title="各种 StackOverflowError 与 OutOfMemoryError 场景以及定位方式"></a>各种 StackOverflowError 与 OutOfMemoryError 场景以及定位方式</h4><h5 id="1-StackOverflowError"><a href="#1-StackOverflowError" class="headerlink" title="1. StackOverflowError"></a>1. StackOverflowError</h5><p>调用栈过深，导致线程栈占用大小超过-Xss（或者是-XX:ThreadStackSize）的限制，如果没指定-Xss，则根据不同系统确定默认最大大小。</p><p>确定默认大小的代码请参考：</p><ul><li>windows：<a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/os/windows/os_windows.cpp" target="_blank" rel="noopener">os_windows.cpp</a></li><li>linux：<a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/os/linux/os_linux.cpp" target="_blank" rel="noopener">os_linux.cpp</a></li></ul><p>总结起来就是，32 位的系统一般是 512k，64 位的是 1024k</p><p>一般报这个错都是因为递归死循环，或者调用栈真的太深而线程栈大小不足，比如那种回调背压模型的框架，netty + reactor 这种，一般线程栈需要调大一点。</p><h5 id="2-OutOfMemoryError-Java-heap-space"><a href="#2-OutOfMemoryError-Java-heap-space" class="headerlink" title="2. OutOfMemoryError: Java heap space"></a>2. OutOfMemoryError: Java heap space</h5><p>堆内存不够用，无法分配更多内存，就会抛出这个异常。一般这种情况发生后，需要查看 heap dump，线上应用一般加上-XX: +HeapDumpOnOutOfMemoryError在OutOfMemoryError发生的时候，进行 heap dump，之后进行分析。</p><p>heap dump 查看工具一般通过 <a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">Memory Analyzer (MAT)</a></p><h5 id="3-OutOfMemoryError-unable-to-create-native-thread"><a href="#3-OutOfMemoryError-unable-to-create-native-thread" class="headerlink" title="3. OutOfMemoryError: unable to create native thread"></a>3. OutOfMemoryError: unable to create native thread</h5><p>这个在创建太多的线程，超过系统配置的极限。如Linux默认允许单个进程可以创建的线程数是1024个。</p><p>一般报这个错首先考虑不要创建那么多线程，线程池化并池子尽量同业务复用。如果实在要创建那么多线程，则考虑修改服务器配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//查看限制个数</span><br><span class="line">ulimit -u</span><br><span class="line"></span><br><span class="line">//编辑修改</span><br><span class="line">vim /etc/security/limits.d/90-nproc.conf</span><br></pre></td></tr></table></figure><h5 id="4-OutOfMemoryError-GC-Overhead-limit-exceeded"><a href="#4-OutOfMemoryError-GC-Overhead-limit-exceeded" class="headerlink" title="4. OutOfMemoryError: GC Overhead limit exceeded"></a>4. OutOfMemoryError: GC Overhead limit exceeded</h5><p>默认情况下，并不是等堆内存耗尽，才会报 OutOfMemoryError，而是如果 JVM 觉得 GC 效率不高，也会报这个错误。</p><p>那么怎么评价 GC 效率不高呢？来看下源码：<a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/share/gc/shared/gcOverheadChecker.cpp" target="_blank" rel="noopener">gcOverheadChecker.cpp</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void GCOverheadChecker::check_gc_overhead_limit(GCOverheadTester* time_overhead,</span><br><span class="line">                                                GCOverheadTester* space_overhead,</span><br><span class="line">                                                bool is_full_gc,</span><br><span class="line">                                                GCCause::Cause gc_cause,</span><br><span class="line">                                                SoftRefPolicy* soft_ref_policy) &#123;</span><br><span class="line"></span><br><span class="line">  // 忽略显式gc命令，比如System.gc()，或者通过JVMTI命令的gc，或者通过jcmd命令的gc</span><br><span class="line">  if (GCCause::is_user_requested_gc(gc_cause) ||</span><br><span class="line">      GCCause::is_serviceability_requested_gc(gc_cause)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool print_gc_overhead_limit_would_be_exceeded = false;</span><br><span class="line">  if (is_full_gc) &#123;</span><br><span class="line">    //如果gc时间过长，并且gc回收的空间还是不多</span><br><span class="line">    //gc时间占用98%以上为gc时间过长，可以通过 -XX:GCTimeLimit= 配置，参考gc_globals.hpp: GCTimeLimit</span><br><span class="line">    //回收空间小于2%为gc回收空间不多，可以通过  -XX:GCHeapFreeLimit= 配置，参考gc_globals.hpp: GCHeapFreeLimit</span><br><span class="line">    if (time_overhead-&gt;is_exceeded() &amp;&amp; space_overhead-&gt;is_exceeded()) &#123;</span><br><span class="line">      _gc_overhead_limit_count++;</span><br><span class="line">      //如果UseGCOverheadLimit这个状态位为开启</span><br><span class="line">      //默认情况下，是开启的，可以通过启动参数-XX:-UseGCOverheadLimit关闭，参考：gc_globals.hpp: UseGCOverheadLimit</span><br><span class="line">      if (UseGCOverheadLimit) &#123;</span><br><span class="line">        //如果超过规定次数，这个次数默认不可配置，必须开启develop编译jdk才能配置，参考gc_globals.hpp: GCOverheadLimitThreshold</span><br><span class="line">        if (_gc_overhead_limit_count &gt;= GCOverheadLimitThreshold)&#123;</span><br><span class="line">          //设置状态位，准备抛出OOM</span><br><span class="line">          set_gc_overhead_limit_exceeded(true);</span><br><span class="line">          //清空计数</span><br><span class="line">          reset_gc_overhead_limit_count();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          //如果还没到达次数，但是也快到达的时候，清空所有的软引用</span><br><span class="line">          bool near_limit = gc_overhead_limit_near();</span><br><span class="line">          if (near_limit) &#123;</span><br><span class="line">            soft_ref_policy-&gt;set_should_clear_all_soft_refs(true);</span><br><span class="line">            log_trace(gc, ergo)(&quot;Nearing GC overhead limit, will be clearing all SoftReference&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //需要打印日志，提示GC效率不高</span><br><span class="line">      print_gc_overhead_limit_would_be_exceeded = true;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Did not exceed overhead limits</span><br><span class="line">      reset_gc_overhead_limit_count();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (UseGCOverheadLimit) &#123;</span><br><span class="line">    if (gc_overhead_limit_exceeded()) &#123;</span><br><span class="line">      log_trace(gc, ergo)(&quot;GC is exceeding overhead limit of &quot; UINTX_FORMAT &quot;%%&quot;, GCTimeLimit);</span><br><span class="line">      reset_gc_overhead_limit_count();</span><br><span class="line">    &#125; else if (print_gc_overhead_limit_would_be_exceeded) &#123;</span><br><span class="line">      assert(_gc_overhead_limit_count &gt; 0, &quot;Should not be printing&quot;);</span><br><span class="line">      log_trace(gc, ergo)(&quot;GC would exceed overhead limit of &quot; UINTX_FORMAT &quot;%% %d consecutive time(s)&quot;,</span><br><span class="line">                          GCTimeLimit, _gc_overhead_limit_count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认配置：gc_globals.hpp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">product(bool, UseGCOverheadLimit, true,                                   \</span><br><span class="line">          &quot;Use policy to limit of proportion of time spent in GC &quot;          \</span><br><span class="line">          &quot;before an OutOfMemory error is thrown&quot;)                          \</span><br><span class="line">                                                                            \</span><br><span class="line">product(uintx, GCTimeLimit, 98,                                           \</span><br><span class="line">      &quot;Limit of the proportion of time spent in GC before &quot;             \</span><br><span class="line">      &quot;an OutOfMemoryError is thrown (used with GCHeapFreeLimit)&quot;)      \</span><br><span class="line">      range(0, 100)                                                     \</span><br><span class="line">                                                                        \</span><br><span class="line">product(uintx, GCHeapFreeLimit, 2,                                        \</span><br><span class="line">      &quot;Minimum percentage of free space after a full GC before an &quot;     \</span><br><span class="line">      &quot;OutOfMemoryError is thrown (used with GCTimeLimit)&quot;)             \</span><br><span class="line">      range(0, 100)                                                     \</span><br><span class="line">                                                                        \</span><br><span class="line">develop(uintx, GCOverheadLimitThreshold, 5,                               \</span><br><span class="line">      &quot;Number of consecutive collections before gc time limit fires&quot;)   \</span><br><span class="line">      range(1, max_uintx)</span><br></pre></td></tr></table></figure><p>可以总结出：默认情况下，启用了 UseGCOverheadLimit，连续 5 次，碰到 GC 时间占比超过 98%，GC 回收的内存不足 2% 时，会抛出这个异常。</p><h5 id="5-OutOfMemoryError-direct-memory"><a href="#5-OutOfMemoryError-direct-memory" class="headerlink" title="5. OutOfMemoryError: direct memory"></a>5. OutOfMemoryError: direct memory</h5><p>这个是向系统申请直接内存时，如果系统可用内存不足，就会抛出这个异常，对应的源代码<a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/nio/Bits.java" target="_blank" rel="noopener">Bits.java</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void reserveMemory(long size, int cap) &#123;</span><br><span class="line">    synchronized (Bits.class) &#123;</span><br><span class="line">        if (!memoryLimitSet &amp;&amp; VM.isBooted()) &#123;</span><br><span class="line">            maxMemory = VM.maxDirectMemory();</span><br><span class="line">            memoryLimitSet = true;</span><br><span class="line">        &#125;</span><br><span class="line">        // -XX:MaxDirectMemorySize limits the total capacity rather than the</span><br><span class="line">        // actual memory usage, which will differ when buffers are page</span><br><span class="line">        // aligned.</span><br><span class="line">        if (cap &lt;= maxMemory - totalCapacity) &#123;</span><br><span class="line">            reservedMemory += size;</span><br><span class="line">            totalCapacity += cap;</span><br><span class="line">            count++;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.gc();</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">    &#125; catch (InterruptedException x) &#123;</span><br><span class="line">        // Restore interrupt status</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (Bits.class) &#123;</span><br><span class="line">        if (totalCapacity + cap &gt; maxMemory)</span><br><span class="line">            throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</span><br><span class="line">        reservedMemory += size;</span><br><span class="line">        totalCapacity += cap;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 DirectByteBuffer 中，首先向 Bits 类申请额度，Bits 类有一个全局的 totalCapacity 变量，记录着全部 DirectByteBuffer 的总大小，每次申请，都先看看是否超限,堆外内存的限额默认与堆内内存(由 -Xmx 设定)相仿，可用 -XX:MaxDirectMemorySize 重新设定。</p><p>如果不指定，该参数的默认值为 Xmx 的值减去1个 Survior 区的值。 如设置启动参数 -Xmx20M -Xmn10M -XX：SurvivorRatio=8,那么申请 20M-1M=19M 的DirectMemory<br>如果已经超限，会主动执行 Sytem.gc()，期待能主动回收一点堆外内存。System.gc() 会触发一个 full gc，当然前提是你没有显示的设置 -XX:+DisableExplicitGC 来禁用显式GC。并且你需要知道，调用 System.gc() 并不能够保证 full gc 马上就能被执行。然后休眠一百毫秒，看看 totalCapacity 降下来没有，如果内存还是不足，就抛出 OOM 异常。如果额度被批准，就调用大名鼎鼎的sun.misc.Unsafe去分配内存,返回内存基地址</p><p>在发生这种异常时，一般通过 JMX 的java.nio.BufferPool.direct里面的属性去监控直接内存的变化以及使用（其实就是 BufferPoolMXBean ），来定位问题。</p><p><img src="/2021/02/20/JVM/StackOverflowError%E4%B8%8EOutOfMemoryError/02.png" alt="Image png"></p><h5 id="6-OutOfMemoryError-map-failed"><a href="#6-OutOfMemoryError-map-failed" class="headerlink" title="6. OutOfMemoryError: map failed"></a>6. OutOfMemoryError: map failed</h5><p>这个是 File MMAP（文件映射内存）时，如果系统内存不足，就会抛出这个异常，对应的源代码是：</p><ul><li>Windows：<a href="https://github.com/openjdk/jdk/blob/master/src/java.base/unix/native/libnio/ch/FileDispatcherImpl.c" target="_blank" rel="noopener">FileDispatcherImpl.c</a></li><li>Linux：<a href="https://github.com/openjdk/jdk/blob/master/src/java.base/windows/native/libnio/ch/FileDispatcherImpl.c" target="_blank" rel="noopener">FileDispatcherImpl.c</a></li></ul><p>以 Linux 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line">Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this,</span><br><span class="line">                                     jint prot, jlong off, jlong len)</span><br><span class="line">&#123;</span><br><span class="line">    void *mapAddress = 0;</span><br><span class="line">    jobject fdo = (*env)-&gt;GetObjectField(env, this, chan_fd);</span><br><span class="line">    jint fd = fdval(env, fdo);</span><br><span class="line">    int protections = 0;</span><br><span class="line">    int flags = 0;</span><br><span class="line"></span><br><span class="line">    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) &#123;</span><br><span class="line">        protections = PROT_READ;</span><br><span class="line">        flags = MAP_SHARED;</span><br><span class="line">    &#125; else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) &#123;</span><br><span class="line">        protections = PROT_WRITE | PROT_READ;</span><br><span class="line">        flags = MAP_SHARED;</span><br><span class="line">    &#125; else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) &#123;</span><br><span class="line">        protections =  PROT_WRITE | PROT_READ;</span><br><span class="line">        flags = MAP_PRIVATE;</span><br><span class="line">    &#125;</span><br><span class="line">    //调用mmap</span><br><span class="line">    mapAddress = mmap64(</span><br><span class="line">        0,                    /* Let OS decide location */</span><br><span class="line">        len,                  /* Number of bytes to map */</span><br><span class="line">        protections,          /* File permissions */</span><br><span class="line">        flags,                /* Changes are shared */</span><br><span class="line">        fd,                   /* File descriptor of mapped file */</span><br><span class="line">        off);                 /* Offset into file */</span><br><span class="line">    //内存不足时，抛出OutOfMemoryError</span><br><span class="line">    if (mapAddress == MAP_FAILED) &#123;</span><br><span class="line">        if (errno == ENOMEM) &#123;</span><br><span class="line">            JNU_ThrowOutOfMemoryError(env, &quot;Map failed&quot;);</span><br><span class="line">            return IOS_THROWN;</span><br><span class="line">        &#125;</span><br><span class="line">        return handle(env, -1, &quot;Map failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ((jlong) (unsigned long) mapAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，考虑：</p><p>1.增加系统内存<br>2.采用文件分块，不要一次 mmap 很大的文件，也就是减少每次 mmap 文件的大小</p><h5 id="7-OutOfMemoryError-Requested-array-size-exceeds-VM-limit"><a href="#7-OutOfMemoryError-Requested-array-size-exceeds-VM-limit" class="headerlink" title="7. OutOfMemoryError: Requested array size exceeds VM limit"></a>7. OutOfMemoryError: Requested array size exceeds VM limit</h5><p>当申请的数组大小超过堆内存限制，就会抛出这个异常。</p><h5 id="8-OutOfMemoryError-Metaspace"><a href="#8-OutOfMemoryError-Metaspace" class="headerlink" title="8. OutOfMemoryError: Metaspace"></a>8. OutOfMemoryError: Metaspace</h5><p>Metadata 占用空间超限（参考上面简述 Java 内存构成， class 这一块 包含两种，一种是 metadata，一种是 class space），会抛出这个异常，那么如何查看元空间内存呢？</p><p>可以通过两个命令，这两个输出是一样的：</p><ul><li><p>jmap -clstats</p></li><li><p>jcmd GC.class_stats （这个需要启动参数： -XX:+UnlockDiagnosticVMOptions）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Index Super InstBytes KlassBytes annotations    CpAll MethodCount Bytecodes MethodAll    ROAll     RWAll     Total ClassName</span><br><span class="line">    1    -1 214348176        504           0        0           0         0         0       24       616       640 [C</span><br><span class="line">    2    -1  71683872        504           0        0           0         0         0       24       616       640 [B</span><br><span class="line">    3    -1  53085688        504           0        0           0         0         0       24       616       640 [Ljava.lang.Object;</span><br><span class="line">    4    -1  28135528        504           0        0           0         0         0       32       616       648 [Ljava.util.HashMap$Node;</span><br><span class="line">    5 17478  12582216       1440           0     7008          64      2681     39040    11232     37248     48480 java.util.ArrayList</span><br><span class="line"> .........</span><br><span class="line"> 25255    25         0        528           0      592           3        42       568      448      1448      1896 zipkin2.reporter.metrics.micrometer.MicrometerReporterMetrics$Builder</span><br><span class="line">            472572680   16436464      283592 41813040      225990   8361510  75069552 39924272 101013144 140937416 Total</span><br><span class="line">               335.3%      11.7%        0.2%    29.7%           -      5.9%     53.3%    28.3%     71.7%    100.0%</span><br><span class="line">Index Super InstBytes KlassBytes annotations    CpAll MethodCount Bytecodes MethodAll    ROAll     RWAll     Total ClassName</span><br></pre></td></tr></table></figure></li></ul><p>其中，每个指标的含义如下所示：</p><ul><li>InstBytes：实例占用大小</li><li>KlassBytes：类占用大小</li><li>annotations：注解占用大小</li><li>CpAll：常量池中占用大小</li><li>MethodCount：方法个数</li><li>Bytecodes：字节码大小</li><li>MethodAll：方法占用大小</li><li>ROAll：只读内存中内存占用</li><li>RWAll：读写内存中内存占用</li></ul><h5 id="9-OutOfMemoryError-Compressed-class-space"><a href="#9-OutOfMemoryError-Compressed-class-space" class="headerlink" title="9. OutOfMemoryError: Compressed class space"></a>9. OutOfMemoryError: Compressed class space</h5><p>class space 内存溢出导致的，和上一个异常类似，需要查看类信息统计定位问题。</p><h5 id="10-OutOfMemoryError-reason-stack-trace-with-native-method"><a href="#10-OutOfMemoryError-reason-stack-trace-with-native-method" class="headerlink" title="10. OutOfMemoryError: reason stack_trace_with_native_method"></a>10. OutOfMemoryError: reason stack_trace_with_native_method</h5><p>这个发生在 JNI 调用中，内存不足</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClassNotFoundException与NoClassDefFoundError的区别</title>
      <link href="/2021/02/20/CoreJava/ClassNotFoundException%E4%B8%8ENoClassDefFoundError%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/02/20/CoreJava/ClassNotFoundException%E4%B8%8ENoClassDefFoundError%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>ClassNotFoundException发生在装入阶段。</strong><br>当应用程序试图通过类的字符串名称，使用常规的三种方法装入类，但却找不到指定名称的类定义时就抛出该异常。</p><p>根据类加载器的可见性机制，子类加载器可以看到父类加载器加载的类，而反之则不行。所以当一个类已经被Application类加载器加载过了，然后如果想要使用Extension类加载器加载这个类，将会抛出java.lang.ClassNotFoundException异常。</p><p><strong>NoClassDefFoundError： 当目前执行的类已经编译，但是找不到它的定义时</strong></p><p>也就是说你如果编译了一个类B，在类A中调用，编译完成以后，你又删除掉B，运行A的时候那么就会出现这个错误</p><p>加载时从外存储器找不到需要的class就出现ClassNotFoundException<br>连接时从内存找不到需要的class就出现NoClassDefFoundError</p><h3 id="JDK-API里面的解释："><a href="#JDK-API里面的解释：" class="headerlink" title="JDK API里面的解释："></a>JDK API里面的解释：</h3><h5 id="1-NoClassDefFoundError"><a href="#1-NoClassDefFoundError" class="headerlink" title="1.NoClassDefFoundError"></a>1.NoClassDefFoundError</h5><p>当 Java 虚拟机或 ClassLoader 实例试图在类的定义中加载（作为通常方法调用的一部分或者作为使用 new 表达式创建的新实例的一部分），但无法找到该类的定义时，抛出此异常。<br>当前执行的类被编译时，所搜索的类定义存在，但无法再找到该定义。</p><h5 id="2-ClassNotFoundException"><a href="#2-ClassNotFoundException" class="headerlink" title="2.ClassNotFoundException"></a>2.ClassNotFoundException</h5><p>当应用程序试图使用以下方法通过字符串名加载类时，抛出该异常： </p><ul><li>Class 类中的 forName 方法。 </li><li>ClassLoader 类中的 findSystemClass 方法。 </li><li>ClassLoader 类中的 loadClass 方法。 </li></ul><p>但是没有找到具有指定名称的类的定义。从 1.4 版本开始，此异常已经更新，以符合通用的异常链机制。在构造时提供并通过 getException() 方法访问的“加载类时引发的可选异常”，现在被称为原因，它可以通过 Throwable.getCause() 方法以及与上面提到的“遗留方法”来访问。</p>]]></content>
      
      
      <categories>
          
          <category> CoreJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoreJava </tag>
            
            <tag> Exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java生产环境下问题排查</title>
      <link href="/2021/01/04/JVM/Java%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>/2021/01/04/JVM/Java%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>在生产环境中，我们无法通过断点调试、新增log、可视化工具去立马查看当前的运行状态和拿到错误信息，此时，借助Java自带的命令行工具以及相关dump分析工具以及一些小技巧，可以大大提升我们排查问题的效率</p><h2 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h2><p>下面会列出一些常用且非常有效的命令以及参数来查看运行时Java程序的信息，从而辅助你了解程序运行状态。还有大量可用的功能由其他参数提供，自行参阅<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/toc.html" target="_blank" rel="noopener">oracle文档</a></p><h3 id="查看JVM参数"><a href="#查看JVM参数" class="headerlink" title="查看JVM参数"></a>查看JVM参数</h3><p><code>jps -l</code> 查看所有正在运行的Java程序，同时显示启动类类名，获取到PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`4706 org.apache.catalina.startup.Bootstrap 5023 sun.tools.jps.Jps`</span><br></pre></td></tr></table></figure><p><code>jinfo -flags PID</code> 查看运行时进程参数与JVM参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Attaching to process ID 28987, please wait... Debugger attached successfully. Server compiler detected. JVM version is 25.171-b11 Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=132120576 -XX:MaxHeapSize=2092957696 -XX:MaxNewSize=697303040 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=44040192 -XX:OldSize=88080384 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC Command line:  -Dspring.config.location=application.properties -Dspring.profiles.active=staging`</span><br></pre></td></tr></table></figure><p><code>java -XX:+PrintFlagsFinal -version</code> 查看当前虚拟机默认JVM参数</p><h3 id="查看即时GC状态"><a href="#查看即时GC状态" class="headerlink" title="查看即时GC状态"></a>查看即时GC状态</h3><p><code>jstat -gc PID 1000 10</code> 每秒查看一次gc信息，共10次</p><p>输出比较多的参数，每个字段的解释参看 <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">` S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT    512.0  512.0   15.3   0.0    4416.0   1055.2   11372.0     7572.5   14720.0 14322.5 1664.0 1522.8     40    0.137   8      0.039    0.176`</span><br></pre></td></tr></table></figure><p>期间可能碰到提示<code>sun.jvm.hotspot.runtime.VMVersionMismatchException: Supported versions are 24.181-b01. Target VM is 25.171-b11</code>的问题，原因在于安装了多个版本，使用<code>which</code>、<code>ls -l</code>可简介定位到与当前执行Java程序相同的Java版本</p><h2 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h2><h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><p>内存泄露导致OOM？内存占用异常的高？这是生产环境常常出现的问题，Java提供dump文件供我们对内存里发生过的事情进行了记录，我们需要借助一些工具从中获取有价值的信息。</p><h4 id="导出Dump文件"><a href="#导出Dump文件" class="headerlink" title="导出Dump文件"></a>导出Dump文件</h4><ol><li>提前对Java程序加上这些<strong>参数</strong>印dump文件 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./</code></li><li>对正在运行的程序使用<strong>jmap</strong>：<code>jmap -dump:format=b,file=heap.hprof PID</code></li></ol><h4 id="分析Dump文件"><a href="#分析Dump文件" class="headerlink" title="分析Dump文件"></a>分析Dump文件</h4><p>如果Dump文件不太大的话，可以传到 <a href="http://heaphero.io/index.jsp" target="_blank" rel="noopener">http://heaphero.io/index.jsp</a> 来分析</p><p>文件比较大，且想进行更加系统的分析，推荐使用<a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">MAT</a>分析，有如下几种常用查看方式</p><ol><li>首页中的【Leak Suspects】能推测出问题所在</li><li>点击【Create a histogram from an arbitrary set of objects】查到所有对象的数量</li><li>右键点击某个对象【Merge Shortest Paths to GC Roots】-&gt; 【exclude all phantom/weak/soft etc. references】能查询到大量数量的某个对象是哪个GC ROOT引用的</li></ol><h3 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h3><p>任务长时间不退出？CPU 负载过高？很可能因为死循环或者死锁，导致某些线程一直执行不被中断，但是不报错是最烦人的，所以日志里看不到错误信息，并且又不能用dump文件分析，因为跟内存无关。这个时候就需要用线程分析工具来帮我们了。</p><h4 id="导出jstack文件"><a href="#导出jstack文件" class="headerlink" title="导出jstack文件"></a>导出jstack文件</h4><p>使用<code>jstack PID &gt; 文件</code>，如果失败请加<code>-F</code>参数，如果还失败请使用Java程序启动时使用的用户执行jstack，下面是jstack的部分输出格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`      线程名                                                              PID的16进制 &quot;http-nio-8080-Acceptor-0&quot; #17 daemon prio=5 os_prio=0 tid=0x00007fac2c4bd000 nid=0x29f4 runnable [0x00007fac192f6000]    java.lang.Thread.State: RUNNABLE（tomcat的工作线程正在运行，有NEW/RUNNABLE/BLOCKED/WAITING/TIMED_WATING/TERMINATED状态）     at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)     at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422)     at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250)     - locked &lt;0x00000000faf845a8&gt; (a java.lang.Object)     at org.apache.tomcat.util.net.NioEndpoint$Acceptor.run(NioEndpoint.java:682)     at java.lang.Thread.run(Thread.java:748)`</span><br></pre></td></tr></table></figure><p>jstack的输出可以看到所有的线程以及他们的状态，我们就可以看有哪些我们自己创建的正在运行的线程，那很可能就是那个一直在执行的线程了，此时<strong>线程名</strong>就格外重要了，所以建议创建新线程时指定有意义的线程名。当然，通过PID查找也非常方便。</p><h4 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h4><ol><li><code>top</code> 查看到哪个java程序负载高</li><li><code>top -p PID -H</code> 查看该进程所有进程的运行状态</li><li>记录下高负载的线程ID，<code>printf &quot;&amp;x&quot; PID</code>转换成16进制</li><li><code>jstack PID &gt; 文件</code></li><li>在jstack文件中用转换成16进制之后的线程ID查询线程运行堆栈</li><li>从堆栈中了解到线程在执行什么任务，并结合业务与代码判断问题所在</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coding.imooc.com/class/241.html" target="_blank" rel="noopener">https://coding.imooc.com/class/241.html</a><br><a href="https://crossoverjie.top/2018/07/08/java-senior/JVM-Troubleshoot/" target="_blank" rel="noopener">https://crossoverjie.top/2018/07/08/java-senior/JVM-Troubleshoot/</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle 指北</title>
      <link href="/2020/12/21/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/Gradle%E6%8C%87%E5%8C%97/"/>
      <url>/2020/12/21/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/Gradle%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<h4 id="一、Gradle项目目录结构"><a href="#一、Gradle项目目录结构" class="headerlink" title="一、Gradle项目目录结构"></a>一、Gradle项目目录结构</h4><ul><li>.gradle    gradle项目产生文件（自动编译工具产生的文件）</li><li>.idea    IDEA项目文件（开发工具产生的文件）</li><li>app    其中一个module，复用父项目的设置，可与父项目拥有相同的配置文件</li><li>build    自动构建时生成文件的地方</li><li>gradle    自动完成gradle环境支持文件夹</li><li>.gitignore    git源码管理文件</li><li>build.gradle    gradle 项目自动编译的配置文件</li><li>gradle.properties    gradle 运行环境配置文件</li><li>gradlew    自动完成 gradle 环境的linux mac 脚本，配合gradle 文件夹使用</li><li>gradlew.bat    自动完成 gradle 环境的windows 脚本，配合gradle 文件夹使用</li><li>local.properties    Android SDK NDK 环境路径配置</li><li>*.iml    IDEA 项目文件</li><li>setting.gradle    gradle 项目的子项目包含文件</li></ul><p>maven 项目转 gradle</p><p>gradle init –type pom</p><p>assemble - 编译打包该工程内容 </p><p>build - 编译打包并测试该工程 </p><p>buildDependents - 编译打包并测试该工程和所有依赖它的工程 </p><p>buildNeeded - 编译打包并测试该工程和它依赖的所有工程 </p><p>classes - 编译打包主要的类文件 </p><p>clean - 删除编译目录 </p><p>jar - 编译打成jar包，这个jar包包含主要的类文件 </p><p>testClasses - 编译打包测试类文件</p>]]></content>
      
      
      <categories>
          
          <category> 项目工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java传递可变参数和方法重载</title>
      <link href="/2020/12/03/CoreJava/Java%E4%BC%A0%E9%80%92%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
      <url>/2020/12/03/CoreJava/Java%E4%BC%A0%E9%80%92%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><h6 id="形式：类型…-参数名"><a href="#形式：类型…-参数名" class="headerlink" title="形式：类型… 参数名"></a>形式：<strong>类型… 参数名</strong></h6><h6 id="示例：public-void-show-int…-a"><a href="#示例：public-void-show-int…-a" class="headerlink" title="示例：public void show(int… a) {};"></a>示例：public void show(int… a) {};</h6><h6 id="可变参数在方法中被当作数组来处理"><a href="#可变参数在方法中被当作数组来处理" class="headerlink" title="可变参数在方法中被当作数组来处理"></a>可变参数在方法中被当作<strong>数组</strong>来处理</h6><h6 id="可变参数传值的四种方式："><a href="#可变参数传值的四种方式：" class="headerlink" title="可变参数传值的四种方式："></a>可变参数传值的四种方式：</h6><ul><li>一个值也不传，可变参数会接收到长度为0的数组</li><li>传null，可变参数会接收到null</li><li>传数组，可变参数会接收到数组</li><li>传1个到多个数组元素值，可变参数会接收到数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    public void changeParam(int... a) &#123;</span><br><span class="line">        System.out.println(&quot;数组长度为：&quot; + a.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test m1 = new Test();</span><br><span class="line">        </span><br><span class="line">        //一个值都不传递</span><br><span class="line">        m1.changeParam();</span><br><span class="line">        //传数组对象</span><br><span class="line">        m1.changeParam(new int[]&#123;5,7,9,1&#125;);</span><br><span class="line">        //传多个元素值，会当成数组处理</span><br><span class="line">        m1.changeParam(1,2,3,4,5);</span><br><span class="line">        //传null，但是这个参数不可用</span><br><span class="line">        m1.changeParam(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="可变参数和数组作为方法参数时的区别："><a href="#可变参数和数组作为方法参数时的区别：" class="headerlink" title="可变参数和数组作为方法参数时的区别："></a>可变参数和数组作为方法参数时的区别：</h6><h6 id="从个数来看，可变参数只能有一个，数组可以有多个"><a href="#从个数来看，可变参数只能有一个，数组可以有多个" class="headerlink" title="从个数来看，可变参数只能有一个，数组可以有多个"></a>从个数来看，可变参数只能有一个，数组可以有多个</h6><h6 id="从定义位置来看，可变参数只能定义在参数列表的末尾，数组可以在任何位置"><a href="#从定义位置来看，可变参数只能定义在参数列表的末尾，数组可以在任何位置" class="headerlink" title="从定义位置来看，可变参数只能定义在参数列表的末尾，数组可以在任何位置"></a>从定义位置来看，可变参数只能定义在参数列表的末尾，数组可以在任何位置</h6><h6 id="从传参的形式来看，可变参数可以传数组、null、0个参数、一到多个参数，数组可以传数组引用、数组对象、null"><a href="#从传参的形式来看，可变参数可以传数组、null、0个参数、一到多个参数，数组可以传数组引用、数组对象、null" class="headerlink" title="从传参的形式来看，可变参数可以传数组、null、0个参数、一到多个参数，数组可以传数组引用、数组对象、null"></a>从传参的形式来看，可变参数可以传数组、null、0个参数、一到多个参数，数组可以传数组引用、数组对象、null</h6><h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><h6 id="方法名相同，但是参数列表不一致，重载的方法会根据参数来匹配调用"><a href="#方法名相同，但是参数列表不一致，重载的方法会根据参数来匹配调用" class="headerlink" title="方法名相同，但是参数列表不一致，重载的方法会根据参数来匹配调用"></a>方法名相同，但是参数列表不一致，重载的方法会根据参数来匹配调用</h6><h6 id="方法的参数必须不同。这里需要注意的是参数不同需要满足2个条件，一个是参数的个数不同，一个是参数个数相同，但参数列表中对应的某个参数的类型不同。"><a href="#方法的参数必须不同。这里需要注意的是参数不同需要满足2个条件，一个是参数的个数不同，一个是参数个数相同，但参数列表中对应的某个参数的类型不同。" class="headerlink" title="方法的参数必须不同。这里需要注意的是参数不同需要满足2个条件，一个是参数的个数不同，一个是参数个数相同，但参数列表中对应的某个参数的类型不同。"></a>方法的参数必须不同。这里需要注意的是参数不同需要满足2个条件，一个是参数的个数不同，一个是参数个数相同，但参数列表中对应的某个参数的类型不同。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    public void show(int a) &#123;</span><br><span class="line">        System.out.println(&quot;带有一个参数的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void show(int... a) &#123;</span><br><span class="line">        System.out.println(&quot;带有可变参数的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test m1 = new Test();</span><br><span class="line">        </span><br><span class="line">        //public void show(int... a)</span><br><span class="line">        m1.show();</span><br><span class="line">        //public void show(int a)</span><br><span class="line">        m1.show(6);//优先调用参数匹配的方法</span><br><span class="line">        //public void show(int... a)</span><br><span class="line">        m1.show(new int[]&#123;5,7,9,1&#125;);</span><br><span class="line">        //public void show(int... a)</span><br><span class="line">        m1.show(1,2,3,4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CoreJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java规则引擎</title>
      <link href="/2020/11/18/Web/Java%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"/>
      <url>/2020/11/18/Web/Java%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h3><ul><li><a href="https://www.jianshu.com/p/41ea7a43093c" target="_blank" rel="noopener">https://www.jianshu.com/p/41ea7a43093c</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规则引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机引擎选型实战</title>
      <link href="/2020/10/27/Web/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%BC%95%E6%93%8E%E9%80%89%E5%9E%8B%E5%AE%9E%E6%88%98/"/>
      <url>/2020/10/27/Web/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%BC%95%E6%93%8E%E9%80%89%E5%9E%8B%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h3><ul><li><p><a href="https://segmentfault.com/a/1190000009906317" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009906317</a></p></li><li><p><a href="https://blog.csdn.net/yqj2065/article/details/39371487" target="_blank" rel="noopener">https://blog.csdn.net/yqj2065/article/details/39371487</a></p></li><li><p>参考工程：jx-decorate-loan/com.huizhaofang.jx.business.common.fsm.StateMachine</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域扫盲</title>
      <link href="/2020/10/27/Web/%E8%B7%A8%E5%9F%9F%E6%89%AB%E7%9B%B2/"/>
      <url>/2020/10/27/Web/%E8%B7%A8%E5%9F%9F%E6%89%AB%E7%9B%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h3><ul><li><p><a href="https://zhuanlan.zhihu.com/p/121048298" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/121048298</a></p></li><li><p><a href="http://www.garyqiang.com/post/qian-duan/kua-yu-wen-ti-shi-zhan" target="_blank" rel="noopener">http://www.garyqiang.com/post/qian-duan/kua-yu-wen-ti-shi-zhan</a></p></li><li><p><a href="http://wangwenming.github.io/misc/2017/02/07/Cookie%E6%89%AB%E7%9B%B2%E8%B4%B4.html" target="_blank" rel="noopener">http://wangwenming.github.io/misc/2017/02/07/Cookie%E6%89%AB%E7%9B%B2%E8%B4%B4.html</a></p></li><li><p>参考工程：jx-decorate-loan/com.huizhaofang.jx.core.common.config.JxCorsConfiguration</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计 Git 代码提交行数</title>
      <link href="/2020/10/27/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/%E7%BB%9F%E8%AE%A1%20Git%20%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A1%8C%E6%95%B0/"/>
      <url>/2020/10/27/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/%E7%BB%9F%E8%AE%A1%20Git%20%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A1%8C%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --all --no-merges --shortstat --since=&quot;2019-06-30&quot; --pretty=format:&apos;%an %ae&apos; | node ../fe-boss-v2/git-stats.js</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var readline = require(&apos;readline&apos;);</span><br><span class="line">var rl = readline.createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout,</span><br><span class="line">  terminal: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let stats = &#123;&#125;;</span><br><span class="line">var isFirstLineOfCommit = true;</span><br><span class="line">var authorName;</span><br><span class="line">rl.on(&apos;line&apos;, function(line) &#123;</span><br><span class="line">    if (isFirstLineOfCommit &amp;&amp; line) &#123;</span><br><span class="line">        authorName = line.split(&apos; &apos;)[0];</span><br><span class="line">        stats[authorName] = stats[authorName] || &#123;filesChanged: 0, insertions: 0, deletions: 0&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">var match = line.match(/(\d+) files&#123;0,1&#125; changed, (\d+) insertions\(\+\), (\d+) deletions\(-\)/);</span><br><span class="line">    if (match !== null) &#123;</span><br><span class="line">    stats[authorName].filesChanged += parseInt(match[1], 10);</span><br><span class="line">    stats[authorName].insertions += parseInt(match[2], 10);</span><br><span class="line">    stats[authorName].deletions += parseInt(match[3], 10);</span><br><span class="line">    &#125;</span><br><span class="line">    isFirstLineOfCommit = line === &apos;&apos;;</span><br><span class="line">&#125;).on(&apos;close&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(stats);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://stackoverflow.com/questions/11135052/how-to-list-only-active-recently-changed-branches-in-git" target="_blank" rel="noopener">How to list only active / recently changed branches in git?</a> </li><li><a href="https://stackoverflow.com/questions/13941976/commit-history-on-remote-repository" target="_blank" rel="noopener">Commit history on remote repository</a> </li><li><a href="https://stackoverflow.com/questions/10349302/how-to-git-log-from-all-branches-for-the-author-at-once" target="_blank" rel="noopener">How to git log from all branches for the author at once?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful</title>
      <link href="/2020/10/27/Web/Restful/"/>
      <url>/2020/10/27/Web/Restful/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Web-Service"><a href="#什么是Web-Service" class="headerlink" title="什么是Web Service"></a>什么是Web Service</h2><ul><li><a href="http://www.weather.com.cn/data/sk/101010100.html" target="_blank" rel="noopener">中国天气网Web Service</a>(免费)</li><li><a href="http://apistore.baidu.com/" target="_blank" rel="noopener">百度APIStore</a>(收费)  </li></ul><h2 id="Web-Service相关标准-specification"><a href="#Web-Service相关标准-specification" class="headerlink" title="Web Service相关标准(specification)"></a>Web Service相关标准(specification)</h2><h3 id="1-SOAP"><a href="#1-SOAP" class="headerlink" title="1. SOAP"></a>1. SOAP</h3><p><strong>Simple Object Access Protocol</strong>，基于HTTP/SMTP/TCP/… + XML，1998年为 M$ 设计的。</p><pre><code>不够Simple。不过反映了 Web Service 的发展进程。</code></pre><h3 id="2-WSDL"><a href="#2-WSDL" class="headerlink" title="2. WSDL"></a>2. WSDL</h3><p><strong>Web Services Description Language</strong>，用于描述接口，就像 JAVA 的方法签名(method signature)。</p><p>由 IBM/M$/Ariba 2000年开发出来描述其 SOAP toolkit，<strong>WSDL 2.0</strong>在2007年6月成为<strong>W3C</strong>推荐标准(recommendation)。</p><h3 id="3-REST"><a href="#3-REST" class="headerlink" title="3. REST"></a>3. REST</h3><p><strong>REpresentational State Transfer</strong> 具象狀態傳輸/表述性状态转移/表现层状态转化</p><h2 id="需要了解的Web-standards"><a href="#需要了解的Web-standards" class="headerlink" title="需要了解的Web standards"></a>需要了解的Web standards</h2><h3 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1. HTTP"></a>1. HTTP</h3><p><a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">旧版RFC2616</a> 1999/06</p><p><a href="https://tools.ietf.org/html/rfc7230" target="_blank" rel="noopener">新版RFC7230</a> 2014/06</p><h3 id="2-URI"><a href="#2-URI" class="headerlink" title="2. URI"></a>2. URI</h3><p><a href="https://tools.ietf.org/html/rfc2396" target="_blank" rel="noopener">旧版RFC2396</a> 1998/08</p><p><a href="https://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">新版RFC3986</a> 2005/01</p><h2 id="REST解释"><a href="#REST解释" class="headerlink" title="REST解释"></a>REST解释</h2><h3 id="1-Resources-资源"><a href="#1-Resources-资源" class="headerlink" title="1. Resources - 资源"></a>1. Resources - 资源</h3><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。<br>Resource举几个好栗子和坏栗子：</p><p>好的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users</span><br><span class="line">orders</span><br><span class="line">tags/1/skus</span><br><span class="line">banners</span><br></pre></td></tr></table></figure><p>坏的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/Credit/Status</span><br><span class="line">/Credit/MemerInfo</span><br><span class="line">/Credit/SaveMemerInfo</span><br><span class="line">/Credit/JobInfo</span><br><span class="line">/Credit/SaveJobInfo</span><br><span class="line"></span><br><span class="line">/area/&#123;id&#125;&amp;&#123;level&#125;</span><br><span class="line"></span><br><span class="line">/coupon_status/&#123;status&#125; 根据用户id获取该用户优惠券并分类（分类：0:未使用，1:已过期，2:已使用）</span><br><span class="line">/coupon_use/&#123;pid&#125;&amp;&#123;cateId&#125; 根据商品 + 用户 获取该商品是否有可使用的优惠券</span><br><span class="line"></span><br><span class="line">/promotionPrizeList/&#123;id&#125; 活动奖品列表</span><br><span class="line">/getPrizeList/&#123;id&#125; 获奖名单及奖品列表</span><br></pre></td></tr></table></figure><p>特殊的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/users/signup</span><br><span class="line">/users/signout</span><br><span class="line">/users/verify_code</span><br></pre></td></tr></table></figure><p>要点：</p><ul><li>英文名词复数，resource 和 数据库表名，前端 class 名等等，统一术语</li><li>注意不要有动词，动词是由 GET/POST/PUT/DELETE/PATCH 完成的</li><li>resource id 一般放在 path</li><li>可读性高(human-readable URIs)</li></ul><h3 id="2-Representation-表现层"><a href="#2-Representation-表现层" class="headerlink" title="2. Representation - 表现层"></a>2. Representation - 表现层</h3><blockquote><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用<strong>Accept</strong>和<strong>Content-Type</strong>字段指定，这两个字段才是对”表现层”的描述。</p></blockquote><p>我们用到了最基本的 <strong>Content-Type</strong> ，高端一点的 <strong>Accept</strong> 暂时不支持，如果要实现接口的版本，则应该在 Accept 里指定。</p><p>这两个概念都属于 HTTP 协议。做 Web应用 开发对 HTTP 1.1 协议不了解的话，还是改行做单机软件比较合适。</p><h3 id="3-State-Transfer-状态转化"><a href="#3-State-Transfer-状态转化" class="headerlink" title="3. State Transfer - 状态转化"></a>3. State Transfer - 状态转化</h3><p>互联网通信协议HTTP协议，是一个无状态协议(stateless protocol: 每次请求作为不相关的独立事物 independent transaction)，很像概率学的<strong>独立不相关</strong>，如抛硬币，如抽奖。</p><p>大部分底层协议都是无状态的，例如<strong>IP</strong>协议。</p><p>HTTP协议无状态的有点：<strong>简单可靠</strong>，缺点：需要在每次请求中，增加额外的信息，比如请求头中的<code>Cookie: JSESSIONID=xxx</code>。</p><p>HTTP协议无状态，不是说我们的应用无状态，恰恰相反，大部分有用户的应用都是有状态的。所有主流HTTP服务器都内置实现了各种Session管理功能，从而在 HTTP 协议之上构建了一种有状态协议(Stateful protocol)。</p><p>既然我们的应用是有状态的，那就可以实现状态转化，REST通过充分利用HTTP协议的四个动词来实现 CRUD 操作：</p><ol><li>GET Read</li><li>POST Create</li><li>PUT Update</li><li>DELETE Delete</li></ol><p>GET 是 “幂等”（idempotent） 的，<code>Math.pow(1, 100) = ?</code><br><br>还有哪个是幂等的？</p><p>其实除了这几种请求方法(Method)外，HTTP 1.1 协议还定义了很多请求方法，如：</p><ul><li>HEAD response只返回header<code>curl -I &quot;http://www.baidu.com/&quot;</code></li><li>OPTIONS 跨域发送非 GET 请求时，需要先发送一个预请求(preflight)，看服务端是否允许客户端跨域请求此Service</li><li>CONNECT </li><li>TRACE</li></ul><p>响应的返回码含义参考<a href="https://tools.ietf.org/html/rfc7231#section-6.1" target="_blank" rel="noopener">rfc7231 6.1章节</a>：</p><ul><li>200 OK</li><li>204 No Content 可用于OK，但是无数据的情况，比如一个用户没有任何订单</li><li>400 Bad Request 比如缺少必须参数，或应该传浮点型的，包含了非数字的字符</li><li>401 Unauthorized 未登录</li><li>403 Forbidden 登录了，但无权限访问此资源</li><li>405 Method Not Allowed </li><li>500 Internal Server Error JAVA异常</li><li>502 Bad Gateway 网关错误，比如 Nginx 反向代理到 Tomcat ，但是 Tomcat 未启动</li><li>504 Gateway Timeout 网关超时，比如我们的服务需要请求微信服务器这种外部资源，但是网络特别卡，超过30秒或1分钟没有返回给 Nginx ，Nginx通常会报 504</li></ul><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><blockquote><p>综合上面的解释，我们总结一下什么是RESTful架构：</p><ol><li><p>每一个URI代表一种资源；</p></li><li><p>客户端和服务器之间，传递这种资源的某种表现层；</p></li><li><p>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p></li></ol></blockquote><h2 id="SprintMVC对RESTful的支持太友好了"><a href="#SprintMVC对RESTful的支持太友好了" class="headerlink" title="SprintMVC对RESTful的支持太友好了"></a>SprintMVC对RESTful的支持太友好了</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(value = &quot;/resources&quot;, produces = &quot;application/json&quot;)</span><br><span class="line">class ResourceController &#123;</span><br><span class="line">     @RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.GET)</span><br><span class="line">     Response getDetail(@PathVariable(&quot;id&quot;) Integer id);</span><br><span class="line"></span><br><span class="line">     @RequestMapping(method = RequestMethod.GET)</span><br><span class="line">     Response getAll();</span><br><span class="line"></span><br><span class="line">     @RequestMapping(method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span><br><span class="line">     Response post(@RequestBody ResourceEntity resourceEntity);</span><br><span class="line"></span><br><span class="line">     @RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.PUT, consumes = &quot;application/json&quot;)</span><br><span class="line">     Response put(@PathVariable(&quot;id&quot;) Integer id, @RequestBody ResourceVO resourceVO);</span><br><span class="line"></span><br><span class="line">     @RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span><br><span class="line">     Response delete(@PathVariable(&quot;id&quot;) Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JS-jQuery-AngularJS对RESTful的支持太友好了"><a href="#JS-jQuery-AngularJS对RESTful的支持太友好了" class="headerlink" title="JS/jQuery/AngularJS对RESTful的支持太友好了"></a>JS/jQuery/AngularJS对RESTful的支持太友好了</h2><ul><li>PUT/POST 采用JSON传递数据，而不是Form表单</li><li>几乎所有响应都是返回JSON</li><li>注意跨域: <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials" target="_blank" rel="noopener">XMLHttpRequest.withCredentials</a></li></ul><h2 id="网络请求分析工具"><a href="#网络请求分析工具" class="headerlink" title="网络请求分析工具"></a>网络请求分析工具</h2><ol><li>Postman 0.8.4.17 - REST Client</li><li><a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">Chrome DevTools</a></li><li>Charles 3.11.4</li><li>JSONView 0.0.32.2</li><li>EditThisCookie 1.4.1</li></ol><p>上述1、4、5扩展可在共享目录<code>//192.168.17.205/xinyuangong/Chrome Extensions</code>下载到，或者使用360浏览器也可以下载</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="http://swagger.io/" target="_blank" rel="noopener">swagger.io</a> Swagger is a simple yet powerful representation of your RESTful API</li><li><a href="https://github.com/mashery/iodocs" target="_blank" rel="noopener">I/O Docs</a> </li></ol><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><blockquote><p>The term REST was defined by Roy T. Fielding in his PhD thesis (you might actually want to follow that link — it’s quite readable, for a dissertation at least).</p></blockquote><p>2000年提出的，论文单词能看懂，但比较抽象。Roy 是 HTTP 协议和 URI 协议的作者之一。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.ruanyifeng.com/blog/2011/09/restful" target="_blank" rel="noopener">理解RESTful架构</a> 阮一峰 2011-09-12 </li><li><a href="https://www.infoq.com/articles/rest-introduction" target="_blank" rel="noopener">A Brief Introduction to REST</a> Stefan Tilkov 2007-12-10</li><li><a href="https://en.wikipedia.org/wiki/SOAP" target="_blank" rel="noopener">SOAP</a></li><li><a href="https://en.wikipedia.org/wiki/Stateless_protocol" target="_blank" rel="noopener">Stateless protocol</a></li><li><a href="https://links97.mixmaxusercontent.com/5ec9ea6a9db2d4003b43cccd/l/TNA8DS2Caw5RM5RhG?messageId=G3jnNNist29124Ugr&rn=ISaxdmbhdlI&re=i02bj5yM2EDQ5cDO3kWcfdmbhdnI&sc=false" target="_blank" rel="noopener">优秀的 REST API 设计指南</a></li><li><a href="http://wangwenming.github.io/java/2016/05/25/RESTful.html" target="_blank" rel="noopener">http://wangwenming.github.io/java/2016/05/25/RESTful.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful架构风格下的4大常见安全问题</title>
      <link href="/2020/10/27/Web/Restful%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8B%E7%9A%844%E5%A4%A7%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/10/27/Web/Restful%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%E4%B8%8B%E7%9A%844%E5%A4%A7%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>伴随着RESTful架构风格的大量应用微服务架构的流行，一些本来难以察觉到的安全问题也逐渐开始显现出来。在我经历过的各种采用RESTful微服务架构风格的应用中，某些安全问题几乎在每个应用中都会出现。然而它们并非是什么高深的技术难题，只不过是借着微服务的流行而显得越发突出，这些都可以通过一些安全实践来避免。本文将一些典型的问题列举出来，希望能引起开发团队的注意，帮助他们绕过这些安全问题的“坑”。</p><h3 id="1-遗漏了对资源从属关系的检查"><a href="#1-遗漏了对资源从属关系的检查" class="headerlink" title="1. 遗漏了对资源从属关系的检查"></a>1. 遗漏了对资源从属关系的检查</h3><p>一个典型的RESTful的URL会用资源名加上资源的ID编号来标识其唯一性，就像这样:<code>/users/&lt;USER ID&gt;</code>，例如：<code>/users/100</code></p><p>一般而言用户只能查看自己的用户信息，而不允许查看其它用户的信息。在这种情况下，攻击者很可能会尝试把这个URL里面的USER ID从100修改为其他数值，以期望应用返回指定用户的信息。不过由于这个安全风险太显而易见，绝大多数应用都会对当前请求者的身份进行校验，看其是否是编号为100的用户，校验成功才返回URL中指定的用户信息，否则会拒绝当前请求。</p><p>对于URL中只出现一个资源的情况，绝大多数应用都已经做了安全防御，然而重灾区出现在URL中包含多个资源的时候。</p><p>以用户查看订单的RESTful URL为例：<code>/users/100/orders/280010</code>，应用只检查了当前请求发起者是否是编号为100的用户，以及编号为280010的订单是否存在，有很大的概率没有检查URL中的订单和用户之间的从属关系。其结果是，攻击者可以通过修改URL中的订单编号，从而遍历系统中的所有订单信息，甚至对不属于他/她的订单发起操作，例如取消订单。</p><p>上面的例子中只有两个资源，如果URL中资源数量继续增加，这种从属关系校验缺失的情况只会更加普遍。</p><p>解决这一问题的方法极其简单，只要发现URL里面出现了两个或者两个以上的资源，就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ResourceA/&lt;ResourceA Id&gt;/ResourceB/&lt;ResourceB Id&gt;/ResourceC/&lt;ResourceC Id&gt;</span><br></pre></td></tr></table></figure><p>在对资源进行操作之前，就得先检查这些资源之间的从属关系，以确保当前请求具有相关的访问、操作权限。</p><h3 id="2-HTTP响应中缺失必要的-Security-Headers"><a href="#2-HTTP响应中缺失必要的-Security-Headers" class="headerlink" title="2. HTTP响应中缺失必要的 Security Headers"></a>2. HTTP响应中缺失必要的 Security Headers</h3><p>HTTP中有一些和安全相关的Header，通过对它们的合理使用，可以使得应用在具备更高的安全性的同时，并不会显著增大开发者的工作负担，有着“低成本高收益”的效果。不过绝大多数情况下，这些Header是默认关闭的，因此很多应用中也就缺失了这些Security Headers。一些典型的Security Headers如下：</p><p><strong>X-Frame-Options</strong><br>为了防止应用遭受点击劫持攻击，可以使用<code>X-Frame-Options: DENY</code>明确告知浏览器，不要把当前HTTP响应中的内容在HTML Frame中显示出来。</p><p><strong>X-Content-Type-Options</strong><br>在浏览器收到HTTP响应内容时，它会尝试按照自己的规则去推断响应内容的类型，并根据推断结果执行后续操作，而这可能造成安全问题。例如，一个包含恶意JavaScript代码的HTTP响应内容，虽然其<code>Content-Type</code>为<code>image/png</code>，但是浏览器推断出这是一段脚本并且会执行它。</p><p><code>X-Content-Type-Options</code>就是专门用来解决这个问题的Header。通过将其设置为<code>X-Content-Type-Options: nosniff</code>，浏览器将不再自作主张的推断HTTP响应内容的类型，而是严格按照响应中<code>Content-Type</code>所指定的类型来解析响应内容。</p><p><strong>X-XSS-Protection</strong><br>避免应用出现跨站脚本漏洞（Cross-Site Scripting，简称XSS）的最佳办法是对输出数据进行正确的编码，不过除此之外，现如今的浏览器也自带了防御XSS的能力。</p><p>要开启浏览器的防XSS功能，只需要在HTTP响应中加上这个Header：<code>X-XSS-Protection: 1; mode=block</code>。其中，数字<code>1</code>代表开启浏览器的XSS防御功能，<code>mode=block</code>是告诉浏览器，如果发现有XSS攻击，则直接屏蔽掉当前即将渲染的内容。</p><p><strong>Strict-Transport-Security</strong><br>使用TLS可以保护数据在传输过程中的安全，而在HTTP响应中添加上<code>Strict-Transport-Security</code>这个Header，可以告知浏览器直接发起HTTPS请求，而不再像往常那样，先发送明文的HTTP请求，得到服务器跳转指令后再发送后续的HTTPS请求。并且，一旦浏览器接收到这个Header，那么当它发现数据传输通道不安全的时候，它会直接拒绝进行任何的数据传输，不再允许用户继续通过不安全的传输通道传输数据，以避免信息泄露。</p><h3 id="3-不经意间泄露的业务信息"><a href="#3-不经意间泄露的业务信息" class="headerlink" title="3. 不经意间泄露的业务信息"></a>3. 不经意间泄露的业务信息</h3><p><strong>会说话的ID</strong><br>资源ID是RESTful URL中很重要的一个组成部分，大多数情况下这类资源ID都是用数字来表示的。这在不经意间泄露了业务信息，而这些信息可能正是竞争对手希望得到的数据。</p><p>以查看用户信息的RESTful URL为例：<code>/users/100</code>。由于用户ID是一个按序递增的数字，因此攻击者既可以通过ID知道目前应用中的用户规模，也可以分别在月初和月末的时候注册一个用户，并对比两个用户的ID即可知道当前这个月有多少新增用户。同理，如果订单号也是按序自增的数字，攻击者可以了解到一定时间范围内的订单量。</p><p>这类ID并不会给应用造成任何技术上的威胁，只是通过ID泄露出来的信息对于你的业务而言可能非常敏感。解决办法是不使用按序递增的数字作为ID，而是使用具有随机性、唯一性、不可预测性的值作为ID，最常见的做法就是使用UUID。</p><p><strong>返回多余的数据</strong><br>前后端分离的情况下，两者之间通常以JSON作为数据传输的主体。有时候可能是为了方便前端代码处理，也可能是疏忽大意，总之后端API返回的JSON数据中包含了远远超出前端代码需要的数据，因此造成数据泄露。</p><p>例如，前端代码本意是请求订单信息，但是后端API返回的订单JSON数据中还包含了很多“有意思”的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;id&quot;: 280010, </span><br><span class="line">    &quot;orderItems&quot;: [...], </span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: 100, </span><br><span class="line">        &quot;password&quot;: &quot;91B4E3E45B2465A4823BB5C03FF81B65&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子里，订单数据中包含了用户信息，最为关键的是连用户的密码字段也被包含在内。</p><p>解决办法显而易见，在给前端返回数据之前，将这些敏感的、前端并不需要的数据过滤掉。技术上实现起来易如反掌，但是真正难的地方在于让整个应用都严格的按照这样的方式来处理JSON数据，确保没有任何遗漏之处。</p><h3 id="4-API缺乏速率限制的保护"><a href="#4-API缺乏速率限制的保护" class="headerlink" title="4. API缺乏速率限制的保护"></a>4. API缺乏速率限制的保护</h3><p>先看一个例子。用户注册时发送短信验证码的API，由于没有做速率限制，使得攻击者可以用一段脚本不断的请求服务器发送短信验证码，导致在短时间内耗尽短信发送配额，或者造成短信网关拥挤等等后果。</p><p>受伤的不仅仅是发送短信的API，其他一些比较敏感的API如果缺乏请求速率限制的保护，同样也会遭遇安全问题。例如用户登录的API缺乏速率限制的话，攻击者可以利用其进行用户名密码暴力破解，再例如某些大量消耗服务器资源的API如果缺乏速率限制，攻击者可以利用其发起拒绝式攻击。</p><p>解决这类安全问题的原则就是对API请求的速率进行适当的限制。具体的做法有很多，最典型的例子就是使用图片验证码，其他的做法还有利用Redis的Expire特性对请求速率进行统计判断，甚至借助运维的力量（例如网络防火墙）来共同进行防御等等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>开发出一个具备足够安全性的应用不是件容易的事情，本文中提到的只是RESTful架构风格下，众多安全问题中比较典型的一部分而已。之所以会有这些问题，其本质原因在于应用开发过程中，开发团队的注意力集中在业务功能的实现上，应用安全性相关的需求没有得到足够的明确和重视。</p><p>如果你不想被这些安全问题所困扰，建议通过在应用开发过程中引入威胁建模、在用户故事卡中设立安全验收标准、进行安全代码审查等一系列安全实践，尽可能从源头上规避这些问题。</p>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful设计细节</title>
      <link href="/2020/10/27/Web/Restful%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82/"/>
      <url>/2020/10/27/Web/Restful%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。</p><h2 id="什么是RESTful"><a href="#什么是RESTful" class="headerlink" title="什么是RESTful"></a>什么是RESTful</h2><p>RESTful是一种软件设计风格, 主要用于客户端与服务端交互的软件. 一般来说RESTful API基于HTTP协议, 通过某个唯一标识符(URI)请求对应的服务器资源(Resource).通常我们把RESTful API编程也叫做”接口编程”.<br>RESTful API基于HTTP协议, 实现了通用的前后端交互, 前端通过某个URI告诉后端执行对应的操作, 并返回需要的资源, 可以很好的实现前后端分离.</p><h2 id="什么场景下使用RESTful-API"><a href="#什么场景下使用RESTful-API" class="headerlink" title="什么场景下使用RESTful API"></a>什么场景下使用RESTful API</h2><p>在当今的互联网应用的前端展示媒介很丰富。有手机、有平板电脑还有PC以及其他的展示媒介。那么这些前端接收到的用户请求统一由一个后台来处理并返回给不同的前端肯定是最科学和最经济的方式，RESTful API就是一套协议来规范多种形式的前端和同一个后台的交互方式。</p><p>RESTful API由后台也就是SERVER来提供前端来调用。前端调用API向后台发起HTTP请求，后台响应请求将处理结果反馈给前端。也就是说RESTful 是典型的基于HTTP的协议。那么RESTful API有哪些设计原则和规范呢？</p><ul><li><p>1，资源。首先是弄清楚资源的概念。资源就是网络上的一个实体，一段文本，一张图片或者一首歌曲。资源总是要通过一种载体来反应它的内容。文本可以用TXT，也可以用HTML或者XML、图片可以用JPG格式或者PNG格式，JSON是现在最常用的资源表现形式。</p></li><li><p>2，统一接口。RESTful风格的数据元操CRUD（create,read,update,delete）分别对应HTTP方法：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口。</p></li><li><p>3，URI。可以用一个URI（统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取这个资源访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。一般的，每个资源至少有一个URI与之对应，最典型的URI就是URL。</p></li><li><p>4，无状态。所谓无状态即所有的资源都可以URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而变化。有状态和无状态的区别，举个例子说明一下：</p></li></ul><p>例如要查询员工工资的步骤为第一步：登录系统。第二步：进入查询工资的页面。第三步：搜索该员工。第四步：点击姓名查看工资。这样的操作流程就是有状态的，查询工资的每一个步骤都依赖于前一个步骤，只要前置操作不成功，后续操作就无法执行。</p><p>如果输入一个URL就可以得到指定员工的工资，则这种情况就是无状态的，因为获取工资不依赖于其他资源或状态，且这种情况下，员工工资是一个资源，由一个URL与之对应可以通过HTTP中的GET方法得到资源，这就是典型的RESTful风格。</p><h2 id="RESTful-的设计细节"><a href="#RESTful-的设计细节" class="headerlink" title="RESTful 的设计细节"></a>RESTful 的设计细节</h2><h3 id="一、URL设计"><a href="#一、URL设计" class="headerlink" title="一、URL设计"></a>一、URL设计</h3><h4 id="动词-宾语"><a href="#动词-宾语" class="headerlink" title="动词+宾语"></a>动词+宾语</h4><p>RESTful的核心思想就是，客户端发出的数据+操作指令都是“动词+宾语”的结构，比如GET /articles这个命令，GET是动词，/articles是宾语，动词通常就有5种HTTP请求方法，对应CRUD操作，根据 HTTP 规范，动词一律大写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># GET：读取（Read）</span><br><span class="line"># POST：新建（Create）</span><br><span class="line"># PUT：更新（Update）</span><br><span class="line"># PATCH：更新（Update），通常是部分更新</span><br><span class="line"># DELETE：删除（Delete）</span><br></pre></td></tr></table></figure><h4 id="动词的覆盖"><a href="#动词的覆盖" class="headerlink" title="动词的覆盖"></a>动词的覆盖</h4><p>有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/Person/4 HTTP/1.1</span><br><span class="line">X-HTTP-Method-Override: PUT</span><br></pre></td></tr></table></figure><p>上面代码中，X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST。</p><h4 id="宾语必须是名词"><a href="#宾语必须是名词" class="headerlink" title="宾语必须是名词"></a>宾语必须是名词</h4><p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># /getAllCars</span><br><span class="line"># /createNewCar</span><br><span class="line"># /deleteAllRedCars</span><br></pre></td></tr></table></figure><h4 id="复数-URL"><a href="#复数-URL" class="headerlink" title="复数 URL"></a>复数 URL</h4><p>既然 URL 是名词，那么应该使用复数，还是单数？这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。</p><p>为了统一起见，建议都使用复数 URL，比如GET /articles/2 要好于GET /article/2。</p><h4 id="避免多级-URL"><a href="#避免多级-URL" class="headerlink" title="避免多级 URL"></a>避免多级 URL</h4><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># GET /authors/12/categories/2</span><br></pre></td></tr></table></figure><p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p><p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># GET /authors/12?categories=2</span><br></pre></td></tr></table></figure><p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># GET /articles/published</span><br></pre></td></tr></table></figure><p>查询字符串的写法明显更好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># GET /articles?published=true</span><br></pre></td></tr></table></figure><h4 id="Back-forward-Slash"><a href="#Back-forward-Slash" class="headerlink" title="Back forward Slash (/)"></a>Back forward Slash (/)</h4><p>目前比较流行的API设计方案，通常建议url以/作为结尾，如果API GET请求中，url不以/结尾，则重定向到以/结尾的API上去（这点现在的web框架基本都支持），因为有没有 /，也是两个url，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /posts/</span><br><span class="line"># /posts</span><br></pre></td></tr></table></figure><p>这也是两个不同的url，可以对应不同的行为和资源</p><h4 id="连接符-和-下划线"><a href="#连接符-和-下划线" class="headerlink" title="连接符 - 和 下划线 _"></a>连接符 - 和 下划线 _</h4><p>RESTful API 应具备良好的可读性，当url中某一个片段（segment）由多个单词组成时，建议使用 - 来隔断单词，而不是使用 _，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Good</span><br><span class="line">/api/featured-post/</span><br><span class="line"></span><br><span class="line"># Bad</span><br><span class="line">/api/featured_post/</span><br></pre></td></tr></table></figure><p>这主要是因为，浏览器中超链接显示的默认效果是，文字并附带下划线，如果API以_隔断单词，二者会重叠，影响可读性。</p><h3 id="二、状态码"><a href="#二、状态码" class="headerlink" title="二、状态码"></a>二、状态码</h3><p>状态码必须精确</p><p>客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。</p><p>HTTP 状态码就是一个三位数，分成五个类别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 1xx：相关信息</span><br><span class="line"># 2xx：操作成功</span><br><span class="line"># 3xx：重定向</span><br><span class="line"># 4xx：客户端错误</span><br><span class="line"># 5xx：服务器错误</span><br></pre></td></tr></table></figure><p>这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p><p>API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。</p><p>2XX状态码</p><p>200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># GET: 200 OK</span><br><span class="line"># POST: 201 Created</span><br><span class="line"># PUT: 200 OK</span><br><span class="line"># PATCH: 200 OK</span><br><span class="line"># DELETE: 204 No Content</span><br></pre></td></tr></table></figure><p>上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。</p><p>此外，202 Accepted状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 202 Accepted</span><br><span class="line">&#123;</span><br><span class="line"> &quot;task&quot;: &#123;</span><br><span class="line"> &quot;href&quot;: &quot;/api/company/job-management/jobs/2130040&quot;,</span><br><span class="line"> &quot;id&quot;: &quot;2130040&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3xx 状态码</p><p>API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p><p>API 用到的3xx状态码，主要是303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是”暂时重定向”，区别在于302和307用于GET请求，而303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。</p><p>下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 303 See Other</span><br><span class="line">Location: /api/orders/12345</span><br></pre></td></tr></table></figure><p>4xx 状态码</p><p>4xx状态码表示客户端错误，主要有下面几种。</p><ul><li>400 Bad Request：服务器不理解客户端的请求，未做任何处理。</li><li>401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</li><li>403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</li><li>404 Not Found：所请求的资源不存在，或不可用。</li><li>405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</li><li>410 Gone：所请求的资源已从这个地址转移，不再可用。</li><li>415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</li><li>422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</li><li>429 Too Many Requests：客户端的请求次数超过限额。</li></ul><p>5xx 状态码</p><p>5xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p><ul><li>500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。</li><li>503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</li></ul><h3 id="三、服务器回应"><a href="#三、服务器回应" class="headerlink" title="三、服务器回应"></a>三、服务器回应</h3><p>不要返回纯本文</p><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。</p><p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /orders/2 HTTP/1.1</span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure><p>发生错误时，不要返回 200 状态码</p><p>有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;status&quot;: &quot;failure&quot;,</span><br><span class="line"> &quot;data&quot;: &#123;</span><br><span class="line"> &quot;error&quot;: &quot;Expected at least two items in list.&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，解析数据体以后，才能得知操作失败。</p><p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;error&quot;: &quot;Invalid payoad.&quot;,</span><br><span class="line"> &quot;detail&quot;: &#123;</span><br><span class="line"> &quot;surname&quot;: &quot;This field is required.&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供链接</p><p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。</p><p>举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> &quot;feeds_url&quot;: &quot;https://api.github.com/feeds&quot;,</span><br><span class="line"> &quot;followers_url&quot;: &quot;https://api.github.com/user/followers&quot;,</span><br><span class="line"> &quot;following_url&quot;: &quot;https://api.github.com/user/following&#123;/target&#125;&quot;,</span><br><span class="line"> &quot;gists_url&quot;: &quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,</span><br><span class="line"> &quot;hub_url&quot;: &quot;https://api.github.com/hub&quot;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。</p><p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;status&quot;: &quot;In progress&quot;,</span><br><span class="line"> &quot;links&quot;: &#123;[</span><br><span class="line"> &#123; &quot;rel&quot;:&quot;cancel&quot;, &quot;method&quot;: &quot;delete&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; &#125; ,</span><br><span class="line"> &#123; &quot;rel&quot;:&quot;edit&quot;, &quot;method&quot;: &quot;put&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; &#125;</span><br><span class="line"> ]&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Restful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中new一个对象是一个怎样的过程？JVM中发生了什么？</title>
      <link href="/2020/10/26/CoreJava/Java%E4%B8%ADnew%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%80%8E%E6%A0%B7%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/10/26/CoreJava/Java%E4%B8%ADnew%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%80%8E%E6%A0%B7%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="Java中new一个对象的步骤："><a href="#Java中new一个对象的步骤：" class="headerlink" title="Java中new一个对象的步骤："></a>Java中new一个对象的步骤：</h3><ol><li><p>当虚拟机遇到一条new指令时候，首先去检查这个指令的参数是否能 <strong>在常量池中能否定位到一个类的符号引用</strong> （即类的带路径全名），并且检查这个符号引用代表的类是否已被加载、解析和初始化过，即<strong>验证是否是第一次使用该类</strong>。如果没有（不是第一次使用），那必须先执行相应的类加载过程（class.forname()）。</p></li><li><p>在类加载检查通过后，接下来虚拟机将 <strong>为新生的对象分配内存</strong> 。对象所需的内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来，目前常用的有两种方式，根据使用的垃圾收集器的不同使用不同的分配机制：</p></li></ol><p>　　2.1. <strong>指针碰撞</strong>（Bump the Pointer）：假设Java堆的内存是绝对规整的，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p><p>　　2.2. <strong>空闲列表</strong>（Free List）：如果Java堆中的内存并不是规整的，已使用的内存和空间的内存是相互交错的，虚拟机必须维护一个空闲列表，记录上哪些内存块是可用的，在分配时候从列表中找到一块足够大的空间划分给对象使用。</p><ol start="3"><li><p>内存分配完后，虚拟机需要将分配到的内存空间中的数据类型都 <strong>初始化为零值（不包括对象头）</strong>；</p></li><li><p>虚拟机要 <strong>对对象头进行必要的设置</strong> ，例如这个对象是哪个类的实例（即所属类）、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都存放在对象的对象头中。</p></li></ol><p>至此，从虚拟机视角来看，一个新的对象已经产生了。但是在Java程序视角来看，执行new操作后会接着执行如下步骤：</p><ol start="5"><li><p><strong>调用对象的init()方法</strong> ,根据传入的属性值给对象属性赋值。</p></li><li><p>在线程 <strong>栈中新建对象引用</strong> ，并指向堆中刚刚新建的对象实例。 </p></li></ol><p>对象虽然创建完了，但是在创建对象的过程中，可能会发生一些小意外。比如：在划分可用空间时，如果是在并发情况下，那么划分就不一定是线程安全的。因为有可能出现正在给A对象分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针分配内存的情况，那么，解决这个问题有两种方案：</p><ol><li>分配内存空间的动作进行<strong>同步处理</strong> ：实际上虚拟机采用CAS配上失败重试的方式保证了更新操作的原子性。</li><li>内存分配的动作按照线程划分在不同的空间中进行： 为每个线程在Java堆中<strong>预先分配</strong>一小块内存 ，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。</li></ol><p>按理说，到这里文章就结束了，问题也解决了。但是，在上面的过程中，我们忽略了一些问题，跳过了一些步骤，比如：类加载过程；对象的使用等等。。。</p><p>那么，创建了对象，我们是要使用的，那么在Java中这些被new出来的对象在使用的过程中，是一个怎样的过程呢？</p><p>带着这个疑问，我想到了以前看Java基础课中，老师讲的内容了(认真听课，课上讲的内容还是很有用滴)……</p><h3 id="一、这就是对对象的访问定位问题"><a href="#一、这就是对对象的访问定位问题" class="headerlink" title="一、这就是对对象的访问定位问题"></a>一、这就是对对象的访问定位问题</h3><p>我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流访问方式有 使用句柄访问（间接访问） 和 直接指针访问 两种：</p><ol><li><p>句柄访问：</p><p>Java堆中将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是<strong>对象句柄位置</strong>，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p></li></ol><p>在这里放一张图您就明白了：</p><p><img src="/2020/10/26/CoreJava/Java%E4%B8%ADnew%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%80%8E%E6%A0%B7%E7%9A%84%E8%BF%87%E7%A8%8B/1757082-20190823164528186-199424695.png" alt="Image png"></p><ol start="2"><li><p>直接指针访问：</p><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是<strong>对象地址</strong>。</p></li></ol><p><img src="/2020/10/26/CoreJava/Java%E4%B8%ADnew%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%80%8E%E6%A0%B7%E7%9A%84%E8%BF%87%E7%A8%8B/1757082-20190823164732018-1329102154.png" alt="Image png"></p><p>两张图放一起一对比就浅显易懂了。</p><h3 id="二、-类加载过程（第一次使用该类）"><a href="#二、-类加载过程（第一次使用该类）" class="headerlink" title="二、 类加载过程（第一次使用该类）"></a>二、 类加载过程（第一次使用该类）</h3><p>Java是使用 双亲委派模型 来进行类的加载的，所以在描述类加载过程前，我们先看一下它的工作过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果一个类加载器（ClassLoader）收到了类加载的请求，它首先不会自己去尝试加载这个类，</span><br><span class="line">　　而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的</span><br><span class="line">　　启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，</span><br><span class="line">　　子加载器才会尝试自己去加载。</span><br><span class="line"></span><br><span class="line">使用双亲委托机制的好处是：</span><br><span class="line">　　能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。</span><br></pre></td></tr></table></figure><p><strong>1、加载</strong></p><p>　　　　 由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例</p><p><strong>2、验证</strong></p><p>格式验证：验证是否符合class文件规范<br>语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）<br>操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）</p><p><strong>3、准备</strong></p><p>为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）<br>被final修饰的static变量（常量），会直接赋值；</p><p><strong>4、解析</strong></p><p>将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。<br>解析需要静态绑定的内容。  // 所有不会被重写的方法和域都会被静态绑定</p><p>　　<strong>以上2、3、4三个阶段又合称为链接阶段</strong>，链接阶段要做的是将加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中。</p><p><strong>5、初始化（先父后子）</strong></p><p>4.1 为静态变量赋值</p><p>4.2 执行static代码块</p><blockquote><p>注意：static代码块只有jvm能够调用<br>　　　如果是多线程需要同时初始化一个类，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。 </p></blockquote><p>因为子类存在对父类的依赖，所以<strong>类的加载顺序是先加载父类后加载子类，初始化也一样。</strong>不过，父类初始化时，子类静态变量的值也有有的，是默认值。</p><p>最终，方法区会存储当前类类信息，包括类的<strong>静态变量</strong>、<strong>类初始化代码</strong>（<strong>定义静态变量时的赋值语句</strong> 和 <strong>静态初始化代码块</strong>）、<strong>实例变量定义</strong>、<strong>实例初始化代码</strong>（<strong>定义实例变量时的赋值语句实例代码块</strong>和<strong>构造方法</strong>）和<strong>实例方法</strong>，还有<strong>父类的类信息引用。</strong></p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>通过实例引用调用实例方法的时候，先从方法区中对象的实际类型信息找，找不到的话再去父类类型信息中找。</p><p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为<strong>虚方法表</strong>的方法来优化调用的效率。</p><p>所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。</p>]]></content>
      
      
      <categories>
          
          <category> CoreJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch</title>
      <link href="/2020/09/28/CoreJava/CountDownLatch/"/>
      <url>/2020/09/28/CoreJava/CountDownLatch/</url>
      
        <content type="html"><![CDATA[<h4 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h4><ul><li>CountDownLatch是在java1.5被引入，跟它一起被引入的工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue。</li><li>存在于java.util.cucurrent包下。</li></ul><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>CountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</li><li>是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。</li></ul><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ul><li>CountDownLatch类中只提供了一个构造器：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//参数count为计数值</span><br><span class="line">public CountDownLatch(int count) &#123;  &#125;;</span><br></pre></td></tr></table></figure><ul><li>类中有三个方法是最重要的：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span><br><span class="line">public void await() throws InterruptedException &#123; &#125;;   </span><br><span class="line">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;  </span><br><span class="line">//将count值减1</span><br><span class="line">public void countDown() &#123; &#125;;</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li><em>普通示例：</em></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class CountDownLatchTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final CountDownLatch latch = new CountDownLatch(2);</span><br><span class="line">        System.out.println(&quot;主线程开始执行…… ……&quot;);</span><br><span class="line">        //第一个子线程执行</span><br><span class="line">        ExecutorService es1 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es1.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    System.out.println(&quot;子线程：&quot;+Thread.currentThread().getName()+&quot;执行&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es1.shutdown();</span><br><span class="line"></span><br><span class="line">        //第二个子线程执行</span><br><span class="line">        ExecutorService es2 = Executors.newSingleThreadExecutor();</span><br><span class="line">        es2.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;子线程：&quot;+Thread.currentThread().getName()+&quot;执行&quot;);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        es2.shutdown();</span><br><span class="line">        System.out.println(&quot;等待两个线程执行完毕…… ……&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            // 或使用 Thread.join();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;两个子线程都执行完毕，继续执行主线程&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em>结果集：</em></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主线程开始执行…… ……</span><br><span class="line">等待两个线程执行完毕…… ……</span><br><span class="line">子线程：pool-1-thread-1执行</span><br><span class="line">子线程：pool-2-thread-1执行</span><br><span class="line">两个子线程都执行完毕，继续执行主线程</span><br></pre></td></tr></table></figure><ul><li><em>模拟并发示例：</em></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Parallellimit &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch cdl = new CountDownLatch(10);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            CountRunnable runnable = new CountRunnable(cdl);</span><br><span class="line">            pool.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CountRunnable implements Runnable &#123;</span><br><span class="line">    private CountDownLatch countDownLatch;</span><br><span class="line">    public CountRunnable(CountDownLatch countDownLatch) &#123;</span><br><span class="line">        this.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (countDownLatch) &#123;</span><br><span class="line">                /*** 每次减少一个容量*/</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(&quot;thread counts = &quot; + (countDownLatch.getCount()));</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(&quot;concurrency counts = &quot; + (10 - countDownLatch.getCount()));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em>结果集：</em></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">thread counts = 9</span><br><span class="line">thread counts = 8</span><br><span class="line">thread counts = 7</span><br><span class="line">thread counts = 6</span><br><span class="line">thread counts = 5</span><br><span class="line">thread counts = 4</span><br><span class="line">thread counts = 3</span><br><span class="line">thread counts = 2</span><br><span class="line">thread counts = 1</span><br><span class="line">thread counts = 0</span><br><span class="line">concurrency counts = 10</span><br><span class="line">concurrency counts = 10</span><br><span class="line">concurrency counts = 10</span><br><span class="line">concurrency counts = 10</span><br><span class="line">concurrency counts = 10</span><br><span class="line">concurrency counts = 10</span><br><span class="line">concurrency counts = 10</span><br><span class="line">concurrency counts = 10</span><br><span class="line">concurrency counts = 10</span><br><span class="line">concurrency counts = 10</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch和CyclicBarrier区别："><a href="#CountDownLatch和CyclicBarrier区别：" class="headerlink" title="CountDownLatch和CyclicBarrier区别："></a>CountDownLatch和CyclicBarrier区别：</h4><ul><li>CountDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次</li><li>CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> CoreJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoreJava </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-FAQ</title>
      <link href="/2020/09/28/CoreJava/Java_FAQ/"/>
      <url>/2020/09/28/CoreJava/Java_FAQ/</url>
      
        <content type="html"><![CDATA[<h4 id="1-javax-net-ssl-SSLHandshakeException-Received-fatal-alert-handshake-failure"><a href="#1-javax-net-ssl-SSLHandshakeException-Received-fatal-alert-handshake-failure" class="headerlink" title="1.javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure"></a>1.javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure</h4><p>接入CGI接口时会报“javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure”, 请安装JCE无限制权限策略文件;<br>JDK6的下载地址: <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html</a><br>JDK7的下载地址: <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html</a><br>JDK8的下载地址: <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a><br>下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt。如果安装的是JRE，将两个jar文件放到%JRE_HOME% \lib\security目录下覆盖原来的文件，如果安装的是JDK，将两个jar文件放到%JDK_HOME%\jre\lib\security目录下覆盖原来文件 </p><h4 id="2-https访问公钥问题"><a href="#2-https访问公钥问题" class="headerlink" title="2.https访问公钥问题"></a>2.https访问公钥问题</h4><p>1.找到本机JDK安装目录，将 com.springsource.org.bouncycastle.jce-1.46.0.jar（该文件在当前目录下） 复制到 jre/lib/ext/ 目录下<br>2.用文本编辑器打开 /jre/lib/security/java.security (注意备份)，找到以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">security.provider.1=sun.security.provider.Sun</span><br><span class="line">security.provider.2=sun.security.rsa.SunRsaSign  </span><br><span class="line">security.provider.3=sun.security.ec.SunEC  </span><br><span class="line">security.provider.4=com.sun.net.ssl.internal.ssl.Provider  </span><br><span class="line">security.provider.5=com.sun.crypto.provider.SunJCE  </span><br><span class="line">security.provider.6=sun.security.jgss.SunProvider  </span><br><span class="line">security.provider.7=com.sun.security.sasl.Provider  </span><br><span class="line">security.provider.8=org.jcp.xml.dsig.internal.dom.XMLDSigRI  </span><br><span class="line">security.provider.9=sun.security.smartcardio.SunPCSC  </span><br><span class="line">security.provider.10=sun.security.mscapi.SunMSCAPI</span><br></pre></td></tr></table></figure><p>将security.provider.2=org.bouncycastle.jce.provider.BouncyCastleProvider复制到security.provider.1=sun.security.provider.Sun 之后，从security.provider.2=sun.security.rsa.SunRsaSign开始往下每一行的数字都加1，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">security.provider.1=sun.security.provider.Sun  </span><br><span class="line">security.provider.2=org.bouncycastle.jce.provider.BouncyCastleProvider  </span><br><span class="line">security.provider.3=sun.security.rsa.SunRsaSign  </span><br><span class="line">security.provider.4=sun.security.ec.SunEC  </span><br><span class="line">security.provider.5=com.sun.net.ssl.internal.ssl.Provider  </span><br><span class="line">security.provider.6=com.sun.crypto.provider.SunJCE  </span><br><span class="line">security.provider.7=sun.security.jgss.SunProvider  </span><br><span class="line">security.provider.8=com.sun.security.sasl.Provider  </span><br><span class="line">security.provider.9=org.jcp.xml.dsig.internal.dom.XMLDSigRI  </span><br><span class="line">security.provider.10=sun.security.smartcardio.SunPCSC  </span><br><span class="line">security.provider.11=sun.security.mscapi.SunMSCAPI</span><br></pre></td></tr></table></figure><p>最后保存即可。</p>]]></content>
      
      
      <categories>
          
          <category> CoreJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoreJava </tag>
            
            <tag> JDK </tag>
            
            <tag> 问题处理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
